\chapter{Эффективный ML}
В этой главе мы обсудим некоторые техники и уловки, используя которые,
ML программисты делают свои программы более элегантными и
эффективными. Затем мы рассмотрим дополнительные {\em императивные}
возможности, которые могут быть задействованы, когда чистый
функциональный подход представляется неподходящим.

\section{Полезные комбинаторы}

Гибкость функций высшего порядка означает, что можно написать
небольшие, но весьма полезные функции, а затем многократно
использовать для множества сходных задач. Такие функции часто называют
{\em комбинаторами}, и не только потому, что они являются
$\lambda$-термами без свободных переменных. Эти функции зачастую
оказываются настолько гибкими, что путём их совместной комбинации
можно реализовать практически всё что угодно, вместо явного
рекурсивного определения.

Например, очень полезный комбинатор для операций над списками, часто
называемый `{\tt itlist}' или `{\tt fold}', выполняющий следующие
действия:
$$ \mbox{\tt itlist}\; f\; [x_1;\; x_2;\; \ldots \;; x_n]\; b =
f\; x_1\; (f\; x_2\; (f\; x_3\; ( \cdots (f\; x_n\; b)))) $$
\noindent Простое определение на ML:

\begin{boxed}\begin{verbatim}
  #let rec itlist f =
     fun [] b -> b
       | (h::t) b -> f h (itlist f t b);;
  itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
\end{verbatim}\end{boxed}

Довольно часто, рекурсивные функции на списках заключаются просто в
повторном применении некоторой функции к каждому элементу списка.
Используя {\tt itlist} с подходящим аргументом, такие функции можно
очень легко реализовать без явного использования рекурсии. Типичный
пример~-- нахождение суммы всех элементов списка из целых чисел.

\begin{boxed}\begin{verbatim}
  #let sum l = itlist (fun x sum -> x + sum) l 0;;
  sum : int list -> int = <fun>
  #sum [1;2;3;4;5];;
  - : int = 15
  #sum [];;
  - : int = 0
  #sum [1;1;1;1];;
  - : int = 4
\end{verbatim}\end{boxed}

\noindent Особо заинтересованные в краткости могут предпочесть
следующий код.

\begin{boxed}\begin{verbatim}
  #let sum l = itlist (prefix +) l 0;;
\end{verbatim}\end{boxed}

\noindent Легко изменить эту функцию для вычисления произведения,
вместо суммы.

\begin{boxed}\begin{verbatim}
  #let prod l = itlist (prefix *) l 1;;
\end{verbatim}\end{boxed}

Многие полезные функции над списками могут быть реализованы подобным
образом.  Например, вот функция, которая отбирает только те элементы
списка, которые удовлетворяют предикату:

\begin{boxed}\begin{verbatim}
  #let forall p l = itlist (fun h a -> p(h) & a) l true;;
  forall : ('a -> bool) -> 'a list -> bool = <fun>
  #let exists p l = itlist (fun h a -> p(h) or a) l false;;
  exists : ('a -> bool) -> 'a list -> bool = <fun>
  #forall (fun x -> x < 3) [1;2];;
  - : bool = true
  #forall (fun x -> x < 3) [1;2;3];;
  - : bool = false
\end{verbatim}\end{boxed}

\noindent Вот функция, проверяющая существуют ли в списке элементы,
удовлетворяющие предикату:

\begin{boxed}\begin{verbatim}
  #let forall p l = itlist (fun h a -> p(h) & a) l true;;
  forall : ('a -> bool) -> 'a list -> bool = <fun>
  #let exists p l = itlist (fun h a -> p(h) or a) l false;;
  exists : ('a -> bool) -> 'a list -> bool = <fun>
  #forall (fun x -> x < 3) [1;2];;
  - : bool = true
  #forall (fun x -> x < 3) [1;2;3];;
  - : bool = false
\end{verbatim}\end{boxed} 

А вот альтернативные версии {\tt length}, {\tt append} и {\tt map}:.

\begin{boxed}\begin{verbatim}
  #let length l = itlist (fun x s -> s + 1) l 0;;
  length : 'a list -> int = <fun>
  #let append l m = itlist (fun h t -> h::t) l m;;
  append : 'a list -> 'a list -> 'a list = <fun>
  #let map f l = itlist (fun x s -> (f x)::s) l [];;
  map : ('a -> 'b) -> 'a list -> 'b list = <fun>
\end{verbatim}\end{boxed}

Некоторые из этих функций сами по себе являются полезными
комбинаторами... Например, если мы хотим рассматривать списки как
множества, т.е. исключаем кратные элементы, то многие стандартные
операции на множествах очень просто выражаются в терминах только что
рассмотренных комбинаторов.

\begin{boxed}\begin{verbatim}
  #let mem x l = exists (fun y -> y = x) l;;
  mem : 'a -> 'a list -> bool = <fun>
  #let insert x l =
    if mem x l then l else x::l;;
  insert : 'a -> 'a list -> 'a list = <fun>
  #let union l1 l2 = itlist insert l1 l2;;
  union : 'a list -> 'a list -> 'a list = <fun>
  #let setify l = union l [];;
  setify : 'a list -> 'a list = <fun>
  #let Union l = itlist union l [];;
  Union : 'a list list -> 'a list = <fun>
  #let intersect l1 l2 = filter (fun x -> mem x l2) l1;;
  intersect : 'a list -> 'a list -> 'a list = <fun>
  #let subtract l1 l2 = filter (fun x -> not mem x l2) l1;;
  subtract : 'a list -> 'a list -> 'a list = <fun>
  #let subset l1 l2 = forall (fun t -> mem t l2) l1;;
  subset : 'a list -> 'a list -> bool = <fun>
\end{verbatim}\end{boxed}

\noindent Функция {\tt setify} предназначена для перевода списка в
множество, посредством исключения кратных элементов.

\section{Создание эффективного кода}

Здесь мы собрали несколько общих приёмов, с помощью которых часто
можно сделать ML программы существенно более эффективными. Для того,
чтобы оправдать некоторые из них, необходимо обрисовать в общих
словах, как определённые конструкции выполняются на <<железе>>.

\subsection{Хвостовая рекурсия и аккумуляторы}

Основной механизм управления в функциональных программах~-- рекурсия.
Если мы заинтересованы в эффективных программах, нам следует подумать
немного о том, как рекурсия реализуется на стандартном оборудовании. В
сущности, нет, или, по крайней мере, мало отличий между реализацией ML
и многими другими языками с динамическими переменными, таким как С. В
языках, не допускающих рекурсивных вызовов можно без опаски сохранять
все локальные переменные (включая и значения аргументов функции) в
фиксированной области памяти, так, например, сделано в FORTRAN. Тем не
менее, в общем случае, когда функция может вызываться рекурсивно, это
не допустимо: вызов функции {\tt f} с одним набором аргументов
содержит вызов {\tt f}, возможно, с другими аргументами. Это означает,
что старые значения аргументов будут переписаны, даже если они могут
потребоваться в дальнейшем, после вызова вложенной $f$. Поясним
сказанное на примере. Рассмотрим ещё раз функцию факториала:

\begin{boxed}\begin{verbatim}
  #let rec fact n = if n = 0 then 1
                    else n * fact(n - 1);;
\end{verbatim}\end{boxed} 

Вызов {\tt fact 6} приводит к последующему вызову {\tt fact 5} (и
далее), но когда вызов {\tt fact 5} закончен, и получен результат, нам
всё ещё требуется исходное значение {\tt n}, а именно $6$, для
произведения, дающего окончательный результат. Обычно в реализациях
поступают следующим образом: для каждого вызова функции выделяется
новый {\em стековый фрейм}. И каждый новый вызов функции передвигает
указатель стека далее вниз \footnote{Такая уж сложилась традиция -
  говорить, что стек "растёт" вниз.} стека, выделяя пространство под
новые переменные. В стековый фрейм и копируются значения аргументов
функции, её локальных переменных, иначе~-- {\em состояние выполнения}.
После того, как вызванная функция завершает выполнение, указатель на
стек перемещается обратно вверх, таким образом, ненужные внутренние
переменные автоматически отбрасываются.  Схема может прояснить
сказанное:

\bigskip
\bigskip

\begin{picture}(140,140)(0,0)

\put(140,0){\line(0,1){150}}
\put(220,0){\line(0,1){150}}
\put(140,0){\line(1,0){80}}
\put(60,0){\tt SP}
\put(80,4){\vector(1,0){60}}
\put(165,6){$n = 0$}
\put(140,20){\line(1,0){80}}
\put(165,26){$n = 1$}
\put(140,40){\line(1,0){80}}
\put(165,46){$n = 2$}
\put(140,60){\line(1,0){80}}
\put(165,66){$n = 3$}
\put(140,80){\line(1,0){80}}
\put(165,86){$n = 4$}
\put(140,100){\line(1,0){80}}
\put(165,106){$n = 5$}
\put(140,120){\line(1,0){80}}
\put(165,126){$n = 6$}
\put(140,140){\line(1,0){80}}
\end{picture}
\bigskip

Здесь изображён воображаемый снимок стека во время последнего
рекурсивного вызова, т.е. вычисления {\tt fact 0}. Все локальные
переменные от предыдущих вызовов собраны в стеке, с каждым экземпляром
функции, имеющим свой фрейм стека. По завершению вызовов указатель
стека {\tt SP} перемещается обратно вверх.

Следовательно, наша реализация {\tt fact} требует $n$ фреймов стека
для вычисления на аргументе $n$. Напротив, рассмотрим следующую
реализацию функции, вычисляющей факториал:

\begin{boxed}\begin{verbatim}
  #let rec tfact x n =
     if n = 0 then x
     else tfact (x * n) (n - 1);;
  tfact : int -> int -> int = <fun>
  #let fact n = tfact 1 n;;
  fact : int -> int = <fun>
  #fact 6;;
  - : int = 720
\end{verbatim}\end{boxed}

Хотя {\tt tfact} также рекурсивна, здесь рекурсивный вызов~-- итоговое
выражение, после него никаких вычислений не происходит; оно не
является подвыражением, частью другого выражения. Подобные вызовы
называются {\em хвостовыми вызовами} (потому что самые последние в
теле функции), а функция, в которой все рекурсивные вызовы суть
хвостовые, называется функцией с {\em хвостовой рекурсией}.

Что знаменательно в хвостовых вызовах? При рекурсивном вызове {\tt
  tfact} нет необходимости сохранять предыдущие значения локальных
переменных. Можно использовать одну и ту же фиксированную область
памяти для хранения переменных.  Будет ли это происходить на самом
деле, разумеется, зависит от того, насколько компилятор способен
обнаружить наличие хвостовой рекурсии в коде. Большинство известных
компиляторов, включая CAML, хвостовую рекурсию обнаруживают.
Следовательно, оформление функции таким образом, что рекурсивный вызов
является хвостовым, может существенно сократить использование памяти.
Для таких функций как факториал, едва ли возможен вызов на столь
больших значениях аргументов $n$, что переполнится стек. Однако,
наивная реализация многих функций над списками, может привести к
подобному результату когда списки длинны.

Дополнительный аргумент {\tt x} функции {\tt tfact} называется {\em
  аккумулятором}, потому что он накапливает промежуточные результаты по
ходу рекурсивных вызовов и, в конце концов, возвращается как значение
функции. Оформление кода таким способом~-- самый простой способ
сделать рекурсивную функцию хвостовой рекурсией.

Мы отметили, что в функциях с хвостовой рекурсии для аргументов может
использоваться фиксированная область памяти. С этой точки зрения можно
рассматривать такую рекурсию как завуалированную реализацию
императивного цикла. Вот очевидная параллель с реализацией факториала
на C:

\begin{verbatim}
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{verbatim}

Инициализация {\tt x = 1} соответствует присваиванию $1$ переменной
{\tt x}. Основной цикл соответствует рекурсивным вызовам, с тем лишь
отличием, что для функции с хвостовой рекурсией мы явно передаём
состояние через аргументы.  Вместо присваивания и введения циклов, мы
делаем рекурсивный вызов с обновлёнными переменными.  Используя
похожие приёмы и выражая состояние явно, можно легко писать в сущности
императивный код в якобы функциональном стиле. Мы ведь знаем, после
оптимизаций стандартными компиляторами машинный код будет один и тот
же в обоих случаях.
% COMMENT# 'состояние' тут это набор переменных, которые меняются по
% ходу цикла

\subsection{Минимизация операций cons}

Мы рассмотрели как используется пространство стековой памяти. Но
различные конструкции в функциональных программах могут использовать
память и другого типа, память обычно выделяемую в области, называемой
{\em кучей}. Тогда как стек последовательным образом растёт и
сокращается, управляемый последовательностью вызовов функций, эта
память не может быть освобождена таким же простым способом. Вместо
этого исполняющей системе время от времени требуется проверять какая
часть выделенной памяти больше не используется, и освобождать её для
дальнейших вычислений, этот процесс известен как {\em сборка мусора}.
Особенно важный пример здесь~-- это память, используемая
конструкторами рекурсивных типов, например, при вызове {\tt ::}. Так,
когда следующий фрагмент выполняется:

\begin{boxed}\begin{lstlisting}
  let l = 1::[] in tl l;;
\end{lstlisting}\end{boxed}

\noindent новый блок памяти, именуемый <<cons-ячейка>>, выделяется для
хранения результата работы конструктора {\tt ::} . Обычно это три
слова памяти, одно является идентификатором конструктора, а два других
являются указателями на голову и хвост списка. В общем случае, решение
по поводу того, когда память может быть освобождена, представляет
собой сложную задачу. Для нашего примера, мы сразу возвращаем хвост
списка, так что, очевидно, cons-ячейка может быть освобождёна
немедленно.  Но, в общем случае, из текста программы столь очевидные
выводы сделать затруднительно, поскольку $l$ может быть, например,
передан различным функциям, которые, могут просматривать элементы
списка. Так что необходимо динамически анализировать использование
памяти и выполнять сборку мусора. В противном случае мы рискуем
исчерпать память.

Разработчики функциональных языков усердно работают над алгоритмами более эффективной сборки мусора. Некоторые заявляют, что автоматическое выделение памяти и сборка мусора работают быстрее, чем в обычном  использовании явного выделения памяти в языках, подобных $C$ ({\tt malloc} и пр.) Хотя мы не пойдём так далеко, конечно, представляется очень удобным, что память всегда выделяется автоматически. Это позволяет избежать многих тех моментов в  программировании, которые печально известны своей утомительностью и подверженностью к ошибкам.

Многие любимые функциональными программистами конструкции используют
память, а она управляется сборщиком мусора. Хотя чрезмерное внимание к
этому может повредить функциональному стилю программ, есть некоторые
простые соображения, которые стоит учитывать во избежание неуместного
расходования памяти. Очень простое правило заключается в том, следует
избегать использования {\tt append} если возможно. Как видим, при
развёртывании рекурсивных вызовов согласно определению

\begin{boxed}\begin{verbatim}
  #let rec append l1 l2 =
     match l1 with
       [] -> l2
     | (h::t) -> h::(append t l2);;
\end{verbatim}\end{boxed}

\noindent порождает $n$ cons-ячеек, где $n$ длина первого списка. Есть
много способов заменить {\tt append}, например, с помощью добавления к
функциям дополнительных аргументов~- - аккумуляторов. Замечательный
пример~-- функция обращения списка, которую мы раньше кодировали как:

\begin{boxed}\begin{verbatim}
  #let rec rev =
     fun [] -> []
       | (h::t) -> append (rev t) [h];;
\end{verbatim}\end{boxed}

Что порождает порядка $n^2 / 2$ cons-ячеек, где $n$ это длина списка.
Следующая альтернатива, используя аккумулятор, генерирует только $n$
из них:

\begin{boxed}\begin{verbatim}

  #let rev =
     let rec reverse acc =
       fun [] -> acc
         | (h::t) -> reverse (h::acc) t in
     reverse [];;
\end{verbatim}\end{boxed}

Более того, ядро рекурсии {\tt reverse}~-- хвостовая рекурсия, так что
мы также сохраняем стековую память и, таким образом, дважды в
выигрыше.

Как пример другой типичной ситуации, когда посредством разумного
использования аккумуляторов мы можем избежать вызовов {\tt append},
рассмотрим задачу по нахождению списка терминальных элементов
бинарного дерева. Если мы зададим тип бинарных деревьев следующим
образом:

\begin{boxed}\begin{verbatim}
  #type btree = Leaf of string
              | Branch of btree * btree;;
\end{verbatim}\end{boxed}

\noindent то решением задачи будет:

\begin{boxed}\begin{verbatim}
  #let rec fringe =
     fun (Leaf s) -> [s]
       | (Branch(l,r)) -> append (fringe l) (fringe r);;
\end{verbatim}\end{boxed}

\noindent Однако следующая улучшенная версия выполняется с меньшими
затратами:

\begin{boxed}\begin{verbatim}
  #let fringe =
     let rec fr t acc =
       match t with
         (Leaf s) -> s::acc
       | (Branch(l,r)) -> fr l (fr r acc) in
     fun t -> fr t [];;
\end{verbatim}\end{boxed}

Заметьте, мы переписали второй аргумент~-- аккумулятор, так что теперь
рекурсивный вызов более понятен при чтении слева-направо. Вот простой
пример, как может использоваться любая из версий {\tt fringe}:

\begin{boxed}\begin{verbatim}
  #fringe (Branch(Branch(Leaf "a",Leaf "b"),
                  Branch(Leaf "c",Leaf "d")));;
  - : string list = ["a"; "b"; "c"; "d"]
\end{verbatim}\end{boxed}

Первая версия создаёт $6$ cons-ячеек, вторая~-- только $4$. На больших
деревьях эффект будет более впечатляющим. Ещё неуместная операция cons
случается при сопоставлении с образцом. Например, рассмотрим фрагмент
кода:

\begin{boxed}\begin{lstlisting}
  fun [] -> []
    | (h::t) -> if h < 0 then t else h::t;;
\end{lstlisting}\end{boxed}

Ветка, соответствующая `else' создаёт cons-ячейку несмотря на то, что
эта же конструкция уже передавалась как аргумент функции. То есть,
аргумент берётся и повторно реконструируется. Чтобы подобных издержек
не было, следует кодировать функцию следующим образом:

\begin{boxed}\begin{lstlisting}
  fun l ->
    match l with
      [] -> []
    | (h::t) -> if h < 0 then t else l;;
\end{lstlisting}\end{boxed}

Тем не менее, ML предлагает более гибкую альтернативу: использование
ключевого слова {\tt as}. С его помощью мы можем именовать
определённые части образцов, так что впоследствии возможно их
использование без реконструкции. Например:

\begin{boxed}\begin{lstlisting}
  fun [] -> []
    | (h::t as l) -> if h < 0 then t else l;;
\end{lstlisting}\end{boxed}

\subsection{Принудительное вычисление}

Мы отмечали, что можно использовать $\lambda$-абстракцию для
приостановки вычислений, так как ML не вычисляет выражения под
$\lambda$-абстракциями.  Некоторые интересные примеры мы рассмотрим
позже.  С другой стороны, может статься кому-то потребуется
принудительное вычисление выражений под $\lambda$-абстракциями.
Например:

\begin{boxed}\begin{verbatim}
  #let rec tfact x n =
     if n = 0 then x
     else tfact (x * n) (n - 1);;
  #let fact n = tfact 1 n;;
\end{verbatim}\end{boxed}

Поскольку мы в действительности никогда непосредственно {\tt tfact} не
используем, представляется нецелесообразным закреплять имя за этой
функцией. Взамен, мы можем сделать её локальной:

\begin{boxed}\begin{verbatim}
  #let fact1 n =
     let rec tfact x n =
       if n = 0 then x
       else tfact (x * n) (n - 1) in
     tfact 1 n;;
\end{verbatim}\end{boxed}

Здесь, однако, недостаток: локальное рекурсивное определение
вычисляется только после того, как {\tt fact1} получает свой аргумент,
поскольку до этого оно находится под $\lambda$-абстракцией. Более
того, оно вычисляется каждый раз, при вызове {\tt fact}. Мы можем
поправить это так:
 
\begin{boxed}\begin{verbatim}
  #let fact2 =
     let rec tfact x n =
       if n = 0 then x
       else tfact (x * n) (n - 1) in
     tfact 1;;
\end{verbatim}\end{boxed}

Теперь локальное связывание вычисляется лишь один раз, во время
объявления {\tt fact2}. В соответствии с нашими испытаниями, вторая
версия {\tt fact} примерно на $20 \%$ быстрее, при заданном аргументе
{\tt 6}.  FIXME (?The additional evaluation doesn't amount to much in
this case, more or less just unravelling a recursive definition, yet
the speedup is significant.  Дополнительное вычисление в данном случае
значения особого не имеет, хотя и даёт более точное определение данной
функции, к тому же скорость вычисления больше. SKIP ?) В тех случаях,
когда при локальном связывании требуется больше вычислений, отличие
может быть более впечатляющим. На самом деле ведутся сложные
исследования в области <<частичных вычислений>> посвящённые этим, а
также более изощрённым оптимизациям. В известном смысле, это обобщение
стандартных оптимизаций, таких как <<сворачивание констант>> для
компилятора обычных языков.  Однако, в рабочих системах ML
ответственность за принудительные вычисления обычно возлагается на
пользователя, как в примере выше.

Мимоходом заметим, что для функций собранных из совокупности
комбинаторов, с не особо явными $\lambda$-абстракциями, больше
возможностей, во время декларации вычислить на столько большую часть
выражения, насколько возможно. То есть, вот простейший пример: $f
\circ g$ выполнит все вычисления возможные в $f$ и $g$, тогда как
$\lamb{x} f(g\; x)$ не будет ничего вычислять, до тех пор, пока не
получит аргумента. С другой стороны, когда мы действительно {\em
  хотим} отложить вычисление, нам, действительно, нужна
$\lambda$-абстракция, так что исключительно комбинаторная версия
невозможна.

\section{Императивные возможности}

ML обладает довольно широкими возможностями для императивного
программирования. Мы не будем тратить время на императивный стиль
программирования, поскольку не это цель нашего курса, и мы
предполагаем что у читателя уже есть достаточно опыта. Следовательно,
мы бегло рассмотрим эти вопросы с несколькими иллюстрирующими
примерами.  Тем не менее, некоторые императивные возможности будут
использоваться далее в примерах, и некоторое знание того, что можно
использовать будет хорошим подспорьем при написании настоящего ML
кода.

\subsection{Исключения}

Мы знаем, что иногда в вычислениях происходят исключительные ситуации,
и вычисление не завершается правильным образом. Например, вследствие
неудачных сопоставлений с образцом. Есть и другие причины для
критических ошибок, например попытка деления на ноль.

\begin{boxed}\begin{verbatim}
  #1 / 0;;
  Uncaught exception: Division_by_zero
\end{verbatim}\end{boxed}

Во всех этих случаях компилятор сообщает о <<необработанном
исключении>>. Исключение~-- это признак ошибки, индикация того, что
вычисления пошли неправильным путём, при этом часто бывает ошибки
можно обработать локально. Также, для {\em исключений} есть тип {\tt
  exn}, который фактически является рекурсивным типом, хотя обычно он
рекурсивный только номинально.  В отличии от обычных типов, для типа
{\tt exn} допустимо вводить конструкторы в любом месте программы,
используя объявления исключений, например:

\begin{boxed}\begin{verbatim}
  #exception Died;;
  Exception Died defined.
  #exception Failed of string;;
  Exception Failed defined.
\end{verbatim}\end{boxed}

В то время как обычно исключения генерирует определённая совокупность
операций, этого же можно добиться прямым использованием конструктора
{\tt raise}, например:
\begin{boxed}\begin{verbatim}
  #raise (Failed "I don't know why");;
  Uncaught exception: Failed "I don't know why"
\end{verbatim}\end{boxed}

Мы можем создать своё собственное исключение на случай попытки взять
первый элемент в пустом списке:

\begin{boxed}\begin{verbatim}
  #exception Head_of_empty;;
  Exception Head_of_empty defined.
  #let hd = fun [] -> raise Head_of_empty
              | (h::t) -> h;;
  hd : 'a list -> 'a = <fun>
  #hd [];;
  Uncaught exception: Head_of_empty
\end{verbatim}\end{boxed}

Обычно исключения последовательно передаются <<наверх>>\footnote{По
  стеку вызовов функций}, но оно, также, может быть <<перехвачено>> и
обработано в окружении функции, с помощью конструкции {\tt try \ldots
  with}, сопровождаемой вариантами исключений:

\begin{boxed}\begin{verbatim}
  #let headstring sl =
     try hd sl
     with Head_of_empty -> ""
        | Failed s -> "Failure because "^s;;
  headstring : string list -> string = <fun>
  #headstring ["hi"; "there"];;
  - : string = "hi"
  #headstring [];;
  - : string = ""
\end{verbatim}\end{boxed}

Являются ли исключения императивной возможностью, в действительности,
это на самом деле вопрос убеждений. С одной стороны, можно считать,
что функции возвращают элементы составного типа~-- собственно из
возвращаемого типа, декларируемого явно, и типа исключений. С другой
стороны, исключения предлагают извращённое, не локальное управление
потоком исполнения, наподобие {\tt goto}.\footnote{Возможно, более
  подходящим примером будут {\tt setjmp} и {\tt longjmp} из C.} Какой
бы смысл в них не вкладывался, исключения часто могут быть весьма
полезны.

\subsection{Ссылки и массивы}

В ML есть настоящие переменные, к которым можно присваивать, и
выражения могут в качестве побочного эффекта изменять значения этих
переменных.  Доступ к переменным осуществляется с помощью {\em ссылок}
(указателей, говоря языком C), и ссылки в свою очередь рассматриваются
в ML как обычные значения.  Действительно, этот подход довольно похож
на использование указателей в C. Например, в C, когда требуется
использовать <<изменяемые параметры>>~-- параметры, для которых
допустимо изменение значений после вычисления функции, используется
передача параметров по указателю. Подобная техника часто используется,
когда функция должна возвращать сложные составные данные.

В ML, запись {\tt ref x} означает объявление и инициализацию ячейки
памяти значением {\tt x} . Инициализация обязательна. Это выражение
выдаёт ссылку (указатель) на ячейку в памяти. Последовательный доступ
к содержимому памяти требует явного разыменования указателя с помощью
оператора {\tt !}, сходного с унарным {\tt *} в C. Вот как это
делается:

\begin{boxed}\begin{verbatim}
  #let x = ref 1;;
  x : int ref = ref 1
  #!x;;
  - : int = 1
  #x := 2;;
  - : unit = ()
  #!x;;
  - : int = 2
  #x := !x + !x;;
  - : unit = ()
  #x;;
  - : int ref = ref 4
  #!x;;
  - : int = 4
\end{verbatim}\end{boxed}

Заметьте, что во многих отношениях {\tt ref} ведёт себя подобно
конструктору типа, а значит, может использоваться в сопоставлении с
образцом.  Следовательно, оператор разыменования {\tt !} можно было бы
определить как:

\begin{boxed}\begin{verbatim}
  #let contents_of (ref x) = x;;
  contents_of : 'a ref -> 'a = <fun>
  #contents_of x;;
  - : int = 4
\end{verbatim}\end{boxed}

Будучи изменяемыми, ссылки иногда полезны для создания разделяемых
структур данных. Можно легко создавать структуры типа граф, с узлами,
содержащими указатель на подграф.

Кроме отдельных ячеек, также в ML можно использовать массивы. В CAML
они называются {\tt векторами}. Массив элементов типа $\alpha$ имеет
тип $\alpha\; vect$. Новый вектор размера {\tt n}, где каждый элемент
проинициализирован значением {\tt x} (опять же, инициализация
обязательна) создаётся с помощью следующего вызова:

\begin{boxed}\begin{verbatim}
  #make_vect n x;;
\end{verbatim}\end{boxed}

\noindent Можно прочесть элемент {\tt m} вектора {\tt v} с помощью:

\begin{boxed}\begin{verbatim}
  #vect_item v m;;
\end{verbatim}\end{boxed}

\noindent а записать значение {\tt y} в {\tt m}-й элемент  {\tt v}:

\begin{boxed}\begin{verbatim}
  #vect_assign v m y;;
\end{verbatim}\end{boxed}

Эти операции соответствуют выражениям {\tt v[m]} и {\tt v[m] = y} в
C. Элементы массива нумеруются с нуля. Например:

\begin{boxed}\begin{verbatim}
  #let v = make_vect 5 0;;
  v : int vect = [|0; 0; 0; 0; 0|]
  #vect_item v 1;;
  - : int = 0
  #vect_assign v 1 10;;
  - : unit = ()
  #v;;
  - : int vect = [|0; 10; 0; 0; 0|]
  #vect_item v 1;;
  - : int = 10
\end{verbatim}\end{boxed}

\noindent Все операции чтения и записи элементов сопровождаются
контролем границ, например:

\begin{boxed}\begin{verbatim}
  #vect_item v 5;;
  Uncaught exception: Invalid_argument "vect_item"
\end{verbatim}\end{boxed}

\subsection{Последовательность вычислений}

В ML нет необходимости указывать последовательность вычислений,
поскольку обычные правила вычисления предполагают порядок. Например:

\begin{boxed}\begin{verbatim}
  #let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   ();;
\end{verbatim}\end{boxed}

\noindent выражения вычисляются в ожидаемом порядке. Здесь мы
используем специальный образец {\tt \_}, который не привязывает
значение к конкретному имени. Тем не менее, более заманчиво
использовать определённые обозначения для установления
последовательности вычислений.  В ML это возможно с помощью точки с
запятой:

\begin{boxed}\begin{verbatim}
  #x := !x + 1;
   x := !x + 1;
   x := !x + 1;
   x := !x + 1;;
\end{verbatim}\end{boxed}

\subsection{Работа с системой типов}

Хотя полиморфизм очень хорош для чисто функциональной части ML,
взаимодействие с некоторыми императивными возможностями построено
неудачно. Например, рассмотрим следующее:

\begin{boxed}\begin{verbatim}
  #let l = ref [];;
\end{verbatim}\end{boxed}

Может показаться {\tt l} имеет полиморфный тип $\alpha\; list\; ref$.
В соответствии со стандартнымиe правилами вывода по полиморфизму мы
могли бы использовать {\tt l} с двумя различными типами, сначала

\begin{boxed}\begin{verbatim}
  #l := [1];;
\end{verbatim}\end{boxed}

\noindent и затем

\begin{boxed}\begin{verbatim}
  #hd(!l) = true;;
\end{verbatim}\end{boxed}

Но это не приемлемо, поскольку фактически мы могли бы записывать нечто
как объект типа {\tt int}, а затем читать как объект типа {\tt bool}.
Следовательно, когда используются ссылки, требуются некоторые
ограничения на привычные правила let-полиморфизма. Было много
предложений по подходящему ограничению системы типов, некоторые из
которых весьма запутанные. Недавно различные версии ML похоже
сошлись к относительно простому методу, называемому {\em ограничением
  значения}, \citeN{wright-example}, и CAML обеспечивает это
ограничение. В самом деле, вышеупомянутая последовательность не
выполняется. Но интересно промежуточное поведение. Если мы посмотрим
на первую линию, мы увидим:
% BUG# может всё-таки 'строку', а не линию? --lg

\begin{boxed}\begin{verbatim}
  #let l = ref [];;
  l : '_a list ref = ref []
\end{verbatim}\end{boxed}

Подчёркивание перед типом переменной обозначает что {\tt l} не
полиморфна в привычном смысле; скорее она имеет один фиксированный
тип, хотя тип этот всё ещё неопределён. Следующая строчка работает
отлично:

\begin{boxed}\begin{verbatim}
  #l := [1];;
  - : unit = ()
\end{verbatim}\end{boxed}

\noindent но если посмотреть на тип {\tt l}, то мы увидим:

\begin{boxed}\begin{verbatim}
  #l;;
  - : int list ref = ref [1]
\end{verbatim}\end{boxed}

Теперь установлен псевдо-полиморфный тип. Благодаря этому, ясно, что
следующая линия даст ошибку:
% BUG# строка?

\begin{boxed}\begin{verbatim}
  #hd(!l) = true;;
  Toplevel input:
  >hd(!l) = true;;
  >         ^^^^
  This expression has type bool,
  but is used with type int.
\end{verbatim}\end{boxed}

Пока это представляется вполне оправданным, но мы ещё не объяснили
почему такие типовые переменные с подчёркиванием встречаются и в
довольно безобидных чисто функциональных выражениях и более того
почему они часто исчезают при $\eta$-раскрытии, например:

\begin{boxed}\begin{verbatim}
  #let I x = x;;
  I : 'a -> 'a = <fun>
  #I o I;;
  it : '_a -> '_a = <fun>
  #let I2 = I o I in fun x -> I2 x;;
  - : '_a -> '_a = <fun>
  #fun x -> (I o I) x;;
  it : 'a -> 'a = <fun>
\end{verbatim}\end{boxed}

Другие методы для полиморфных ссылок зачастую зависят от
закодированной в типах информации о том, что выражение может содержать
ссылки. Это кажется вполне естественным, но такой подход может
привести к типам функций захламлённым этой специальной информацией.
Представляется непривлекательным, что в типе функции должен отражаться
факт того, как функция реализована~-- императивно ли или чисто
функционально.

Решение Врайта, с другой стороны, использует только основной синтаксис
let-связанного выражения и перед обобщением типа утверждает, что оно
является так называемым {\em значением}. Чего действительно хотелось
бы, так это знать: может ли вычисление выражения привести к побочным
эффектам.  Но, поскольку в общем случае это неразрешимо, то чтобы
выяснить является ли выражение значением или нет, используется простой
синтаксический критерий.  Грубо говоря, выражение является значением
если оно не допускает дальнейших вычислений по правилам ML~--- вот
почему выражение часто может быть обращено в значение, посредством
обратного $\eta$-преобразования. К сожалению, это работает против
методов оптимизации при помощи принудительных вычислений.

\section*{Упражнения}

\begin{enumerate}

\item Определим $C$ комбинатор следующим образом:

\begin{boxed}\begin{verbatim}
  #let C f x y = f y x;;
\end{verbatim}\end{boxed}

Что делает эта функция?

\begin{boxed}\begin{verbatim}
  #fun f l1 l2 -> itlist (union o C map l2 o f) l1 [];;
\end{verbatim}\end{boxed}

\item Что делает эта функция? Напишите более эффективную версию.

\begin{boxed}\begin{verbatim}
  #let rec upto n = if n < 1 then [] else append (upto (n-1)) [n];;
\end{verbatim}\end{boxed}

\item Определим функцию, вычисляющую числа Фибоначчи:

\begin{boxed}\begin{verbatim}
  #let rec fib =
     fun 0 -> 0
       | 1 -> 1
       | n -> fib(n - 2) + fib(n - 1);;
\end{verbatim}\end{boxed}

Почему эта функция неэффективна? Предложите лучшую реализацию.

\item Предложите пример использования данного или подобного
  рекурсивного исключения.

\begin{boxed}\begin{verbatim}
  #exception Recurse of exn;;
\end{verbatim}\end{boxed}

\item Напишите простую версию быстрой сортировки на массивах. Сначала
  массив разделяется на две части по некоторому элементу, затем на
  левой части и на правой рекурсивно вызывается sort. Какой
  рекурсивный вызов является хвостовым?  Сколько требуется памяти в
  худшем случае? Как с помощью небольшого изменения в коде добиться
  значительной оптимизации?

\item Докажите, что обе версии {\tt rev}, что мы упомянули, всегда
  дают одинаковый результат.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:

