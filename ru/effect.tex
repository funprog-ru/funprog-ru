\chapter{Эффективный ML}
В этой главе мы обсудим некоторые техники и уловки, используя которые, ML программисты делают свои программы более элегантными  и эффективными. Затем мы рассмотрим дополнительные {\em императивные} возможности, которые могут быть задействованы, когда чистый функциональный подход представляется неподходящим.

\section{Полезные комбинаторы}

Гибкость функций высшего порядка означает, что можно написать небольшие, но весьма полезные функции, а затем многократно использовать для  множества сходных задач. Такие функции часто называют {\em комбинаторами}, и не только потому, что они являются $\lambda$ {\em - выражениями} без свободных переменных. Зачастую эти функции  оказываются настолько гибки, что практически что угодно может быть реализовано путём их совместной  комбинации,  вместо явного рекурсивного задания.

Например, очень полезный комбинатор для операций над списками, часто называемый `{\tt itlist}' или `{\tt fold}', выполняющий следующие действия:
$$ \mbox{\tt itlist}\; f\; [x_1;\; x_2;\; \ldots \;; x_n]\; b =
f\; x_1\; (f\; x_2\; (f\; x_3\; ( \cdots (f\; x_n\; b)))) $$
\noindent Простое определение на ML:

\begin{boxed}\begin{verbatim}
  #let rec itlist f =
     fun [] b -> b
       | (h::t) b -> f h (itlist f t b);;
  itlist : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b = <fun>
\end{verbatim}\end{boxed}

Довольно часто, рекурсивные функции на списках заключаются просто в повторном применении некоторой функции к каждому элементу списка. Используя   {\tt itlist} с подходящим аргументом, такие функции можно очень легко реализовать без явного использования рекурсии. Типичный пример - нахождение суммы всех элементов списка из целых чисел.

\begin{boxed}\begin{verbatim}
  #let sum l = itlist (fun x sum -> x + sum) l 0;;
  sum : int list -> int = <fun>
  #sum [1;2;3;4;5];;
  - : int = 15
  #sum [];;
  - : int = 0
  #sum [1;1;1;1];;
  - : int = 4
\end{verbatim}\end{boxed}

\noindent Т.е.  увлекающиеся сокращениями могут предпочесть следующий код.

\begin{boxed}\begin{verbatim}
  #let sum l = itlist (prefix +) l 0;;
\end{verbatim}\end{boxed}

\noindent Легко изменить эту функцию для произведения, вместо суммы.

\begin{boxed}\begin{verbatim}
  #let prod l = itlist (prefix *) l 1;;
\end{verbatim}\end{boxed}

Многие полезные функции над списками могут быть получены подобным образом.
Например, вот функция, которая отбирает только те элементы списка, которые удовлетворяют предикату:

\begin{boxed}\begin{verbatim}
  #let forall p l = itlist (fun h a -> p(h) & a) l true;;
  forall : ('a -> bool) -> 'a list -> bool = <fun>
  #let exists p l = itlist (fun h a -> p(h) or a) l false;;
  exists : ('a -> bool) -> 'a list -> bool = <fun>
  #forall (fun x -> x < 3) [1;2];;
  - : bool = true
  #forall (fun x -> x < 3) [1;2;3];;
  - : bool = false
\end{verbatim}\end{boxed}

\noindent Вот функция, проверяющая существуют ли в списке элементы, удовлетворяющие предикату:

\begin{boxed}\begin{verbatim}
  #let forall p l = itlist (fun h a -> p(h) & a) l true;;
  forall : ('a -> bool) -> 'a list -> bool = <fun>
  #let exists p l = itlist (fun h a -> p(h) or a) l false;;
  exists : ('a -> bool) -> 'a list -> bool = <fun>
  #forall (fun x -> x < 3) [1;2];;
  - : bool = true
  #forall (fun x -> x < 3) [1;2;3];;
  - : bool = false
\end{verbatim}\end{boxed} 


А вот альтернативные версии {\tt length}, {\tt append} и {\tt map}:.

\begin{boxed}\begin{verbatim}
  #let length l = itlist (fun x s -> s + 1) l 0;;
  length : 'a list -> int = <fun>
  #let append l m = itlist (fun h t -> h::t) l m;;
  append : 'a list -> 'a list -> 'a list = <fun>
  #let map f l = itlist (fun x s -> (f x)::s) l [];;
  map : ('a -> 'b) -> 'a list -> 'b list = <fun>
\end{verbatim}\end{boxed}

Некоторые из этих функций сами по себе являются полезными комбинаторами... Например, если мы хотим рассматривать списки как множества, т.е. исключаем кратные элементы, то многие стандартные операции на множествах очень просто выражаются в терминах только что рассмотренных комбинаторов. 




\begin{boxed}\begin{verbatim}
  #let mem x l = exists (fun y -> y = x) l;;
  mem : 'a -> 'a list -> bool = <fun>
  #let insert x l =
    if mem x l then l else x::l;;
  insert : 'a -> 'a list -> 'a list = <fun>
  #let union l1 l2 = itlist insert l1 l2;;
  union : 'a list -> 'a list -> 'a list = <fun>
  #let setify l = union l [];;
  setify : 'a list -> 'a list = <fun>
  #let Union l = itlist union l [];;
  Union : 'a list list -> 'a list = <fun>
  #let intersect l1 l2 = filter (fun x -> mem x l2) l1;;
  intersect : 'a list -> 'a list -> 'a list = <fun>
  #let subtract l1 l2 = filter (fun x -> not mem x l2) l1;;
  subtract : 'a list -> 'a list -> 'a list = <fun>
  #let subset l1 l2 = forall (fun t -> mem t l2) l1;;
  subset : 'a list -> 'a list -> bool = <fun>
\end{verbatim}\end{boxed}

\noindent Функция {\tt setify} предназначена для перевода списка в множество, посредством исключения кратных элементов.

\section{Создание эффективного кода}

Здесь мы собрали несколько  общих приёмов, которые часто делают ML программы существенно более эффективными. Для того, чтобы оправдать некоторые из них, необходимо обрисовать в общих словах, как определённые конструкции выполняются  на "железе".

\subsection{Хвостовая рекурсия и аккумуляторы}

Основной механизм управления в функциональных программах - рекурсия. Если мы заинтересованы в эффективных программах, нам следует подумать немного о том, как рекурсия реализуется на стандартном оборудовании. В сущности,  нет, или, по крайней мере, мало отличий между реализацией ML и многих других языков с динамическими переменными, таких как С. В языках, не допускающих рекурсивных вызовов можно без опаски сохранять все локальные переменные (включая и значения аргументов функции) в фиксированной области памяти, так, например, сделано в FORTRAN. Тем не менее, в общем случае, когда функция может вызываться рекурсивно, это не допустимо: вызов функции {\tt f} с одним набором аргументов  содержит вызов {\tt f}, возможно, с другими аргументами. Это означает, что старые значения аргументов будут переписаны, даже если  они могут потребоваться в дальнейшем, после вызова вложенной $f$. Поясним сказанное на примере. Рассмотрим ещё раз функцию факториала:

\begin{boxed}\begin{verbatim}
  #let rec fact n = if n = 0 then 1
                    else n * fact(n - 1);;
\end{verbatim}\end{boxed} 

Вызов {\tt fact 6} приводит к последующему вызову {\tt fact 5} (и далее), но когда вызов {\tt fact 5}  закончен, и получен результат, нам всё ещё требуется исходное значение {\tt n}, а именно $6$, для произведения, дающего окончательный результат. Обычно в реализациях поступают следующим образом: для каждого вызова функции выделяется новый {\em стековый фрейм}. И каждый новый вызов функции передвигает указатель стека далее вниз \footnote{Такая уж сложилась традиция - говорить, что стек  "растёт" вниз.} стека, выделяя пространство под новые переменные. В стековый фрейм и копируются значения аргументов функции, её локальных переменных, иначе - {\em состояние выполнения}. После того, как вызванная функция завершает выполнение,  указатель на стек перемещается обратно вверх, таким образом, ненужные внутренние переменные автоматически отбрасываются. 
Схема может прояснить сказанное:

\bigskip
\bigskip

\begin{picture}(140,140)(0,0)

\put(140,0){\line(0,1){150}}
\put(220,0){\line(0,1){150}}
\put(140,0){\line(1,0){80}}
\put(60,0){\tt SP}
\put(80,4){\vector(1,0){60}}
\put(165,6){$n = 0$}
\put(140,20){\line(1,0){80}}
\put(165,26){$n = 1$}
\put(140,40){\line(1,0){80}}
\put(165,46){$n = 2$}
\put(140,60){\line(1,0){80}}
\put(165,66){$n = 3$}
\put(140,80){\line(1,0){80}}
\put(165,86){$n = 4$}
\put(140,100){\line(1,0){80}}
\put(165,106){$n = 5$}
\put(140,120){\line(1,0){80}}
\put(165,126){$n = 6$}
\put(140,140){\line(1,0){80}}
\end{picture}
\bigskip

Здесь изображён воображаемый снимок стека во время последнего рекурсивного вызова, т.е. вычисления {\tt fact 0}. Все локальные переменные от предыдущих вызовов собраны в стеке, с каждым экземпляром функции, имеющим свой фрейм стека. По завершению вызовов указатель стека {\tt SP} перемещается обратно вверх.

Следовательно, наша реализация {\tt fact} требует $n$ фреймов стека для вычисления на аргументе $n$. Напротив, рассмотрим следующую реализацию функции, вычисляющей факториал:

\begin{boxed}\begin{verbatim}
  #let rec tfact x n =
     if n = 0 then x
     else tfact (x * n) (n - 1);;
  tfact : int -> int -> int = <fun>
  #let fact n = tfact 1 n;;
  fact : int -> int = <fun>
  #fact 6;;
  - : int = 720
\end{verbatim}\end{boxed}

Хотя {\tt tfact} также рекурсивна, здесь рекурсивный вызов - окончательное выражение, после него никаких вычислений не происходит; оно не появляется как подвыражение, как часть другого выражения. Подобные вызовы называются {\em хвостовыми вызовами} (потому что самые последние в теле функции), а функция, в которой все рекурсивные вызовы суть хвостовые, называется {\em хвостовой рекурсией}.

Что знаменательно в хвостовых вызовах? При рекурсивном вызове {\tt tfact} нет необходимости сохранять предыдущие значения локальных переменных. Можно использовать одну и ту же фиксированную область памяти для хранения переменных.
Будет ли это происходить на самом деле, разумеется, зависит от того, насколько компилятор способен обнаружить наличие хвостовой рекурсии в коде. Большинство известных компиляторов, включая CAML, хвостовую рекурсию обнаруживают. Следовательно, оформление функции таким образом, что рекурсивный вызов является хвостовым, может существенно сократить использование памяти. Для функций, таких как факториал, едва ли возможен  вызов на столь больших значениях аргументов $n$, что переполнится стек. Однако, наивная реализация многих функций на списках, может привести к подобному результату когда списки длинны.

Дополнительный аргумент {\tt x} функции {\tt tfact} называется {\em акумулятором}, потому что он накапливает промежуточные результаты по ходу рекурсивных вызовов и, в конце концов, возвращается как значение функции. Оформление кода таким способом -самый простой способ сделать рекурсивную функцию хвостовой рекурсией.

Мы отметили, что для хвостовой рекурсии может для аргументов использоваться фиксированная область памяти. С этой точки зрения можно рассматривать такую рекурсию как завуалированную реализацию императивного цикла. Вот очевидная параллель с  реализацией факториала на C:

\begin{verbatim}
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{verbatim}

Инициализация {\tt x = 1} соответствует присваиванию $1$ переменной {\tt x}. Основной цикл соответствует рекурсивным вызовам, с тем лишь отличием, что 
FIX (? the arguments to the tail recursive function make explicit that part of the state we are interested in assigning to. ?). Вместо присваивания и введения циклов, мы делаем рекурсивный вызов с обновлёнными переменными.  Используя похожие приёмы и выражая состояние явно, можно легко писать в сущности императивный код в якобы функциональном стиле. Мы ведь знаем, после оптимизаций стандартными компиляторами машинный код будет один и тот же в обоих случаях.

\subsection{Минимизация конструкторов}

Мы рассмотрели как используется пространство стековой памяти. Но различные конструкции в функциональных программах могут  использовать память и другого типа, память обычно выделяемую в области, называемой {\em кучей}. Тогда как стек последовательным образом растёт и сокращается, управляемый последовательностью вызовов функций, эта память не может быть освобождена таким же простым способом. Вместо этого исполняющей системе время от времени  требуется проверять какая часть выделенной памяти больше не используются, и освобождать её для дальнейших вычислений, этот процесс известен как {\em сборка мусора}. Особенно важный пример здесь - это  память, используемая конструкторами рекурсивных типов, например, при вызове {\tt ::}. Так, когда следующий фрагмент выполняется:

\begin{boxed}\begin{lstlisting}
  let l = 1::[] in tl l;;
\end{lstlisting}\end{boxed}

\noindent новый блок памяти, именуемый `cons cell' FIX(?конструктор элемента?), выделяется для хранения ссылки на конструктор FIX (? экземпляра конструктора ?) {\tt ::} . Обычно это три слова памяти, одно является идентификатором конструктора, а два других являются указателями на голову и хвост списка. В общем случае, решение по поводу того, когда память может быть освобождена,  представляет собой сложную задачу. Для нашего примера,  мы сразу возвращаем хвост списка, так что, очевидно, cons cell также может быть освобожден немедленно. Но, в общем случае, из текста программы столь очевидные выводы сделать затруднительно, поскольку $l$ может быть, например, передан различным функциям, которые, могут просматривать элементы списка. Так что необходимо  динамически  анализировать использование памяти и выполнять сборку мусора. В противном случае мы рискуем исчерпать память.

Разработчики функциональных языков усердно работают над алгоритмами более эффективной сборки мусора. Некоторые заявляют, что автоматическое выделение памяти и сборка мусора работают быстрее, чем в обычном  использовании явного выделения памяти в языках, подобных $C$ ({\tt malloc} и пр.) Хотя мы не пойдём так далеко, конечно, представляется очень удобным, что память всегда выделяется автоматически. Это позволяет избежать многих тех моментов в  программировании, которые печально известны своей утомительностью и подверженностью к ошибкам.

Многие любимые функциональными программистами конструкции используют память, а она управляется сборщиком мусора. Хотя чрезмерное внимание к этому может повредить функциональному стилю программ, есть некоторые простые соображения, которые стоит учитывать во избежание неуместного расходования памяти. Очень простое правило заключается в том, следует избегать использования {\tt append} если возможно. Как видим, при развёртывании рекурсивных вызовов согласно определению

\begin{boxed}\begin{verbatim}
  #let rec append l1 l2 =
     match l1 with
       [] -> l2
     | (h::t) -> h::(append t l2);;
\end{verbatim}\end{boxed}

\noindent генерирует $n$ cons cells где $n$ длина первого списка. Есть много способов заменить {\tt append}, например, с помощью добавления к функциям дополнительных аргументов - аккумуляторов. Замечательный пример - функция обращения списка, которую мы раньше кодировали как:

\begin{boxed}\begin{verbatim}
  #let rec rev =
     fun [] -> []
       | (h::t) -> append (rev t) [h];;
\end{verbatim}\end{boxed}

Что генерирует около $n^2 / 2$ cons cells, где $n$ - длина списка. Следующая альтернатива, используя аккумулятор, генерирует только $n$ из них:

\begin{boxed}\begin{verbatim}

  #let rev =
     let rec reverse acc =
       fun [] -> acc
         | (h::t) -> reverse (h::acc) t in
     reverse [];;
\end{verbatim}\end{boxed}

Более того, ядро рекурсии {\tt reverse} - хвостовая рекурсия, так что мы также сохраняем стековую память и, таким образом, дважды в выигрыше.

Как пример другой типичной ситуации, когда посредством разумного использования аккумуляторов мы можем избежать вызовов {\tt append}, рассмотрим 
задачу по нахождению списка терминальных элементов бинарного дерева. Если мы зададим тип бинарных деревьев следующим образом:

\begin{boxed}\begin{verbatim}
  #type btree = Leaf of string
              | Branch of btree * btree;;
\end{verbatim}\end{boxed}

\noindent то решением задачи будет:

\begin{boxed}\begin{verbatim}
  #let rec fringe =
     fun (Leaf s) -> [s]
       | (Branch(l,r)) -> append (fringe l) (fringe r);;
\end{verbatim}\end{boxed}

\noindent Однако следующая улучшенная версия выполняется с меньшими затратами:

\begin{boxed}\begin{verbatim}
  #let fringe =
     let rec fr t acc =
       match t with
         (Leaf s) -> s::acc
       | (Branch(l,r)) -> fr l (fr r acc) in
     fun t -> fr t [];;
\end{verbatim}\end{boxed}

Заметьте, мы  переписали второй аргумент - аккумулятор, так что теперь рекурсивный вызов  более понятен при чтении слева - направо. Вот простой пример, как может использоваться любая из версий {\tt fringe}:

\begin{boxed}\begin{verbatim}
  #fringe (Branch(Branch(Leaf "a",Leaf "b"),
                  Branch(Leaf "c",Leaf "d")));;
  - : string list = ["a"; "b"; "c"; "d"]
\end{verbatim}\end{boxed}

Первая версия создаёт $6$ cons cells, вторая - только $4$. На больших деревьях эффект будет более впечатляющим. Ещё неуместное FIX (? consing ?) случается при сопоставлении с образцом. Например, рассмотрим фрагмент кода:

\begin{boxed}\begin{lstlisting}
  fun [] -> []
    | (h::t) -> if h < 0 then t else h::t;;
\end{lstlisting}\end{boxed}


Ветка, соответствующая `else' создаёт  cons cell несмотря на то, что эта же конструкция уже передавалась как аргумент функции. То есть, аргумент берётся и повторно реконструируется. Чтобы подобных издержек  не было, следует кодировать функцию следующим образом:

\begin{boxed}\begin{lstlisting}
  fun l ->
    match l with
      [] -> []
    | (h::t) -> if h < 0 then t else l;;
\end{lstlisting}\end{boxed}

Тем не менее, ML предлагает более гибкую альтернативу: использование ключевого слова {\tt as}. С его помощью мы можем именовать определённые части паттернов, так что впоследствии возможно их использование без реконструкции. Например:

\begin{boxed}\begin{lstlisting}
  fun [] -> []
    | (h::t as l) -> if h < 0 then t else l;;
\end{lstlisting}\end{boxed}

\subsection{Форсирование вычислений}

Мы отмечали, что, хотя ML does не вычисляет FIX (? Underneath - зависимые?) лямбды, можно использовать лямбды для приостановки вычислений. Некоторые интересные примеры мы рассмотрим позже.
С другой стороны, может статься кому - то потребуется форсировать вычисление FIX (?hidden underneath lambdas?)выражений. Например:

\begin{boxed}\begin{verbatim}
  #let rec tfact x n =
     if n = 0 then x
     else tfact (x * n) (n - 1);;
  #let fact n = tfact 1 n;;
\end{verbatim}\end{boxed}

Поскольку мы в действительности никогда непосредственно {\tt tfact} не используем, представляется нецелесообразным закреплять имя за этой функцией. Взамен, мы можем сделать её локальной:



\begin{boxed}\begin{verbatim}
  #let fact1 n =
     let rec tfact x n =
       if n = 0 then x
       else tfact (x * n) (n - 1) in
     tfact 1 n;;
\end{verbatim}\end{boxed}

Здесь, однако, недостаток: локальное рекурсивное определение вычисляется только после того, как {\tt fact1} получает свои аргументы, поскольку  до этого оно скрыто за лямбдой. Более того, оно вычисляется каждый раз, при вызове {\tt fact}. Мы можем поправить это так:
 
\begin{boxed}\begin{verbatim}
  #let fact2 =
     let rec tfact x n =
       if n = 0 then x
       else tfact (x * n) (n - 1) in
     tfact 1;;
\end{verbatim}\end{boxed}

Теперь локальное связывание вычисляется лишь один раз, в точке объявления 
{\tt fact2}. В соответствии с нашими испытаниями, вторая версия {\tt fact} примерно на $20 \%$ быстрее, когда вычисляется на {\tt 6}.
FIXME (?The additional evaluation doesn't amount to much in this case, more or less just unravelling a recursive
definition, yet the speedup is significant.
Дополнительное вычисление в данном случае значения особого не имеет, хотя и даёт более точное определение данной функции, к тому же скорость вычисления
больше. SKIP ?) В тех случаях, когда при локальном связывании требуется больше вычислений, отличие может быть более впечатляющим. На самом деле ведутся сложные исследования по `частичным вычислениям' посвящённые оптимизациям, подобным этой, а также более изощрённым. В известном смысле, это обобщение обычных оптимизаций компилятора для языков, таких как `постоянное свёртывание'.

Мимоходом заметим, что для функций собранных из совокупности комбинаторов, FIX ( с меньшим числом лямбд/ с менее выраженными лямбдами), больше возможностей, во время декларации вычислить на столько большую часть выражения, насколько возможно. То есть, вот простейший пример: $f \circ g$ будет выполнятся при каждом вычислении $f$ и $g$, тогда как $\lamb{x} f(g\; x)$ не выполнится ни разу, до тех пор, пока не получит аргумента. С другой стороны, когда мы действительно {\em хотим} отложить вычисление, нам, действительно, нужны лямбды, так что исключительно комбинаторная версия невозможна.

\section{Императивные возможности}

ML обладает довольно широкими возможностями для императивного программирования. Мы не будем тратить время на императивный стиль программирования, поскольку не это  цель нашего курса, и мы предполагаем читателя уже достаточно подготовленным. Следовательно, мы бегло рассмотрим эти вопросы с несколькими иллюстрирующими примерами. Тем не менее, некоторые императивные возможности будут использоваться далее в примерах, и некоторое знание того, что можно использовать будет хорошим подспорьем при написании настоящего ML кода.

\subsection{Исключения}

Мы знаем, что иногда в вычислениях происходят исключительные ситуации, и вычисление не завершается правильным образом. Например, вследствие неудачных сравнений по образцу. Есть и другие причины для критических ошибок, например попытка деления на ноль.

\begin{boxed}\begin{verbatim}
  #1 / 0;;
  Uncaught exception: Division_by_zero

\end{verbatim}\end{boxed}

Во всех этих случаях компилятор сообщает об `необработанных исключениях'. Исключение - это признак ошибки, индикация того, что вычисления пошли неправильным путём, при этом часто бывает ошибки можно обработать локально. Также, есть тип рекурсивных {\tt exn} {\em исключений}, хотя обычно они бесполезны. В отличие от обычных типов, для типов исключений конструкторы допустимо вводить в любом месте программы:

\begin{boxed}\begin{verbatim}
  #exception Died;;
  Exception Died defined.
  #exception Failed of string;;
  Exception Failed defined.
\end{verbatim}\end{boxed}

В то время как обычно исключения генерирует определённая совокупность операций, этого же можно добиться прямым использованием  конструктора{\tt raise}, например:
\begin{boxed}\begin{verbatim}
  #raise (Failed "I don't know why");;
  Uncaught exception: Failed "I don't know why"
\end{verbatim}\end{boxed}

Мы можем изобрести своё собственное исключение на случай попытки взять первый элемент в пустом списке:

\begin{boxed}\begin{verbatim}
  #exception Head_of_empty;;
  Exception Head_of_empty defined.
  #let hd = fun [] -> raise Head_of_empty
              | (h::t) -> h;;
  hd : 'a list -> 'a = <fun>
  #hd [];;
  Uncaught exception: Head_of_empty
\end{verbatim}\end{boxed}

Обычно исключения последовательно передаются "наверх"\footnote{По стеку вызовов функций}, но оно, также, может быть `перехвачено' в окружении функции, с помощью конструкции {\tt try \ldots with}, сопровождаемой вариантами исключений: 

\begin{boxed}\begin{verbatim}
  #let headstring sl =
     try hd sl
     with Head_of_empty -> ""
        | Failed s -> "Failure because "^s;;
  headstring : string list -> string = <fun>
  #headstring ["hi"; "there"];;
  - : string = "hi"
  #headstring [];;
  - : string = ""
\end{verbatim}\end{boxed}

Являются ли исключения императивной возможностью, в действительности, это на самом деле вопрос убеждений. С одной стороны, можно считать функции  возвращают элементы составного типа - собственно из возвращаемого типа, декларируемого явно, и типа исключений. С другой стороны, исключения предлагают извращённое, не локальное управление потоком исполнения, наподобие {\tt goto}.\footnote{Возможно, более подходящм примером будут {\tt setjmp} и {\tt longjmp} из C.} Какой бы смысл в них не вкладывался, исключения часто могут быть весьма полезны.

\subsection{Ссылки и массивы}

ML имеет настоящие  присваиваемые переменные, и выражения могут, с побочными эффектами, изменять значения этих переменных. Они допускают явное обращение через {\em ссылки} (указатели, говоря языком C) и ссылки эти рассматриваются в ML как обычные значения. Действительно, этот подход довольно похож на использование указателей в C. Например, в C, когда требуется использовать 'изменяемые параметры' - параметры, для которых допустимо  изменение значений после вычисления функции, используется передача параметров по указателю. Подобная техника часто используется, когда функция должна возвращать сложные составные данные.

В ML, запись {\tt ref x} означает объявление и инициализацию ячейки памяти значением {\tt x} . Инициализация обязательна. Это выражение задаёт  ссылку (указатель) на ячейку в памяти. Последовательный доступ к содержимому памяти требует явного разыменования указателя с помощью оператора {\tt !}, сходного с унарным {\tt *} в C. Вот как это делается:

\begin{boxed}\begin{verbatim}
  #let x = ref 1;;
  x : int ref = ref 1
  #!x;;
  - : int = 1
  #x := 2;;
  - : unit = ()
  #!x;;
  - : int = 2
  #x := !x + !x;;
  - : unit = ()
  #x;;
  - : int ref = ref 4
  #!x;;
  - : int = 4
\end{verbatim}\end{boxed}

Заметьте, что в большинстве отношений {\tt ref} ведёт себя подобно конструктору типа, а значит, может использоваться  в сравнении по шаблону. Следовательно, можно было бы  оператор разыменования  {\tt !} задать: 


\begin{boxed}\begin{verbatim}
  #let contents_of (ref x) = x;;
  contents_of : 'a ref -> 'a = <fun>
  #contents_of x;;
  - : int = 4
\end{verbatim}\end{boxed}

Будучи изменяемыми, ссылки иногда полезны для создания  разделяемых структур данных. Можно легко создавать структуры типа граф, с узлами, содержащими указатель на подграф.

Кроме отдельных ячеек, также в ML можно использовать массивы. В CAML они называются {\tt векторами}. Массив элементов типа $\alpha$ имеет тип $\alpha\; vect$. Новый вектор размера {\tt n}, с каждым элементом проинициализированным значением {\tt x} - такая однократная инициализация обязательна  - создаётся с помощью следующего вызова:

\begin{boxed}\begin{verbatim}
  #make_vect n x;;
\end{verbatim}\end{boxed}

\noindent Можно прочесть элемент {\tt m} вектора {\tt v} с помощью:

\begin{boxed}\begin{verbatim}
  #vect_item v m;;
\end{verbatim}\end{boxed}

\noindent и записать значение {\tt y} в {\tt m} - й элемент  {\tt v}:

\begin{boxed}\begin{verbatim}
  #vect_assign v m y;;
\end{verbatim}\end{boxed}

Эти операции соответствуют выражениям {\tt v[m]} и {\tt v[m] = y} в
C. Элементы массива нумеруются с нуля. Например:

\begin{boxed}\begin{verbatim}
  #let v = make_vect 5 0;;
  v : int vect = [|0; 0; 0; 0; 0|]
  #vect_item v 1;;
  - : int = 0
  #vect_assign v 1 10;;
  - : unit = ()
  #v;;
  - : int vect = [|0; 10; 0; 0; 0|]
  #vect_item v 1;;
  - : int = 10
\end{verbatim}\end{boxed}

\noindent Все операции чтения и записи элементов сопровождаются контролем границ, например:

\begin{boxed}\begin{verbatim}
  #vect_item v 5;;
  Uncaught exception: Invalid_argument "vect_item"
\end{verbatim}\end{boxed}

\subsection{Sequencing}

В ML нет необходимости указывать последовательность вычислений, поскольку обычные правила вычисления предполагают порядок. Например:

\begin{boxed}\begin{verbatim}
  #let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   let _ =  x := !x + 1 in
   ();;
\end{verbatim}\end{boxed}

\noindent выражения вычисляются в ожидаемом порядке. Здесь мы используем специальный паттерн {\tt \_} который является подложным, подставным именем FIX(??). Тем не менее, более заманчиво использовать договорные правила записи для установления последовательности вычислений, в ML это возможно с помощью точки с запятой:

\begin{boxed}\begin{verbatim}
  #x := !x + 1;
   x := !x + 1;
   x := !x + 1;
   x := !x + 1;;
\end{verbatim}\end{boxed}

\subsection{Работа с системой типов}


Хотя полиморфизм очень хорош для чисто функциональной части ML, взаимодействие с 
некоторыми императивными возможностями построено неудачно. Например,
рассмотрим следующее:

\begin{boxed}\begin{verbatim}
  #let l = ref [];;
\end{verbatim}\end{boxed}

Может показаться {\tt l} имеет полиморфный тип $\alpha\; list\; ref$. В соответствии со стандартнымиe правилами вывода по полиморфизму мы могли бы использовать {\tt l} с двумя различными типами, сначала

\begin{boxed}\begin{verbatim}
  #l := [1];;
\end{verbatim}\end{boxed}

\noindent и затем

\begin{boxed}\begin{verbatim}
  #hd(!l) = true;;
\end{verbatim}\end{boxed}

Но это не обосновано, поскольку мы, фактически могли бы записывать что ? то как объект типа {\tt int} а затем читать как объект типа {\tt bool}.
Следовательно, когда используются ссылки, требуются некоторые ограничения на привычные правила по полиморфизму типов. Было много предложений по подходящему ограничению системы типов, некоторые из которых ? весьма запутанные. Недавно различные версии ML, теперь, похоже, сходятся к относительно простому методу, называемому {\em ограничением значения}, \citeN{wright-example}, и CAML обеспечивает это ограничение. В самом деле, вышеупомянутая последовательность не выполняется. Но интересно  промежуточное поведение. Если мы посмотрим на первую линию, мы увидим:

\begin{boxed}\begin{verbatim}
  #let l = ref [];;
  l : '_a list ref = ref []
\end{verbatim}\end{boxed}

Подчёркивание перед типом переменной обозначает что {\tt l} не полиморфна в привычном смысле; скорее она имеет один фиксированный тип, хотя тип этот всё ещё неопределён. Следующая строчка работает отлично:

\begin{boxed}\begin{verbatim}
#l := [1];;
- : unit = ()
\end{verbatim}\end{boxed}

\noindent но если посмотреть на тип {\tt l}, то мы увидим:

\begin{boxed}\begin{verbatim}
  #l;;
  - : int list ref = ref [1]
\end{verbatim}\end{boxed}

Теперь установлен псевдо ? полиморфный тип. Благодаря этому, ясно, что следующая линия даст ошибку:

\begin{boxed}\begin{verbatim}
  #hd(!l) = true;;
  Toplevel input:
  >hd(!l) = true;;
  >         ^^^^
  This expression has type bool,
  but is used with type int.
\end{verbatim}\end{boxed}

До сих пор это представлялось обоснованным, но мы ещё не объяснили почему сходные подчёркнутые типы переменных встречаются в несомненно довольно безвредных чисто функциональных выражениях, и, более того, почему они часто исчезают при $\eta$ -раскрытии.

\begin{boxed}\begin{verbatim}
  #let I x = x;;
  I : 'a -> 'a = <fun>
  #I o I;;
  it : '_a -> '_a = <fun>
  #let I2 = I o I in fun x -> I2 x;;
  - : '_a -> '_a = <fun>
  #fun x -> (I o I) x;;
  it : 'a -> 'a = <fun>
\end{verbatim}\end{boxed}

Другие техники для полиморфных ссылок часто основываются на кодировании в типе
данных о том, что выражение может включать ссылки. Это представляется разумным,
но такой подход может привести к типам функций захламлённым этой специальной 
информацией. Представляется непривлекательным, что в типе функции  должен отражаться факт того, как функция реализована - императивно ли, или чисто функционально.

Решение Wright'а, с другой стороны, использует только основной синтаксис выражений, связываемых через let. Чего действительно хотелось бы, так это знать: может ли вычисление выражений привести к побочным эффектам. В действительности, поскольку в общем случае это неразрешимо, используется ли значение, или нет, выясняют исходя из простого синтаксического критерия. Грубо говоря, выражение является значением если оно не допускает дальнейших вычислений по правилам ML  --- вот почему выражение часто может быть обращено в значение, посредством обратной eta конверсии. К сожалению, это не способствует скорости вычислений.
\section*{Упражнения}

\begin{enumerate}

\item Определим $C$ комбинатор следующим образом:

\begin{boxed}\begin{verbatim}
  #let C f x y = f y x;;
\end{verbatim}\end{boxed}

Что делает эта функция?

\begin{boxed}\begin{verbatim}
  #fun f l1 l2 -> itlist (union o C map l2 o f) l1 [];;
\end{verbatim}\end{boxed}

\item Что делает эта функция? Напишите более эффективную версию.

\begin{boxed}\begin{verbatim}
  #let rec upto n = if n < 1 then [] else append (upto (n-1)) [n];;
\end{verbatim}\end{boxed}

\item Определим функцию, вычисляющую числа Фибоначчи:

\begin{boxed}\begin{verbatim}

  #let rec fib =

     fun 0 -> 0
       | 1 -> 1
       | n -> fib(n - 2) + fib(n - 1);;
\end{verbatim}\end{boxed}

Почему эта функция неэффективна? Предложите лучшую реализацию.

\item (*) FIX (? Can you think of any uses for this exception or similar recursive ones? Можете ли вы предложить пример использования такого исключения, или таких же рекурсивных? ?)


\begin{boxed}\begin{verbatim}
  #exception Recurse of exn;;
\end{verbatim}\end{boxed}

\item Напишите простую версию быстрой сортировки на массивах. Сначала массив разделяется на две части по некоторому элементу, затем на левой части и на правой рекурсивно вызывается sort. Какой рекурсивный вызов является хвостовым?  Сколько требуется памяти в худшем случае? Как с помощью небольшого изменения в коде добиться значительной оптимизации?

\item Докажите, что обе версии {\tt rev}, что мы упомянули, всегда дают одинаковый результат.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:

