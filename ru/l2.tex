\documentclass[portrait,%
              fancybox,%
              notes,%
              epsfig,%
              alltt,%
              semcolor,
              alltt]{seminar}

\usepackage[koi8-r]{inputenc}
\usepackage[russian]{babel}

\input amssym.def
\input amssym

\newcommand{\nat}{\mbox{$\protect\Bbb N$}}
\newcommand{\num}{\mbox{$\protect\Bbb Z$}}
\newcommand{\rat}{\mbox{$\protect\Bbb Q$}}
\newcommand{\real}{\mbox{$\protect\Bbb R$}}
\newcommand{\complex}{\mbox{$\protect\Bbb C$}}
\newcommand{\xxx}{\mbox{$\protect\Bbb X$}}

\newcommand{\lamb}[1]{\lambda #1.\:}
\newcommand{\eps}[1]{\varepsilon #1.\:}
\newcommand{\all}[1]{\forall #1.\:}
\newcommand{\ex}[1]{\exists #1.\:}
\newcommand{\exu}[1]{\exists! #1.\:}

\newcommand{\True}{\top}
\newcommand{\False}{\bot}
\newcommand{\Not}{\neg}
\newcommand{\And}{\wedge}
\newcommand{\Or}{\vee}
\newcommand{\Imp}{\Rightarrow}
\newcommand{\Iff}{\Leftrightarrow}

\newcommand{\entails}{\vdash}
\newcommand{\proves}{\vdash}

\newcommand{\Ands}{\bigwedge}
\newcommand{\Ors}{\bigvee}

\newcommand{\BQ}{\mbox{$\ulcorner$}}
\newcommand{\BEQ}{\mbox{\raise4pt\hbox{$\ulcorner$}}}
\newcommand{\EQ}{\mbox{$\urcorner$}}
\newcommand{\EEQ}{\mbox{\raise4pt\hbox{$\urcorner$}}}

\newcommand{\QUOTE}[1]{\mbox{$\BQ #1 \EQ$}}
\let\psubset=\subset                    % Pure TeX: thanks to MAJ %
\let\subset=\subseteq

\newcommand{\powerset}{\wp}             % This is pretty dire...  %

\newcommand{\Union}{\cup}
\newcommand{\Inter}{\cap}
\newcommand{\Unions}{\bigcup}
\newcommand{\Inters}{\bigcap}

\newcommand{\proof}{{\bf \noindent Proof:\ }}
\newcommand{\qed}{Q.E.D.}

\newcommand{\Rule}{\infer}

\newcommand{\restrict}{\upharpoonright} % This is lousy and must be fixed! %

\newcommand{\bigsqcap}{\mbox{\Large{$\sqcap$}}}

\newcommand\leb{\lbrack\!\lbrack}
\newcommand\reb{\rbrack\!\rbrack}
\newcommand{\sem}[1]{\leb #1 \reb}

\newcommand{\BA}{\begin{array}[t]{l}}
\newcommand{\EA}{\end{array}}
\newcommand{\sqle}{\sqsubseteq}
\newcommand{\sqlt}{\sqsubset}

\newcommand{\too}{\twoheadrightarrow}

\newcommand{\Los}{{\L}o{\'s}}

% These are from Mike's notes

\def\alphas{\mathrel{\mathop{\longrightarrow}\limits_{\alpha}}}
\def\betas{\mathrel{\mathop{\longrightarrow}\limits_{\beta}}}
\def\etas{\mathrel{\mathop{\longrightarrow}\limits_{\eta}}}

\def\goesto{\longrightarrow}

% Sizes

\newenvironment{rslide}
{\begin{slide*}[240mm,165mm] }
{\end{slide*}}

\renewcommand{\slidetopmargin}{0.8in}
\renewcommand{\slidebottommargin}{0.8in}

% Various combinations of one colour on another

\newcommand{\greenonred}[1]%
{\psset{fillcolor=red}\psframebox*[framearc=.3]{\green #1}}

\newcommand{\whiteonred}[1]%
{\psset{fillcolor=red}\psframebox*[framearc=.3]{\white #1}}

\newcommand{\yellowonmagenta}[1]%
{\psset{fillcolor=magenta}\psframebox*[framearc=.3]{\yellow #1}}

\newcommand{\whiteonblack}[1]%
{\psset{fillcolor=black}\psframebox*[framearc=.3]{\white #1}}

\newcommand{\blackonlightgray}[1]%
{\psset{fillcolor=lightgray}\psframebox*[framearc=.3]{\black #1}}

\newcommand{\blueonlightgray}[1]%
{\psset{fillcolor=lightgray}\psframebox*[framearc=.3]{\blue #1}}

\newcommand{\cyanonblack}[1]%
{\psset{fillcolor=black}\psframebox*[framearc=.3]{\cyan #1}}

\newcommand{\blueonyellow}[1]%
{\psset{fillcolor=yellow}\psframebox*[framearc=.3]{\blue #1}}

\newcommand{\redonyellow}[1]%
{\psset{fillcolor=yellow}\psframebox*[framearc=.3]{\red #1}}

\newcommand{\heading}[1]%
{\begin{center}\whiteonblack{\large\bf\blueonlightgray{#1}}\end{center}}

\newcommand{\emphatic}[1]{\blueonyellow{#1}}

\newcommand{\veryemphatic}[1]%
{\begin{center}{\emphatic{#1}}\end{center}}

% Head and foot of slides

\newpagestyle{ColourDemo}%
  {\cyanonblack{Введение в Функциональное Программирование:
                Лекция 2}\hfil\cyanonblack{\thepage}}
  {\cyanonblack{Джон Харрисон}\hfil
   \cyanonblack{Университет Кембриджа, 17 января 1997}}
%\newpagestyle{ColourDemo}%
%  {\cyanonblack{Introduction to Functional Programming:
%                Lecture 2}\hfil\cyanonblack{\thepage}}
%  {\cyanonblack{John Harrison}\hfil
%   \cyanonblack{University of Cambridge, 17 January 1997}}

\pagestyle{ColourDemo}

\centerslidesfalse

% Colour bullets

\def\labelitemi{{\black$\bullet$}}
\def\labelitemii{{\black--}}
\def\labelitemiii{{\black$\ast$}}
\def\labelitemiv{{\black$\cdot$}}

% Start of document (default text colour is blue)

\begin{document}\blue


\begin{rslide}

\vspace*{-0.5cm}

\heading{%
\begin{tabular}{c}
{\Large\red Введение в}\\
{\Large\red Функциональное}\\
{\Large\red Программирование}\\
{\cyan Джон Харрисон}\\
{\cyan Университет Кембриджа}\\
{\green Лекция 2}\\
{\green $\lambda$-исчисление как}\\
{\green формальная система}
%{\LARGE\red Introduction to}\\
%{\LARGE\red Functional Programming}\\
%{\cyan John Harrison}\\
%{\cyan University of Cambridge}\\
%{\green Lecture 2}\\
%{\green $\lambda$-calculus as a formal system}
\end{tabular}}

Темы:

%Topics covered:

\begin{itemize}

\item Зачем нужна формальная система

%\item Why a formal system?

\item Свободные и связанные переменные

%\item Free and bound variables

\item Подстановка

%\item Substitution

\item Правила преобразования и эквивалентность $\lambda$-термов

%\item Conversion rules and lambda equality

\item Редукция, стратегии вычисления и теорема Чёрча-Россера

%\item Reduction, evaluation strategies and the Church-Rosser theorem(s)

\item Комбинаторы

%\item Combinators

\end{itemize}

\end{rslide}



\begin{rslide}

\heading{Зачем нужна формальная система?}

%\heading{Why a formal system?}

\vspace*{0.5cm}

Мы принимаем некоторые факты, как `очевидные', например {\red $$
  (\lamb{x\; y} x + y)\;1\;2 = (\lamb{y} 1 + y)\;2 = 1 + 2 $$} потому
что они согласуются с интуитивным пониманием.  Сейчас мы зададим
некоторые {\em формальные} правила вычислений с помощью
$\lambda$-выражений.

%We have taken certain facts as `obvious', e.g.
%{\red $$ (\lamb{x\; y} x + y)\;1\;2 = (\lamb{y} 1 + y)\;2 = 1 + 2 $$}
%because they respect the intuitive meanings. Now we specify some {\em
%formal} rules for calculating with lambda expressions.

Эти правила могут быть применены машинально, без раздумий. XXX как можно было
бы преобразовать выражение:
{\red $$ x - 3 = 5 - x$$}
в
{\red $$ 2 x = 5 + 3 $$}

без учёта основных значений XXX

%These can then be applied mechanically, without thinking about them,
%just as one might take:

%{\red $$ x - 3 = 5 - x$$}

%and transform it, without considering the underlying meanings, to

% {\red $$ 2 x = 5 + 3 $$}

\end{rslide}



\begin{rslide}

\heading{Цитата Уайтхеда}

\vspace*{0.5cm}

К вопросу обозначений и формальных правил вывода.

%On the subject of symbolisms and formal rules of manipulation:

\begin{green}\begin{quote}
[\ldots] с помощью обозначений мы можем делать переходы в
рассуждениях почти механически; без обозначений нам бы потребовались
высшие способности мозга. [\ldots] Цивилизация развивается за счёт
увеличения числа важных операций, которые могут быть выполнены
машинально.
\end{quote}\end{green}

%\begin{green}\begin{quote}
%[\ldots] by the aid of symbolism, we can make transitions in reasoning almost
%mechanically by the eye, which otherwise would call into play the higher
%faculties of the brain. [\ldots] Civilisation advances by extending the number
%of important operations which can be performed without thinking about them.
%\end{quote}\end{green}

А.~Н.~Уайтхед: `Введение в математику', 1919 г.

%A. N. Whitehead: An Introduction to Mathematics', 1919.

\end{rslide}



\begin{rslide}

\heading{Формальный синтаксис $\lambda$-термов}

%\heading{Formal syntax of $\lambda$-terms}

\vspace*{0.5cm}

$\lambda$-термы строятся по индукции следующим образом:

%Lambda terms are built up inductively in the following ways:

\begin{itemize}

\item {\bf Переменные}, например {\red $x$}, {\red $u$} и {\red $v_3$}.

%\item {\bf Variables}, e.g. {\red $x$}, {\red $u$} and {\red $v_3$}.

\item {\bf Константы}, например {\red $c$}, {\red $0$} и {\red $false$}.

%\item {\bf Constants}, e.g. {\red $c$}, {\red $0$} and {\red
%$false$}.

\item {\bf Применения}, а именно {\red $s\; t$} где {\red $s$} и
  {\red$t$}~-- $\lambda$-термы, например {\red $f(x)$}.

%\item {\bf Applications}, of the form {\red $s\; t$} where {\red $s$}
%and {\red$t$} are $\lambda$-terms, e.g. {\red $f(x)$}.

\item {\bf Абстракции}, а именно {\red $\lamb{x} s$}, например {\red
    $\lamb{x}$}

%\item {\bf Abstractions}, of the form {\red $\lamb{x} s$}, e.g. {\red
%$\lamb{x}x$}.

\end{itemize}

Это может быть выражено следующей грамматикой BNF:

{\red $$ Exp = Var \mid Const \mid Exp\; Exp \mid \lambda\; Var . \; Exp $$}

Так как синтаксис задан по индукции, то мы можем {\em определять сущности
  с помощью примитивной рекурсии} и {\em доказывать сущности с помощью
  структурной индукции}.

%This can be described by the following BNF grammar:

%{\red $$ Exp = Var \mid Const \mid Exp\; Exp \mid \lambda\; Var . \; Exp $$}

%Since the syntax is defined inductively, we can {\em define things by
%primitive recursion} and {\em prove things by structural induction}.

\end{rslide}



\begin{rslide}

\heading{Примитивная рекурсия: FV}

%\heading{Primitive recursion: FV}

\vspace*{0.5cm}

│В │к│а│ч│е│с│т│в│е │п│о│я│с│н│е│н│и│я к тому, как можно определять функции рекурсивно,
используя синтаксис $\lambda$-термов, я приведу формальное определение
множества свободных переменных, записываемое как {\red $FV(t)$} для
терма {\red $t$}.

%As an illustration of how to define functions recursively over the
%syntax of $\lambda$-terms, here is a formal definition of the set of free
%variables in a term {\red $t$}, written {\red $FV(t)$}.

\begin{red}
\begin{eqnarray*}
   FV(x)          & = & \{ x \}                 \\
   FV(c)          & = & \emptyset               \\
   FV(s\; t)      & = & FV(s) \Union FV(t)      \\
   FV(\lamb{x} s) & = & FV(s) - \{ x \}
\end{eqnarray*}
\end{red}

В общем, мы всегда можем определить значение функции для данного терма
относительно значений для подтермов, │к│а│к │э│т│о │п│о│к│а│з│а│н│о │т│у│т. Интуитивно
ясно, что мы всегда можем вычислить значение функции для какого-либо
конкретного терма.

%In general, we can always define the value of a function on a given term
%in terms of the value on the immediate subterms, as here. Intuitively, it
%is clear that we can always calculate the value of the function on any
%particular term.

\end{rslide}



\begin{rslide}

\heading{
\begin{tabular}{c}
{Структурная индукция:}\\
{FV~-- конечно}
\end{tabular}}

%\heading{Structural induction: FV is finite}

В качестве примера структурной индукции мы докажем, что для любого
$\lambda$-терма {\red $t$} множество {\red $FV(t)$} всегда конечно.

%As an illustration of structural induction, we will prove that for any
%$\lambda$-term {\red $t$}, the set {\red $FV(t)$} is always finite.

\begin{itemize}

\item Если {\red $t$} переменная {\red $v$}, то {\red $FV(t) = \{v\}$}
  по определению, и это множество определённо конечно.

%\item If {\red $t$} is a variable {\red $v$}, then {\red $FV(t) = \{v\}$} by
%definition, and this is certainly finite.

\item Если {\red $t$} константа {\red $c$}, то {\red $FV(t) =
    \emptyset$}, которое заведомо конечно.

%\item If {\red $t$} is a constant {\red $c$}, then {\red $FV(t) = \emptyset$},
%which is trivially finite.

\item Если {\red $t$} применение {\red $s_1\; s_2$}, то по
  предположению индукции {\red $FV(s_1)$} и {\red $FV(s_2)$} оба
  конечны.  Но {\red $FV(t) = FV(s_1) \Union FV(s_2)$}, а объединение
  двух конечных множеств~-- конечно.

%\item If {\red $t$} is an application {\red $s_1\; s_2$}, then by the inductive
%hypothesis {\red $FV(s_1)$} and {\red $FV(s_2)$} are both finite. But {\red
%$FV(t) = FV(s_1) \Union FV(s_2)$} and the union of two finite sets is finite.

\item Если {\red $t$}~-- это абстракция {\red $\lamb{x} s$}, то по
  предположению индукции {\red $FV(s)$}~-- конечно.  Но {\red $FV(t) =
    FV(s) - \{x\}$}, которое должно быть конечным, ибо его мощность
  меньше.

%\item If {\red $t$} is an abstraction {\red $\lamb{x} s$}, then by the
%inductive hypothesis {\red $FV(s)$} is finite. But {\red $FV(t) = FV(s) -
%\{x\}$}, which must also be finite as it is no larger.

\end{itemize}

Что и требывалось доказать.

%Q.E.D.

\end{rslide}




\begin{rslide}

\heading{Подстановка}

\vspace*{0.5cm}

Для того, чтобы выразить определённые правила, нам надо формализовать
понятие подстановки терма вместо переменной в другом терме.

%In order to express certain rules, we need to formalize the notion of
%substituting a term for a variable in another term.

Мы записываем {\red $t[s/x]$} как результат подстановки терма {\red
  $s$} вместо переменной {\red $x$} в другом терме {\red $t$}. Иногда
записывают {\red $t[x := s]$} и даже {\red $t[x/s]$}.

%We write {\red $t[s/x]$} for the result of substituting a term {\red $s$} for a
%variable {\red $x$} in another term {\red $t$}. One also sees {\red $t[x :=
%s]$} and even {\red $t[x/s]$}.

Нашу запись можно запомнить, думая об умножении дробей:

%Ours can be remembered by thinking of multiplication of fractions:

{\red $$ x[t/x] = t $$}

Например:

%For example:

{\red $$ (\lamb{z} x + z + x)[y/x] = \lamb{z} y + z + y $$}
Конечно мы делаем подстановку только для {\em свободных} переменных,
поэтому {\red $(\lamb{x} x)[y/x] = \lamb{x} x$}.

\end{rslide}


\begin{rslide}

\heading{Простая подстановка}

%\heading{Naive substitution}

\vspace*{0.5cm}

На первый взгляд, кажется, что мы можем определить подстановку,
используя примитивную рекурсию следующим образом:
{\red
\begin{eqnarray*}
    x[t/x]            & = & t                           \\
    y[t/x]            & = & y \mbox{ if $x \not= y$}    \\
    c[t/x]            & = & c                           \\
    (s_1\;s_2)[t/x]   & = & s_1[t/x] \; s_2[t/x]        \\
    (\lamb{x} s)[t/x] & = & \lamb{x} s                  \\
    (\lamb{y} s)[t/x] & = & \lamb{x} (s[t/x]) \mbox{ if $x \not= y$}
\end{eqnarray*}}
Однако это не так.  Мы получим {\red $(\lamb{y} x + y)[y/x] = \lamb{y} y
  + y$}~--- {\em захват переменной}.  Нам следует сначала
переименовать переменную, чтобы получить {\red $\lamb{w} x + w$}, и
только потом совершить простую подстановку.

{\red $$ (\lamb{w} x + w)[y/x] = \lamb{w} y + w $$}

%At first sight we can define substitution by primitive recursion as follows:
%{\red \begin{eqnarray*}
%   x[t/x]            & = & t                           \\
%   y[t/x]            & = & y \mbox{ if $x \not= y$}    \\
%   c[t/x]            & = & c                           \\
%   (s_1\;s_2)[t/x]   & = & s_1[t/x] \; s_2[t/x]        \\
%   (\lamb{x} s)[t/x] & = & \lamb{x} s                  \\
%   (\lamb{y} s)[t/x] & = & \lamb{x} (s[t/x]) \mbox{ if $x \not= y$}
%\end{eqnarray*}}
%However this isn't right. We get {\red $(\lamb{y} x + y)[y/x] = \lamb{y} y
%+ y$} --- {\em variable capture}. We should rename first to {\red $\lamb{w} x +
%w$}, and only then perform the naive substitution:
%
%{\red $$ (\lamb{w} x + w)[y/x] = \lamb{w} y + w $$}
\end{rslide}


\begin{rslide}

\heading{Подстановка переименовывания}

%\heading{Renaming substitution}

\vspace*{0.5cm}

Рассмотрим два случая, определяя {\red $(\lamb{y} s)[t/x]$} для {\red
  $x \not= y$}.

% So we consider two cases when defining {\red $(\lamb{y} s)[t/x]$}
% for {\red $x \not= y$}.

\begin{itemize}

\item Если {\red $x \not\in FV(s)$} либо {\red $y \not\in FV(t)$}, то
  можно сделать подстановку как ни в чём ни бывало; захвата переменной
  не произойдёт.

% \item If either {\red $x \not\in FV(s)$} or {\red $y \not\in FV(t)$}
%   then we can proceed as before; variable capture will not occur.

\item Иначе мы берём новую переменную {\red $z \not\in FV(s) \Union FV(t)$}
и составляем выражение {\red $\lamb{z} (s[z/y][t/x])$}.  Сначала мы
переименовываем связанную переменную {\red $y$} в {\red $z$}, а потом
продолжаем делать подстановку как ни в чём ни бывало.

% \item Otherwise, we pick a new variable {\red $z \not\in FV(s)
% \Union FV(t)$} and form {\red $\lamb{z} (s[z/y][t/x])$}. That is,
% first we rename the bound variable {\red $y$} to {\red $z$}, then
% proceed with the substitution as before.

\end{itemize}

Для определённости мы можем определить {\red $z$} как самую первую
лексикографическую переменную, которая не является свободной ни в
{\red $s$}, ни в {\red $t$}.

%For definiteness, we can define {\red $z$} to be the lexicographically earliest
%variable not occurring free in {\red $s$} or {\red $t$}.

Указанное выше определение гарантирует, что подстановка не нарушает
интуитивного представления.  Теперь мы можем свободно пользоваться
подстановкой.

%The above definition ensures that substitution always respects the intuitive
%interpretation. Now we can use this operation freely.

\end{rslide}



\begin{rslide}

\heading{Правила преобразования}

%\heading{Conversion rules}

\vspace*{0.5cm}

$\lambda$-исчисление основано на трёх фундаментальных `конверсиях',
которые преобразовывают одни термы в другие, интуитивно эквивалентные
термы.  Конверсии традиционно обозначаются греческими буквами: {\green
  $\alpha$} (alpha), {\green $\beta$} (beta) и {\green $\eta$} (eta).
Самая важная для нас это {\green $\beta$}-конверсия.

%Lambda calculus is based on three fundamental `conversions' which transform one
%term into another one, intuitively equivalent to it. These are traditionally
%denoted by the Greek letters {\green $\alpha$} (alpha), {\green $\beta$} (beta)
%and {\green $\eta$} (eta). The most important to us is {\green $\beta$}.

\begin{itemize}

\item $\alpha$-конверсия: {\red $\lamb{x} s \alphas \lamb{y} s[y/x]$},
  где {\red $y \not\in FV(s)$}.  Например, {\red $\lamb{u}
    u\; v \alphas \lamb{w} w\; v$}, но {\red $\lamb{u} u\; v
    \not\alphas \lamb{v} v\; v$}.  Это ограничение позволяет избежать
  захвата переменной.

%\item Alpha conversion: {\red $\lamb{x} s \alphas \lamb{y} s[y/x]$} provided
%{\red $y \not\in FV(s)$}. For example, {\red $\lamb{u} u\; v \alphas \lamb{w}
%w\; v$}, but {\red $\lamb{u} u\; v \not\alphas \lamb{v} v\; v$}. This
%restriction avoids another instance of variable capture.

\item $\beta$-конверсия: {\red $(\lamb{x} s)\; t \betas s[t/x]$}.

%\item Beta conversion: {\red $(\lamb{x} s)\; t \betas s[t/x]$}.

\item $\eta$-конверсия: {\red $\lamb{x} t\; x \etas t$}, где {\red $x
    \not\in FV(t)$}.  Например, {\red $\lamb{u} v\; u \etas v$}, но
  {\red $\lamb{u} u\; u \not\etas u$}.

%\item Eta conversion: {\red $\lamb{x} t\; x \etas t$}, provided {\red $x
%\not\in FV(t)$}. For example {\red $\lamb{u} v\; u \etas v$} but {\red
%$\lamb{u} u\; u \not\etas u$}.
%
\end{itemize}

\end{rslide}



\begin{rslide}

\heading{Эквивалентность $\lambda$-термов}

%\heading{Lambda equality}

\vspace*{0.5cm}

Говорят, что два терма {\red $s$} и {\red $t$} равны, если существует
конечная последовательность $\alpha$, $\beta$ или $\eta$ конверсий,
которая переводит один терм в другой.  А записывают это как {\red $s =
  t$}.

%We say that two terms {\red $s$} and {\red $t$} are equal, and write {\red $s =
%t$}, if there is a finite sequence of $\alpha$, $\beta$ or $\eta$ conversions,
%forwards or backwards, at any depth, which connects them.

Формально это отношение определяется по индукции (см. следующий слайд).

%Formally we define the relation inductively (see next slide).

Заметим, что понятие `равенство' {\em определено}, поэтому это не тоже
самое, что и синтаксическое равенство.  Синтаксическим равенством мы
называем `тождество' и используем знак {\red $\equiv$}.  Например,
{\red $\lamb{x} x = \lamb{y} y$}, но {\red $\lamb{x} x \not\equiv
  \lamb{y} y$}.

%Note that this `equality' is a {\em defined} notion and is not the same as
%equality at the syntactic level. We'll call this `identity', and use the symbol
%{\red $\equiv$}. For example {\red $\lamb{x} x = \lamb{y} y$} but {\red
%$\lamb{x} x \not\equiv \lamb{y} y$}.

Отношение равенства {\em экстенсионально}, т.е. если две функции {\red
  $f$} и {\red $g$} дают одинаковые значения для всех аргументнов, то
эти функции равны.  Действительно, если {\red $f$} и {\red $g$}
обладают таким свойством, то взяв переменную {\red $y$}, которая не
является свободной ни в {\red $f$}, ни в {\red $g$}, получим {\red
  $f\; y = g\; y$}.  Поэтому {\red $\lamb{y} f\; y = \lamb{y} g\; y$}.
Применив $\eta$-конверсию пару раз, и получим {\red $f = g$}.

%The equality relation is {\em extensional}, i.e. if two functions {\red $f$}
%and {\red $g$} give equal results for all arguments, then they are themselves
%equal. Indeed, if {\red $f$} and {\red $g$} have this property, then choose a
%variable {\red $y$} not free in {\red $f$} or {\red $g$}. We have {\red $f\; y
%= g\; y$} and therefore {\red $\lamb{y} f\; y = \lamb{y} g\; y$}. But now by a
%couple of $\eta$-conversions, we get {\red $f = g$}.

\end{rslide}



\begin{rslide}

\heading{
\begin{tabular}{c}
{Эквивалентность $\lambda$-термов:}\\
{определение}
\end{tabular}}

%\heading{Lambda equality: definition}

\vspace*{0.5cm}

\begin{red}

$$ \frac{s \alphas t \mbox{ or } s \betas t \mbox{ or } s \etas t}{s = t} $$

$$ \frac{}{t = t} $$

$$ \frac{s = t}{t = s} $$

$$ \frac{s = t \mbox{ and } t = u}{s = u} $$

$$ \frac{s = t}{s\; u = t\; u} $$

$$ \frac{s = t}{u\; s = u\; t} $$

$$ \frac{s = t}{\lamb{x} s = \lamb{x} t}$$

\end{red}

\end{rslide}



\begin{rslide}

\heading{$\lambda$-редукция}

%\heading{Lambda reduction}

\vspace*{0.5cm}

Вот `подправленное' определение эквивалентности $\lambda$-термов.

%This is a `directional' version of lambda equality.

\vspace*{0.5cm}

\begin{red}

$$ \frac{s \alphas t \mbox{ or } s \betas t \mbox{ or } s \etas t}{s \goesto t}
$$

$$ \frac{}{t \goesto t} $$

$$ \frac{s \goesto t \mbox{ and } t \goesto u}{s \goesto u} $$

$$ \frac{s \goesto t}{s\; u \goesto t\; u} $$

$$ \frac{s \goesto t}{u\; s \goesto u\; t} $$

$$ \frac{s \goesto t}{\lamb{x} s \goesto \lamb{x} t}$$

\end{red}

\end{rslide}


\begin{rslide}

\heading{Стратегия вычислений}

%\heading{Evaluation strategy}

\vspace*{0.5cm}

Идея заключается в том, что редукция соответствует постоянным попыткам
вычислить выражения путем применения функций к аргументам.  Однако,
зачастую существует несколько возможностей редуцировать данный терм.
Например:

%The idea is that reduction corresponds to a systematic attempt to evaluate
%expressions by applying functions to arguments. However there are often several
%different ways to reduce a given term. For example we have:

\begin{red}
\begin{eqnarray*}
& & (\lamb{x} y)\; ((\lamb{x} x\; x\; x)\;(\lamb{x} x\; x\; x))     \\
& \goesto & (\lamb{x} y)\; ((\lamb{x} x\; x\; x)\;(\lamb{x} x\; x\; x)\;
                            (\lamb{x} x\; x\; x))                           \\
& \goesto & (\lamb{x} y)\; (\cdots)
\end{eqnarray*}
\end{red}

и так до бесконечности.  Однако, мы можем редуцировать самый левый
внешний {\em редекс}.  В результате получим терм {\red $y$}, который
записан в нормальной форме, т.е. отсутствуют нетривиальные редукции.

В целом же, стратегия вычислений важна на практике.  Мы позже вернёмся
к этой теме.

%ad infinitum. However we can reduce the leftmost outermost {\em redex} first
%and get simply {\red $y$}, which is in normal form, i.e. no nontrivial
%reductions are possible.

%In general, then, evaluation strategy is practically important, and we will
%return to this subject.

\end{rslide}


\begin{rslide}

\heading{Теорема Чёрча-Россера}

%\heading{The Church Rosser theorem}

\vspace*{0.5cm}

Теорема гласит, что если {\red $s \goesto t_1$} и {\red $s \goesto
  t_2$}, то существует терм {\red $u$} такой, что {\red $t_1 \goesto
  u$} и {\red $t_2 \goesto u$}.

%This says that if {\red $s \goesto t_1$} and {\red $s \goesto t_2$}, then there
%is a {\red $u$} such that {\red $t_1 \goesto u$} and {\red $t_2 \goesto u$}.

Применяя это действие неоднократно, мы получим более сильное
утверждение, чем то, что если {\red $t_1 = t_2$}, то существует терм
{\red $u$}, такой, что {\red $t_1 \goesto u$} и {\red $t_2 \goesto
  u$}.

%By applying this repeatedly, we get the stronger form that if {\red $t_1 =
%t_2$} then there is a term {\red $u$} with {\red $t_1 \goesto u$} and {\red
%$t_2 \goesto u$}.

Таким образом, {\em если} терм редуцируется или в общем случае равен
терму в нормальной форме, то эта нормальная форма единственна с
точностью до $\alpha$-конверсии.

%So {\em if} a term reduces to, or in general is equal to, a term in normal
%form, that normal form is unique up to alpha conversion.

Также из теоремы следует, что эквивалентность $\lambda$-термов
нетривиальна, так как если два терма в нормальной форме не
$\alpha$-эквивалентны, то они не равны.  Например {\red $\lamb{x\; y}
  x \not= \lamb{x\; y} y$}.

%Also a consequence of the theorem is that lambda equality is nontrivial,
%because two terms in normal form that are not alpha-equivalent are not equal.
%For example {\red $\lamb{x\; y} x \not= \lamb{x\; y} y$}.

Другая теорема (тоже доказанная Чёрчем и Россером) гласит, что если
{\em хоть какая-то} последовательность редукций завершается, то с тем
же результатом завершится и постоянное редуцирование самого левого
внешнего редекса.

%Another theorem (also proved by Church and Rosser) is that if {\em any}
%reduction sequence terminates, then the one arrived at by systematically
%reducing the leftmost outermost redexes will terminate.

\end{rslide}


\begin{rslide}

\heading{Комбинаторы}

%\heading{Combinators}

\vspace*{0.5cm}

Оказывается, мы можем освободиться от $\lambda$-абстракций, введя три
простых {\em комбинатора}:

%It turns out that we can dispense with $\lambda$-abstractions altogether if we
%introduce three very simple {\em combinators}:

\begin{red}
\begin{eqnarray*}
I & = & \lamb{x} x                              \\
K & = & \lamb{x\; y} x                          \\
S & = & \lamb{f\; g\; x} (f\; x)(g\; x)
\end{eqnarray*}
\end{red}

Их названия можно запомнить так: {\red $I$} = Identity (тождество),
{\red $K$} = Konstant (константа) и {\red $S$} = Sharing (выделение). 

%The names can be remembered by {\red $I$} = Identity, {\red $K$} = Konstant and
%{\red $S$} = Sharing.

Комбинаторная полнота: для каждого $\lambda$-терма существует
эквивалент без $\lambda$-абстракций с теми же свободными переменными,
записанный с помощью комбинаторов.

%Combinatory completeness: every $\lambda$-term has an equivalent, with the same
%free variables, written using combinators and with no lambda abstractions.

Это достаточно привлекательно, потому что позволяет избежать таких
трудностей, как захват переменной.

%This is quite attractive, because it avoids all the complications like variable
%capture.

\end{rslide}


\begin{rslide}

\heading{Комбинаторная полнота}

%\heading{Combinatory completeness}

\vspace*{0.5cm}

Достаточно найти комбинаторный эквивалент для любого {\red $\lamb{x}
  t$}, где {\red $t$} терм {\red $\lambda$}-свободный.  Тогда мы
сможем применить такую процедуру повторно восходящим способом к самым
внутренним абстракциям.

%It's enough to be able to find a combinatory equivalent for any {\red $\lamb{x}
%t$} where {\red $t$} is {\red $\lambda$}-free. Then we can apply the procedure
%repeatedly to the innermost abstraction in a bottom-up fashion.

\begin{itemize}

\item Если {\red $t$}~- переменная, то либо {\red $t = x$}, тогда
  {\red $\lamb{x} x = I$}, либо {\red $t \not= x$}, тогда {\red
    $\lamb{x} y = K\; y$}.

%\item If {\red $t$} is a variable, then either {\red $t = x$}, when {\red
%$\lamb{x} x = I$}, or {\red $t \not= x$}, when {\red $\lamb{x} y = K\; y$}.

\item Если {\red $t$}~- константа, скажем, {\red $c$}, тогда {\red
    $\lamb{x} y = K\; c$}.

%\item If {\red $t$} is a constant, say {\red $c$}, then {\red $\lamb{x} y = K\;
%c$}.

\item Если {\red $t$}~- абстракция, скажем {\red $s\; u$} тогда по
  предположению индукции существуют $\lambda$-свободные термы {\red
    $s'$} и {\red $u'$}, такие что {\red $s' = \lamb{x} s$} и {\red
    $u' = \lamb{x} u$}.  Простое вычисление показывает, что {\red
    $\lamb{x} s\; u = S\;s'\;u'$}.

%\item If {\red $t$} is an abstraction, say {\red $s\; u$}, then by the
%inductive hypothesis, there are lambda-free terms {\red $s'$} and {\red $u'$}
%with {\red $s' = \lamb{x} s$} and {\red $u' = \lamb{x} u$}. A simple calculation
%shows that {\red $\lamb{x} s\; u = S\;s'\;u'$}.

\end{itemize}

По сути, достаточно {\red $S$} и {\red $K$}, ибо {\red $I = S\; K\;
  K$}.

%In fact, {\red $S$} and {\red $K$} alone suffice, since {\red $I = S\; K\; K$}.

\end{rslide}


\end{document}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
