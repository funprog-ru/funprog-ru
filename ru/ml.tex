\chapter{Знакомство с ML}

В предыдущих главах мы начали с чистого $\lambda$-исчисления, а затем
систематически расширяли его новыми возможностями.  Например, мы
добавили конструкцию `let' как примитив, чтобы сделать полиморфное
типизирование более полезным, а также оператор рекурсии, для того,
чтобы восстановить мощь вычислений, которая была потеряна после
введения типов.  Двигаясь дальше по этому пути, мы в конечном счёте
достигли ML, при этом имея возможность простого взгляда на мир
используя типизированное $\lambda$-исчисление.

Следующей стадией является избавление от выражения таких типов данных
как логические значения и натуральные числа через $\lambda$-термы, и
создания примитивов для них.  Так что мы получим новые примитивные
типы, такие как {\tt bool} и {\tt int} (положительные и отрицательные
целые числа) и новые конструктора типов, такие как $\times$,~--- шаг,
который мы предчувствовали в последней главе.  С этими изменениями
% BUG# `шаг, который мы предчувствовали' как то коряво звучит --lg
также связаны новые константы и новые правила преобразования.
Например, выражение $2 + 2$ вычисляется с использованием машинной
арифметики, вместо преобразования его в нумералы Чёрча и выполнения
$\beta$-преобразований.  Эти дополнительные преобразования,
рассматриваемые как расширение обычных $\lambda$-операций, часто
называются `$\delta$-преобразованиями'.  В течение курса мы увидим, как
язык ML расширен по сравнению с чистым $\lambda$-исчислением.  Первым
делом мы должны обратиться к фундаментальному вопросу стратегии
вычисления выражений ML.

\section{Энергичное вычисление}

Мы сказали, что с теоретической точки зрения, нормальный порядок
(сверху вниз, слева направо) редукции выражений более предпочтителен,
потому что если хоть какая-то стратегия завершается, то эта тоже.
\footnote{Эта стратегия подобна некоторым, используемым в традиционных
  языках, таких как Algol 60, где ёё называют {\em вызов по имени}.}
Однако, этот подход имеет некоторые практические недостатки.  Например,
рассмотрим следующее выражение:

$$ (\lamb{x} x + x + x)\; (10 + 5) $$

При использовании нормального порядка редукции мы получаем $(10 + 5) +
(10 + 5) + (10 + 5)$, и на следующих шагах редукции мы должны
вычислить три раза одно и тоже выражение.  На практике это совершенно
недопустимо.  Существует два основных решения данной проблемы, и эти
решения делят мир функционального программирования на два лагеря.

Первое решение это придерживаться нормального порядка редукции, но при
этом пытаться оптимизировать реализацию так, чтобы разнообразные
подвыражения, возникающие при таком подходе, использовались совместно,
и никогда не вычислялись более одного раза.  В самой реализации
выражения представляются в виде связанных ацикличных графов, а не в
виде деревьев.  Этот подход известен как {\em ленивое (lazy)} или {\em
  вызов по необходимости (call-by-need)} вычисление, поскольку
выражения вычисляются только тогда, когда они необходимы.

Вторым решением является попытка перевернуть с ног на голову
теоретические размышления о стратегии редукции и вычислять аргументы
функции до передачи значений.  Этот подход известен как {\em
  аппликативный порядок} или {\em энергичное} вычисление.  Последнее
имя возникло из-за того, что аргументы функции вычисляются даже тогда,
когда они не нужны, например, $t$ в $(\lamb{x} y)\; t$.  Конечно,
энергичное вычисление означает, что вычисления некоторых выражений
могут зацикливаться, тогда как они могут завершаться при работе в
ленивом режиме.  Но это считается допустимым, поскольку этих вещей
достаточно легко избежать на практике.  В любом случае, стратегия
энергичного вычисления является стандартной для многих языков
программирования, таких как C, где её называют {\em вызов по значению
  (call by value)}.

ML использует энергичное вычисление по двум основным причинам.
Управление редукцией и совместным использованием, которое возникает
при ленивом вычислении, является достаточно сложным, и реализация
может быть относительно неэффективной и трудной.  Если программист
не особо заботлив, то память может заполниться не вычисленными
выражениями, и в общем тяжело понять потребление памяти программами.
В действительности, многие реализации ленивого вычисления стараются
оптимизировать его, путём использования энергичного вычисления в тех
местах, где семантика не отличается.\footnote{Они стараются выполнить
  {\em анализ строгости}~--- один из видов статического анализа,
  который часто помогает определить, что аргументы должны быть
  вычислены \cite{mycroft-thesis}.}  В противоположность этому, в ML
мы всегда сначала вычисляем аргументы функций, и только затем
выполняем $\beta$-редукцию~--- это просто и эффективно, и легко
реализуется с использованием стандартных технологий построения
компиляторов.

Второй причиной для выбора аппликативного порядка вычислений является
то, что ML не является {\em чистым} функциональным языком, а имеет
императивные возможности (переменные, присваивание и т.п.).
Следовательно, порядок вычисления подвыражений может изменить {\em
  семантику}, а не просто влияет на эффективность.  Если используется
ленивое вычисление, то для программиста становится практически
невозможно отчётливо представить (в нетривиальной программе) когда
какое подвыражение вычисляется.  В энергичной системе ML, нужно лишь
помнить простое правило вычисления.

Однако важно осознавать, что стратегия вычислений ML {\em не} просто
снизу вверх, в противоположность нормальному порядку редукции. В
действительности ML {\em никогда не вычисляет содержимое
  $\lambda$-абстракций}.  (В частности, он никогда не
редуцирует $\eta$-редексы, а только $\beta$-редексы.)  При
вычислении  $(\lamb{x} s[x])\; t$, сначала вычисляется $t$.  Однако
$s[x]$ не затрагивается, поскольку оно является содержимым
$\lambda$-абстракции.  Кроме того, любое подвыражение  $t$, которое
является содержимым $\lambda$-абстракции, также остаётся нетронутым.
Вот точные правила вычисления:

\begin{itemize}

\item Константы вычисляются сами в себя.

\item Вычисления заканчиваются на $\lambda$-абстракциях, и не
  затрагивают их содержимого.  В частности, не выполняется
  $\eta$-преобразование.

\item При вычислении комбинации $s\; t$ {\em сначала} вычисляются оба
  $s$ и $t$.  Потом, при условии что вычисление $s$ дало
  $\lambda$-абстракцию, производится самое внешнее
  $\beta$-преобразование, и процесс повторяется.

\end{itemize}

Порядок вычисления $s$ и $t$ отличается в зависимости от версии ML.  В
той версии, которую мы будем использовать, сначала всегда
вычисляется~$t$.  Строго говоря, мы также должны задать правило для
{\tt let}-выражений, поскольку, как упоминалось, они теперь
рассматриваются как примитивы.  Однако, с точки зрения вычислений, они
могут рассматриваться как раньше, как применение $\lambda$-абстракции к
аргументу, который будет вычислен первым.
% COMMENT# то есть let x = s in t можно рассматривать как
% (lambda x t) s   --lg
Для того, чтобы сделать это явным, правило для 

$$ \mbox{let}\; x = s\; \mbox{in}\; t $$

\noindent гласит, что сначала вычисляются все $s$, а результат
подставляется вместо $x$ в $t$, и в заключение, вычисляется новое
значение $t$.  Давайте рассмотрим некоторые примеры вычисления
выражений:

\begin{eqnarray*}
(\lamb{x} (\lamb{y} y + y)\; x) (2 + 2)
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x) 4   \\
& \goesto & (\lamb{y} y + y) 4                  \\
& \goesto & 4 + 4                               \\
& \goesto & 8
\end{eqnarray*}

Заметьте, что под-терм $(\lamb{y} y + y)\; x$ {\em не редуцируется},
поскольку он находится в пределах $\lambda$-абстракции.  Однако,
редуцируемые термы, \emph{не} находящиеся внутри $\lambda$-абстракций
обоих функций, а также аргумент, редуцируются до того, как вычисляется
применения функции, например, второй шаг будет следующим:

\begin{eqnarray*}
((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; (2 + 2)
& \goesto & ((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; 4           \\
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x)\; 4                   \\
& \goesto & (\lamb{y} y + y)\; 4                                  \\
& \goesto & 4 + 4
\end{eqnarray*}

Тот факт, что ML не вычисляет содержимое $\lambda$-абстракций,
является ключевым для высококвалифицированных программистов на ML.
Это даёт возможность точного контроля за вычислением выражений, и
может использоваться для имитации многих полезных вещей из стратегии
ленивого вычисления.  В следующем разделе мы увидим очень простые
примеры.

\section{Результаты энергичного вычисления}

Использование энергичного вычисления заставляет нас объявить некоторые
дополнительные возможности как примитивы, с их собственными
специальными методами редукции, вместо того, чтобы реализовать их
напрямую, в терминах $\lambda$-исчисления.  В частности, мы не можем
больше рассматривать условную конструкцию:

$$ \mbox{if}\; b\; \mbox{then}\; e_1\; \mbox{else}\; e_2 $$

\noindent как применение обычного трехкомпонентного (тернарного) оператора:

$$ \mbox{COND}\; b\; e_1\; e_2 $$

Причина заключается в том, что в любом случае, из-за применения
энергичного вычисления, мы вычисляем все выражения $b$, $e_1$ и $e_2$,
\emph{до} вычисления содержимого $\mbox{COND}$.  Обычно это пагубно.
Например, заново рассмотрим наше определение функции для вычисления
факториала:

$$ \mbox{let rec fact}(n) = \mbox{if ISZERO}\; n\; \mbox{then}\; 1\;
                            \mbox{else}\; n * \mbox{fact}(\mbox{PRE}\; n) $$

Если условное выражение будет вычислять все свои аргументы, то для вычисления 
$\mbox{fact}(0)$, ветвь `else' также должна быть вычислена, что
в свою очередь вызывает вычисление $\mbox{fact}(\mbox{PRE}\; 0)$.  И
это в свою очередь вызывает вычисление $\mbox{fact}(\mbox{PRE}\;
(\mbox{PRE}\; 0))$, и т.д.  Соответственно, вычисление превратится в
бесконечный цикл.

Таким образом, мы делаем условное выражение примитивной конструкцией,
и изменяем обычную стратегию редукции таким образом, что {\em сначала}
% BUG# два 'таким образом' в одном предложении --lg
вычисляется логическое выражение, а затем вычисляется {\em только
  одна} соответствующая ветвь условия.

А что происходит с самим процессом рекурсии?  Мы предложили
понимание рекурсивных определений с точки зрения рекурсивного оператора
$Rec$ с его собственным правилом редукции:

$$ Rec\; f \goesto f(Rec\; f) $$

\noindent он также будет зацикливаться при использовании стратегии
энергичного вычисления:

$$  Rec\; f \goesto f(Rec\; f) \goesto f(f(Rec\; f)) \goesto f(f(f(Rec\; f)))
\goesto \cdots $$

Однако, нам необходимо лишь очень простое изменение в правиле
редукции, чтобы всё работало правильно:

$$ Rec\; f \goesto f(\lamb{x} Rec\; f\; x) $$

Теперь, $\lambda$-абстракция справа означает, что $\lamb{x} Rec\; f\;
x$ вычисляется само в себя (то есть не вычисляется вовсе), и только
после того, как выражение было редуцировано за счёт подстановки этой
$\lambda$-абстракции в теле $f$, вычисление продолжается.

\section{Семейство языков ML}

Мы говорили о `ML' так, как будто это один язык.  На самом деле
существует много вариантов ML, даже включая `Lazy ML', реализацию
университета Chalmers в Швеции, которая базируется на ленивых
вычислениях.  Наиболее популярная версия ML в образовании~--- это
`Standard ML', но мы будет использовать другую версию, которая называется
CAML (`camel') Light.\footnote{Это имя означает `Categorical Abstract
  Machine', метод реализации, лежащий в её основе.}  Мы выбрали CAML
Light по следующим причинам:

\begin{itemize}

\item реализация имеет небольшой объём и хорошо переносима между
  платформами, так что она эффективно работает на Unix, PC, Macs, и
  других.

\item Система очень проста, синтаксически и семантически, что делает
  её достаточно простой для изучения.

\item Система хорошо подходит для практического использования.
  Например, она имеет интерфейс к библиотекам на языке C и
  поддерживает стандартную, раздельную компиляцию, совместимую с {\tt
    make}.

\end{itemize}

Однако, мы будем изучать достаточно общие техники, и любой написанный
код, может быть запущен (с небольшими синтаксическими изменениями) на
любой версии ML, и часто, на других функциональных языках.

\section{Запуск ML}

ML уже установлен на рабочий сервер (Thor).  Для того, чтобы
использовать его, вам необходимо поместить каталог с исполняемыми
файлами CAML в переменную среды {\tt PATH}.  Это может быть сделано
следующим образом (предполагая, что вы используете командный процессор
`bash' или что-то из его семейства):

\begin{boxed}
\begin{verbatim}
  PATH="$PATH:/home/jrh13/caml/bin"
  export PATH
\end{verbatim}
\end{boxed}%$

Чтобы не вводить эти команды при каждом заходе на сервер, вы можете
вставить эти команды в конец вашего файла {\tt .bash\_profile}, или
его эквивалента для вашего командного процессора.  Теперь, для
использования CAML в интерактивном режиме, вам просто надо набрать
{\tt camllight}, и программа должна запуститься и выдать приглашение
(`{\tt \#}'):

\begin{boxed}
\begin{verbatim}
  $ camllight
  >       Caml Light version 0.73

  #
\end{verbatim}
\end{boxed}%$

Для того, чтобы выйти из системы, просто наберите {\tt ctrl/d} или
{\tt quit();;} в строке приглашения.  Если вы заинтересованы в
установке CAML Light на ваш собственный компьютер, то вы должны
прочитать следующую Web-страницу для получения подробной информации:

\begin{boxed}
\begin{verbatim}
  http://pauillac.inria.fr/caml/
\end{verbatim}
\end{boxed}

\section{Взаимодействие с ML}

Когда ML выдаст вам строку приглашения, вы можете вводить выражения,
завершённые двумя последовательными знаками ``точка с запятой''.  ML
будет вычислять их и выдавать результат.  На компьютерном жаргоне
говорят, что ML находится в состоянии ``read-eval-print loop
(цикл чтение-вычисление-печать)???'': выражения считываются,
% BUG# надо остановиться на чём-либо --lg
вычисляются и печатаются результаты.  Например, ML может быть
использован как простой калькулятор:

\begin{boxed}
\begin{verbatim}
  #10 + 5;;
  - : int = 15
\end{verbatim}
\end{boxed}

Система не только возвращает ответ, но также выдаёт  {\em тип}
выражения, который определяется автоматически.  Система может сделать
это, поскольку знает тип встроенного оператора сложения {\tt +}.  С
другой стороны, если для выражения не может быть определён тип, то
система отвергнет его, и постарается выдать сообщение о том, почему
произошла ошибка.  В сложных случаях, сообщения об ошибках  достаточно
тяжело понять.

\begin{boxed}
\begin{verbatim}
  #1 + true;;
  Toplevel input:
  >let it = 1 + true;;
  >             ^^^^
  This expression has type bool,
  but is used with type int.
\end{verbatim}
\end{boxed}

Поскольку ML является функциональным языком, то выражения могут иметь
функциональный тип.  Для $\lambda$-абстракций $\lamb{x} t[x]$ ML предоставляет
следующий синтаксис~--- {\tt fun x -> t[x]}.  Например, мы можем
определить функцию ``следующий successor'':
% BUG# в l5.tex переведено как 'инкремент', на чём лучше остановится? --lg

\begin{boxed}
\begin{verbatim}
  #fun x -> x + 1;;
  - : int -> int = <fun>
\end{verbatim}
\end{boxed}

Как и в предыдущем примере, тип выражения (сейчас это {\tt int ->
  int}), выводится и выдаётся на экран.  Однако сама функция не
печатается; система лишь выдаёт {\tt <fun>}.  Это сделано потому, что
внутреннее представление функций не шибко читабельно.\footnote{CAML не
  хранит их как синтаксические деревья, а компилирует в байт-код.}
Функции применяются к соседним аргументам, также как и в
$\lambda$-исчислении.  Например:

\begin{boxed}
\begin{verbatim}
  #(fun x -> x + 1) 4;;
  - : int = 5
\end{verbatim}
\end{boxed}

Опять же, как и в $\lambda$-исчислении, применение функции ассоциируется
слева, и вы можете написать каррированные функции, используя  то же
самое соглашение по сокращению повторяющихся $\lambda$-абстракций (т.е.,
{\tt fun}-й).  Например, все следующие выражения эквивалентны:

\begin{boxed}
\begin{verbatim}
  #((fun x -> (fun y -> x + y)) 1) 2;;
  - : int = 3
  #(fun x -> fun y -> x + y) 1 2;;
  - : int = 3
  #(fun x y -> x + y) 1 2;;
  - : int = 3
\end{verbatim}
\end{boxed}

\section{Связывания и объявления}

Конечно, это не совсем удобно~--- вычислять всё выражение за один шаг;
вместо этого, мы можем использовать {\tt let} для связывания полезных
подвыражений с именами. Это может быть сделано следующим образом:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1 in
   successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent Для связывания функций может использоваться более элегантная
конструкция:

\begin{boxed}
\begin{verbatim}
  #let successor x = x + 1 in
  successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent и можно использовать рекурсию, добавив ключевое слово {\tt
  rec}:

\begin{boxed}
\begin{verbatim}
  #let rec fact n = if n = 0 then 1
                    else n * fact(n - 1) in
   fact 6;;
  - : int = 720
\end{verbatim}
\end{boxed}

Используя {\tt and}, мы можем сделать несколько связываний
одновременно, и определить взаимно рекурсивные функции. Вот пример
двух простых, хотя сильно неэффективных, функций, которые определяют,
является ли натуральное число чётным или нечётным:

\begin{boxed}
\begin{verbatim}
  #let rec even n = if n = 0 then true else odd (n - 1)
       and odd n  = if n = 0 then false else even (n - 1);;
  even : int -> bool = <fun>
  odd : int -> bool = <fun>
  #even 12;;
  - : bool = true
  #odd 14;;
  - : bool = false
\end{verbatim}
\end{boxed}

В действительности, любое связывание может быть сделано отдельно от
его применения.  ML помнит набор связанных переменных и пользователь
может пополнять данный набор интерактивно.  Просто уберите {\tt in} и
завершите выражение двойной точкой с запятой:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1;;
  successor : int -> int = <fun>
\end{verbatim}
\end{boxed}

\noindent После этого объявления, любое последующее выражение может
использовать функцию {\tt successor}, например:

\begin{boxed}
\begin{verbatim}
  #successor 11;;
  - : int = 12
\end{verbatim}
\end{boxed}

Заметьте, что мы не делаем {\em присвоений} {\em переменных}.  Каждое
связывание выполняется только раз, когда система анализирует введённые
данные; оно не может быть повторено или изменено.  Оно может быть
перезаписано новым определением с тем же именем, но это не присвоение,
в своём обычном значении, поскольку последовательность событий связана
только с процессом {\em компиляции}, а не с динамикой {\em выполнения}
программы.  Конечно, отходя от интерактивного получения ответа от
системы, мы можем полностью заменить все двойные точки с запятой,
записанные после объявлений, на {\tt in} и вычислить всё за раз.  С
этой точки зрения видно, что переписывание объявления в
действительности соответствует определению новой локальной переменной,
которая скрывает предыдущую, в соответствии с обычными правилами
$\lambda$-исчисления.  Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let y = 2;;
  y : int = 2
  #let x = 3;;
  x : int = 3
  #x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

\noindent является тем же самым, что и:

\begin{boxed}
\begin{verbatim}
  #let x = 1 in
   let y = 2 in
   let x = 3 in
   x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

Обязательно заметьте, что следуя $\lambda$-исчислению, связывание
переменных является {\em статическим}, например, первое связывание
{\tt x} используется до того, как будет сделано новое связывание, и
любое его использование до нового определения, не будет затронуто
новым определением.  Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let f w = w + x;;
  f : int -> int = <fun>
  #let x = 2;;
  x : int = 2
  #f 0;;
  - : int = 1
\end{verbatim}
\end{boxed}

Первые версии LISP, однако, использовали {\em динамическое}
связывание, когда переопределение переменной также распространялось на
предыдущие использования этой переменной, так что аналогичная
последовательность команд, должна будет вернуть число 2.  В
действительности это считалось ошибкой, но скоро программисты начали
использовать эту возможность.  Это означало, что когда некоторая
низкоуровневая функция изменялась, то изменения распространялись на
все её применения в других функциях без необходимости в их
перекомпиляции.  Эта возможность продолжала существовать долгое время
во многих диалектах LISP, но в конечном счёте победила идея, что
статическое связывание лучше.  В Common LISP по умолчанию используется
статическое связывание, но динамическое связывание можно разрешить,
если необходимо, используя ключевое слово {\tt special}.

\section{Полиморфные функции}

Мы можем определять полиморфные функции, такие как оператор
тождественного отображения:

\begin{boxed}
\begin{verbatim}
  #let I = fun x -> x;;
  I : 'a -> 'a = <fun>
\end{verbatim}
\end{boxed}

ML печатает типовые переменные как {\tt 'a}, {\tt 'b} и~т.д.
Предполагается, что они являются ASCII-представлением для $\alpha$,
$\beta$ и~т.д.  Мы можем использовать полиморфную функцию с разными
типами:

\begin{boxed}
\begin{verbatim}
  #I true;;
  - : bool = true
  #I 1;;
  - : int = 1
  #I I I I 12;;
  - : int = 12
\end{verbatim}
\end{boxed}

В данном примере все вхождения {\tt I} имеют различные типы и
интуитивно соответствуют разным функциям.  Давайте определим все
комбинаторы:

\begin{boxed}
\begin{verbatim}
  #let I x = x;;
  I : 'a -> 'a = <fun>
  #let K x y = x;;
  K : 'a -> 'b -> 'a = <fun>
  #let S f g x = (f x) (g x);;
  S : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c = <fun>
\end{verbatim}
\end{boxed}

Заметьте, что система сама следит за типами, несмотря на то что в
последнем случае они были довольно сложными.  Теперь, вспомним, что $I =
S\; K\; K$; давайте попробуем сделать это на ML:\footnote{Отметим,
  что с точки зрения отсутствия типов, $S\; K\; A = I$ верно для любого $A$.
  Однако, читатель может сам попробовать, например, $S\; K\; S$ и
  убедиться, что его тип, является менее общим, чем ожидалось.}
% COMMENT# По поводу этого footnote:
% http://users.livejournal.com/_darkus_/336760.html
% I = Y(SK);;  !!  --lg

\begin{boxed}
\begin{verbatim}
  #let I' = S K K;;
  I' : '_a -> '_a = <fun>
\end{verbatim}
\end{boxed}

\noindent Выражение имеет правильный тип,\footnote{Игнорируйте
  подчёркивания.  Это связано с типизированием императивных
  возможностей, и мы обсудим это позже.} и может быть легко проверено
на конкретных случаях, например:

\begin{boxed}
\begin{verbatim}
  #I' 3 = 3;;
  - : bool = true
\end{verbatim}
\end{boxed}

В приведённых примерах полиморфных функций, система очень быстро
выводит наиболее общий тип для каждого выражения, и тип, который она
выводит, является простым.  Так обычно и происходит на практике, но
существуют патологические случаи, например, следующий пример,
приведённый в \citeN{mairson-ml}.  Тип этого выражения вычисляется
около 10 секунд, и занимает более 4000 строк на 80-символьном
терминале.

\begin{boxed}
\begin{lstlisting}
  let pair x y = fun z -> z x y in
  let x1 = fun y -> pair y y in
  let x2 = fun y -> x1(x1 y) in
  let x3 = fun y -> x2(x2 y) in
  let x4 = fun y -> x3(x3 y) in
  let x5 = fun y -> x4(x4 y) in
  x5(fun z -> z);;
\end{lstlisting}
\end{boxed}

Мы сказали, что программист на ML никогда не вводит тип.  Это правда в
том смысле, что ML уже назначит наиболее общий тип для выражения.
Однако, иногда бывает полезно {\em ограничить} вывод типа.  Это не
заставит работать код, который до этого не работал, но может
использоваться как документация для понимания того, для чего этот код
предназначен; также возможно использовать более короткие синонимы для
сложных типов.  Ограничение типа может быть задано в ML путём
добавления {\em аннотации типа} после некоторого выражения(й).
Аннотации типов состоят из двоеточия, за которым указан тип.  Обычно
не имеет значения то, где эти аннотации добавлены, если они есть, то
они заставляют использовать соответствующие ограничения.  Например,
вот несколько альтернативных вариантов ограничения функции
тождественного отображения к типу {\tt int -> int}:

\begin{boxed}
\begin{verbatim}
  #let I (x:int) = x;;
  I : int -> int = <fun>
  #let I x = (x:int);;
  I : int -> int = <fun>
  #let (I:int->int) = fun x -> x;;
  I : int -> int = <fun>
  #let I = fun (x:int) -> x;;
  I : int -> int = <fun>
  #let I = ((fun x -> x):int->int);;
  I : int -> int = <fun>
\end{verbatim}
\end{boxed}

\section{Равенство функций}

Вместо сравнения действий $I$ и $I'$ на отдельные аргументы, такие как
$3$, может показаться, что мы можем разрешить данный вопрос путём
сравнения самих функций.  Однако, это не работает:

\begin{boxed}
\begin{verbatim}
  #I' = I;;
  Uncaught exception: Invalid_argument "equal: functional value"
\end{verbatim}
\end{boxed}

В общем случае {\em запрещено} сравнивать функции, хотя в нескольких
специальных случаях, когда равенство функций очевидно, выдаётся {\tt
  true}.

\begin{boxed}
\begin{verbatim}
  #let f x = x + 1;;
  f : int -> int = <fun>
  #let g x = x + 1;;
  g : int -> int = <fun>
  #f = f;;
  - : bool = true
  #f = g;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #let h = g;;
  h : int -> int = <fun>
  #h = f;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #h = g;;
  - : bool = true
\end{verbatim}
\end{boxed}

Почему существуют эти ограничения?  Разве в ML функции не являются
объектами высшего порядка?  Да, но к сожалению, (экстенсиональное)
равенство функций невычислимо.  Это следует из различных классических
теорем в теории рекурсии, таких как {\em Неразрешимость проблемы
  останова} и {\em Теорема Райса}.\footnote{Вы увидите
  доказательства в курсе теории вычислений.  Теорема Райса~---
  чрезвычайно сильный вывод о неразрешимости, которая утверждает, что
  {\em любое} нетривиальное свойство функции, соответствующее
% COMMENT# нетривиальное свойство это такое свойство, для которого
% есть функции как обладающие им так и не обладающие --lg
  программе, невычислимо из её текста.  Отличной книгой по теории
  вычислений является~\citeN{davis-weyuker}.}  Позвольте нам дать
конкретный пример, почему это может быть так.  Это всё ещё открытая
проблема~--- будет ли следующая функция завершена для всех её
аргументов, предположение, что это так, известно как {\em Гипотеза
  Коллатца (Collatz conjecture)}:\footnote{Хороший обзор этой
  проблемы, и попытки решить её, приведены в~\citeN{lagarias-collatz}.
  Честно говоря, мы должны использовать целые числа с неограниченной
  точностью, а не машинную арифметику.  Позже мы увидим как это
  сделать.}

\begin{boxed}
\begin{verbatim}
  #let rec collatz n =
     if n <= 1 then 0
     else if even(n) then collatz(n / 2)
     else collatz(3 * n + 1);;
  collatz : int -> int = <fun>
\end{verbatim}
\end{boxed}

Хотя ясно, что если она завершается, то возвращает~$0$. Теперь
рассмотрим следующую тривиальную функцию:

\begin{boxed}
\begin{verbatim}
  #let f (x:int) = 0;;
  f : int -> int = <fun>
\end{verbatim}
\end{boxed}

Решение уравнение {\tt collatz = f}, компьютер подтвердил бы
гипотезу Коллатца.  Очень легко придумать другие примеры для открытых
математических проблем.

Представляется возможным перехватить применение оператора сравнения к
функциям и типам, построенных из них, на этапе проверки типов, а не в
момент выполнения.  Типы, которые не вовлекают использование функций
такими способами, известны как {\em сравнимые типы}, поскольку всегда
возможно проверить объекты таких типов на равенство.  С другой
стороны, это делает систему типов более сложной.  Однако, некоторые
могут аргументировать, что статическая проверка типов должна быть
расширена насколько это возможно.

\section*{Дополнительная литература}

Много книг о функциональном программировании содержат информацию об
общих вещах, которые мы обсуждали, таких как стратегии вычислений.
Хорошее элементарное введение в CAML Light и функциональное
программирование можно найти в~\citeN{mauny-tutorial}.
\citeN{paulson-ml}~также является хорошей книгой, хотя основывается на
Standard~ML.

\section*{Примеры}

\begin{enumerate}

\item Предположим, что `функция-условие', определённая {\tt ite(b,x,y)
    = if b then x else y} является единственной функцией, которая
  может работать с аргументами типа {\tt bool}.  Существует ли способ
  написать функцию факториала?

\item Используйте правила типизирования приведённые в предыдущей главе
  для того, чтобы вывести формальное доказательство, что
  комбинатор~$S$ имеет тот тип, который выдаёт~ML.

\item Напишите простую, рекурсивно определённую функцию для возведения
  в степень целых чисел, т.е. вычисляющую $x^n$ для $n \geq 0$.
  Напишите две функции на ML, эквивалентность которых соответствует
  истинности последней теоремы Ферма: не существует целых чисел $x$,
  $y$, $z$ и натурального числа $n > 2$, так что $x^n + y^n = z^n$, за
  исключением тривиального случая, когда $x = 0$ или $y = 0$.
%BUG# не совсем понял, что значит ``эквивалентность которых
%соответствует истинности''.  Что за функции такие? --lg

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
