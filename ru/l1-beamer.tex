\documentclass{fp-slides}

\begin{document}

%%%%%%%%%%%%%%% Define code blocks

\defverbatim[colored]\factCcode{%
\begin{lstlisting}[frame=single,language=C]
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{lstlisting}}

\defverbatim[colored]\factMLcode{%
\begin{lstlisting}[frame=single]
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}}

\defverbatim[colored]\badFuncCode{%
\begin{lstlisting}[frame=single]
  int rand(void)
  { static int n = 0;
    return n = 2147001325 * n + 715136305;
  }
\end{lstlisting}}

%%%%%%%%%%%%%%%%%%%%%%

\frame{\titlepage}

\section*{Лекция 1. Введение и Обзор}

%\subsection{Обсуждаемые темы}


\frame{
  \frametitle{Темы, обсуждаемые на лекции}

  \begin{itemize}
  \item Императивное программирование
    \maybepause
    
  \item Функциональное программирование
    \maybepause

  \item Достоинства функционального программирования
    \maybepause

  \item Обзор курса
    \maybepause

  \item $\lambda$-нотация и её достоинства

  \end{itemize}
}



\frame{
  \frametitle{Императивное Программирование}

Императивные (или процедурные) программы основываются на изменении
{\em состояния} с помощью последовательности выполняемых {\em команд}.

Состояние в основном изменяется при помощи команды {\em присваивания},
записываемой как \mbox{\alert{\tt v = E}} или \mbox{\alert{\tt v := E}}.

Мы можем выполнить одну команду за другой, написав их последовательно,
возможно разделяя точкой с запятой: \alert{$C_1 \mbox{ ; } C_2$}.

Команды выполняются условно при помощи \alert{\tt if}, и циклично при
помощи \alert{\tt while}.

Программы - последовательности инструкций по изменению состояния.

Императивные языки программирования, такие как FORTRAN, Algol, C,
Modula-3, поддерживают такой стиль программирования.  

}


\frame{
  \frametitle{Абстрактный вид}

Забудем про операции ввода-вывода и допустим, что программа работает
конечное время, производя какой-либо результат.

Рассмотрим выполнение в абстрактном виде:

\alert{$$ \sigma_0 \to \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n $$}

Программа стартует в вычислителе с начальным состоянием \alert{$\sigma_0$},
содержащем входные значения для программы.


После завершения программы, вычислитель оказывается в состоянии \alert{
$\sigma_n$}, содержащем результат(ы) работы программы.


Состояние изменяется конечное число раз из \alert{$\sigma_0$} в
\alert{$\sigma_n$}; в принципе, каждая команда может изменить
состояние.

}



\frame{
  \frametitle{Функциональное программирование}

  Функциональная программа - это просто {\em выражение}, а выполнение
  программы - это {\em вычисление} выражения.

  \begin{itemize}
  \item Нет состояний, то есть \alert{нет переменных}.
    \maybepause

\item Поэтому \alert{нет присваивания}, ибо не к чему присваивать.

    \maybepause

\item Нет \alert{последовательности исполнения} и \alert{нет циклов},
      поскольку вычисление одного выражения не влияет на вычисление
      другого.

    \maybepause

  \end{itemize}

С другой стороны:

\begin{itemize}

\item Мы можем определять \alert{рекурсивные функции}, создавая что-то
  наподобие циклов.

    \maybepause

\item Более гибкое использование функций, например, мы можем
  определять \alert{функции высшего порядка}.

    \maybepause

\end{itemize}

Функциональные языки поддерживают такой стиль программирования.
}

\frame{
  \frametitle{Пример: факториал}

Мы можем записать функцию для вычисления факториала в императивном
стиле на языке C следующим образом:

\factCcode

\noindent тогда как на ML это можно выразить рекурсивной фукнцией:

\factMLcode

}

\frame{
  \frametitle{Зачем?}

  На первый взгляд язык без переменных, присваивания и
  последовательностей команд выглядит совсем непрактично.

  В этом курсе мы покажем, как много интересного можно сделать,
  используя функциональный стиль программирования.


  Императивные языки были созданы как абстракция над ''железом'' - от
  машинного кода, ассемблеров и макро-ассемблеров до FORTRANа и ему
  подобных.

  Возможно это ошибочный подход, и нам следует смотреть на задачу
  глазами человека.  Возможно, функциональные языки больше подходят
  для использования людьми.

  Но каковы конкретные причины для выбора функциональных языков?

}

\frame{
  \frametitle{Достоинства функционального программирования}

  Избегая использования переменных и операций присваивания мы получаем
  следующие преимущества:

  \begin{itemize}
  \item Более ясную семантику.  Программы больше соответствуют
    абстрактным математическим объектам.

    \maybepause

  \item Б\'{о}льшая свобода исполнения операций, например
    распараллеливаемость.

    \maybepause
  \end{itemize}

Используя функции более гибко, мы имеем:

\begin{itemize}

\item Выразительность и элегантность.
    \maybepause

\item Лучшая параметризация и модульность программ.
    \maybepause

\item Удобные способы представления бесконечных данных.
    \maybepause

\end{itemize}
}


\frame{
  \frametitle{Денотационная семантика}

Функцию факториала на ML мы можем представить как
математическую (частичную) функцию \alert{$\num \to \num$}:

%\begin{red}
$$ \sem{\mbox{fact}}(n) = \left\{ \begin{array}{ll}
                                 n! & \mbox{if $n \geq 0$} \\
                                 \bot & \mbox{otherwise}
                          \end{array} \right. $$
%\end{red}

\noindent где \alert{$\bot$} - неопределённость.

Если у нас появляется состояние, то такое представление не работает.
Вот `функция' на C, которой не соответствует ни одна математическая
функция:

\badFuncCode

Она выдаёт различные значения при успешных вызовах!

}

\frame{
  \frametitle{Семантика императивных программ}

  Чтобы создать надлежащую семантику для императивных программ, нам
  необходимо явно определить состояние.  Например, мы можем создавать
  команды как:

  \begin{itemize}
\item Частичные функции \alert{$\Sigma \to \Sigma$} (Strachey)
    \maybepause

\item Отношения \alert{$\Sigma \times \Sigma$} (Hoare)
    \maybepause

\item Предикатные преобразователи, то есть всюду определённые функции
      \alert{$(\Sigma \to bool) \to (\Sigma \to bool)$} (Dijkstra)
    \maybepause
  \end{itemize}

Даже если позволить инструкцию \alert{\tt goto}, то этого мало и нам
нужна семантика, основанная на {\em продолжениях} (Wadsworth, Morris).

Все эти методы достаточно сложны.

В функциональных программах у нас есть возможность проверить их
корректность, или корректность определённых преобразований, или
оптимизаций.

}



\frame{
  \frametitle{Проблемы с функциональными программами}

Функциональное программирование не лишено недостатков.  Некоторые вещи
сложнее внедрить в чисто функциональную модель, например:

  \begin{itemize}
\item Ввод-вывод
    \maybepause

\item Интерактивные или постоянно запущенные программы (редакторы и
      др.)
    \maybepause

  \end{itemize}

Зачастую, чтобы добиться всего этого, можно использовать бесконечные
структуры данных.

Функциональные языки также в меньшей степени соответствуют
современному аппаратному обеспечению, поэтому функциональные программы
могут быть менее эффективными, а оценка времени исполнения и
потребляемых ресурсов~--- непростой.

ML не чисто функциональный язык, поэтому вы можете использовать присваивание
переменных, если это потребуется.  Большинство наших программ написано на
чисто функциональном подмножестве языка.
}


\frame{
  \frametitle{Обзор курса (1)}

Мы начнём с теоретического фундамента - $\lambda$-исчисления, и
дойдём до практического применения программирования на ML.

Ориентировочно треть курса посвящена теории и две трети практике.

Теоретические части:

\begin{enumerate}

\item Введение и обзор (эта лекция)
    \maybepause

\item $\lambda$-исчисление как формальная система
    \maybepause

\item $\lambda$-исчисление как язык программирования
    \maybepause

\item Типы

\end{enumerate}

}


\frame{
  \frametitle{Обзор курса (2)}

Практические или `прикладные' части курса:

\begin{enumerate}

\item Введение в ML
    \maybepause

\item Разбор полиморфизма
    \maybepause

\item Рекурсивные типы
    \maybepause

\item Доказательства программ
    \maybepause

\item Продвинутый ML
    \maybepause

\item Другие стили функционального программирования
    \maybepause

\item Примеры на ML (1)
    \maybepause

\item Примеры на ML (2)
    \maybepause

\end{enumerate}

}


\frame{
  \frametitle{$\lambda$-нотация}

$\lambda$-нотация~-- это способ определения функций, предложенный Алонзо
Чёрчем в 1930 году.  Мы пишем:

\alert{$$ \lamb{x} E[x] $$ }

чтобы определить `функцию от \alert{$x$}, которая выдаёт
\alert{$E[x]$}'.  Здесь \alert{$E[x]$}~-- это выражение, которое
содержит или не содержит \alert{$x$}.

Например, \alert{$\lamb{x} x$}~-- это функция тождественного отображения,
которая возвращает заданный аргумент, а \alert{$\lamb{x} x^2$}~-- это
функция возведения в квадрат.

Литера \alert{$\lambda$}~-- историческая случайность. Первоначально
Чёрч использовал обозначение \alert{$\hat{x}.\; E[x]$}, а серия ошибок
набора превратило его в нынешнюю форму. Иногда также пишут \alert{$x
  \mapsto E[x]$} и \alert{$[x]\; E[x]$}.

}


\frame{
  \frametitle{Зачем?}

В неформальной математике, когда мы говорим о функции, то обычно даём
ей какое-то имя: `Пусть \alert{$f(x) = E[x]$} \ldots тогда \alert{$\cdots f
\cdots$}'.

Также, большинство языков программирования позволяют определить функцию
только, если ей будет дано имя.

Такой подход не совсем оправдан.  Он означает, что мы не рассматриваем
функции наравне с другими математическими объектами.  Мы не говорим:

\begin{quote}
Определим \alert{$x$} и \alert{$y$} как \alert{$x = 2$} и \alert{$y = 4$}
соответственно. Тогда \alert{$x x = y$}
\end{quote}

$\lambda$-нотация помогает привести функции в равное положение.  Это
является важным аспектом функционального программирования.

}


\frame{
  \frametitle{Преимущества $\lambda$-нотации}

$\lambda$-нотация также может быть полезна для улучшения ясности
математического изложения.

Когда мы говорим \alert{$x + x y$}, то часто не разъясняем, является ли
это выражение определённым значением для конкретного \alert{$x$}, или
это функция от \alert{$x$} (или \alert{$y$} \ldots).  Используя
$\lambda$-нотацию мы можем явно это обозначить.

Вообще, используя только:

\begin{itemize}

\item Переменные, например \alert{$x$}, \alert{$y$}.
    \maybepause

\item Константы, например \alert{$3$}, \alert{$true$}, \alert{$+$}.
    \maybepause

\item Применение функции к аргументам, например \alert{$f\; x$}.
    \maybepause

  \item $\lambda$-абстракция выражения над переменными, например
    \alert{$\lamb{x} x + y$}

\end{itemize}

мы составим основной `абстрактный синтаксис' математики.

}


\frame{
  \frametitle{Каррирование}

У нас могут быть функции от двух и более аргументов, например
\alert{$\lamb{x} \lamb{y} x + y$}.

Мы можем думать о ней как о функции от одного аргумента \alert{$\num
  \to (\num \to \num)$}.  Если дан аргумент, допустим \alert{$2$}, то
она возвращает функцию от одного аргумента \alert{$\num \to \num$},
которая прибавляет \alert{$2$} к своему аргументу.  Этот принцип
известен как {\em каррирование}, в честь Хаскелла Карри.

Примем соглашение, что \alert{$\lamb{x\; y} E[x,y]$} означает
\alert{$\lamb{x} \lamb{y} E[x,y]$}, и что функция применяется всегда к
левому аргументу, например \alert{$f\; x\; y$} означает
\alert{$(f(x))(y)$}.  Это поддерживает каррирование, например

\alert{$$ (\lamb{x\; y} x + y)\;1\;2 = (\lamb{y} 1 + y)\;2 = 1 + 2 $$}

Заметим что скобки опциональны.

}


\frame{
  \frametitle{Связывание переменных}

Многие конструкции в математике {\em связывают} переменные.  Переменная
\alert{$x$} в 

\alert{$$ \int_0^a 3 x^2 \; dx $$}

связана, тогда как \alert{$a$} свободна; также \alert{$n$} связана, а
\alert{$k$} свободна в

\alert{$$ \Sigma_{n=0}^k n^2 $$}

Мы увидим, что свободные и связанные переменные могут быть достаточно
сложными.  Используя $\lambda$-нотацию, все эти конструкции связывания
переменных могут быть разбиты таким образом, что единственной операцией
связывания будет $\lambda$-абстракция.

}

\frame[shrink=5]{
  \frametitle{Пример дифференцирования}

  Например, общепринятая конструкция \alert{${d \over dx} x^2$} может
  быть разложена как:

  \alert{$$ D\; (\lamb{x} \mbox{EXP } x\; 2)\; x $$}

  где \alert{$D$} (каррированный) оператор дифференцирования
  \alert{$(\real \to \real) \to \real \to \real$}, возвращающий
  производную его первого аргумента в точке, заданной вторым
  аргументом, а \alert{$\mbox{EXP}$} - функция возведения в степень.

  Получается, что тут две переменные \alert{$x$}, одна связана, а
  другая нет.  Аналогично в

  \alert{$$ \int_0^x 2 x \; dx $$}

  в данном случае общепринятая запись корректно разделяет их.

}


\frame{
  \frametitle{Парадокс Рассела}

  Изначально Чёрч надеялся использовать $\lambda$-нотацию как основу
  математики, введя константы для логических операций, например чтобы
  \alert{$\Not$} означало `не'.  К сожалению, у него не получилось,
  ибо определяя \alert{$R = \lamb{x} \Not\; (x\; x)$} мы получаем:

  \alert{$$ R\; R = (\lamb{x} \Not\; (x\; x)) \; R = \Not\; (R\;
    R) $$}

  Как мы знаем, существует соответствие между множествами и их
  характеристической функцией, поэтому, если думать о \alert{$s\;x$}
  как о \alert{$x \in s$}, то получается хорошо известный парадокс
  Рассела о множестве всех множеств, не содержащих себя.

  \alert{$$ R = \{x \mid x \not\in x\} $$}

}

\end{document}
