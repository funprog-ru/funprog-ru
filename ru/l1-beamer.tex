\documentclass{fp-slides}

\usetheme{Warsaw}

\begin{document}

\frame{\titlepage}

\section*{Лекция 1. Введение и Обзор}

%\subsection{Обсуждаемые темы}


\frame{
  \frametitle{Темы, обсуждаемые на лекции}

  \begin{itemize}
  \item Императивное программирование
    \pause
    
  \item Функциональное программирование
    \pause

  \item Достоинства функционального программирования
    \pause

  \item Обзор курса
    \pause

  \item $\lambda$-нотация и её достоинства

  \end{itemize}
}



\frame{
  \frametitle{Императивное Программирование}

Императивные (или процедурные) программы основываются на изменении
{\em состояния} с помощью последовательности выполняемых {\em команд}.

Состояние в основном изменяется при помощи команды {\em присваивания},
записываемой как \mbox{\alert{\tt v = E}} или \mbox{\alert{\tt v := E}}.

Мы можем выполнить одну команду за другой, написав их последовательно,
возможно разделяя точкой с запятой: \alert{$C_1 \mbox{ ; } C_2$}.

Команды выполняются условно при помощи \alert{\tt if}, и циклично при
помощи \alert{\tt while}.

Программы - последовательности инструкций по изменению состояния.

Императивные языки программирования, такие как FORTRAN, Algol, C,
Modula-3, поддерживают такой стиль программирования.  

}


\frame{
  \frametitle{Абстрактный вид}

Забудем про операции ввода-вывода и допустим, что программа работает
конечное время, производя какой-либо результат.

Рассмотрим выполнение в абстрактном виде:

\alert{$$ \sigma_0 \to \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n $$}

Программа стартует в вычислителе с начальным состоянием \alert{$\sigma_0$},
содержащем входные значения для программы.


После завершения программы, вычислитель оказывается в состоянии \alert{
$\sigma_n$}, содержащем результат(ы) работы программы.


Состояние изменяется конечное число раз из \alert{$\sigma_0$} в
\alert{$\sigma_n$}; в принципе, каждая команда может изменить
состояние.

}



\frame{
  \frametitle{Функциональное программирование}

  Функциональная программа - это просто {\em выражение}, а выполнение
  программы - это {\em вычисление} выражения.

  \begin{itemize}
  \item Нет состояний, то есть \alert{нет переменных}.
    \pause

\item Поэтому \alert{нет присваивания}, ибо не к чему присваивать.

    \pause

\item Нет \alert{последовательности исполнения} и \alert{нет циклов},
      поскольку вычисление одного выражения не влияет на вычисление
      другого.

    \pause

  \end{itemize}

С другой стороны:

\begin{itemize}

\item Мы можем определять \alert{рекурсивные функции}, создавая что-то
  наподобие циклов.

    \pause

\item Более гибкое использование функций, например, мы можем
  определять \alert{функции высшего порядка}.

    \pause

\end{itemize}

Функциональные языки поддерживают такой стиль программирования.
}

\frame{
  \frametitle{Пример: факториал}

Мы можем записать функцию для вычисления факториала в императивном
стиле на языке C следующим образом:

%\begin{red}
% \begin{lstlisting}[language=C]
%   int fact(int n)
%   { int x = 1;
%     while (n > 0)
%      { x = x * n;
%        n = n - 1;
%      }
%     return x;
%   }
% \end{lstlisting}
%\end{red}

\noindent тогда как на ML это можно выразить рекурсивной фукнцией:

%\begin{red}
% \begin{lstlisting}
%   let rec fact n =
%     if n = 0 then 1
%     else n * fact(n - 1);;
% \end{lstlisting}
%\end{red}

}

\frame{
  \frametitle{Зачем?}

На первый взгляд язык без переменных, присваивания и
последовательностей команд выглядит совсем непрактично.

В этом курсе мы покажем, как много интересного можно сделать, используя
функциональный стиль программирования.


Императивные языки были созданы как абстракция над ''железом'' - от
машинного кода, ассемблеров и макро-ассемблеров до FORTRANа и ему
подобных.

Возможно это ошибочный подход, и нам следует смотреть на задачу
глазами человека.  Возможно, функциональные языки больше подходят для
использования людьми.

Но каковы конкретные причины для выбора функциональных языков?

}

\frame{
  \frametitle{Достоинства функционального программирования}

Избегая использования переменных и операций присваивания мы получаем
следующие преимущества:

  \begin{itemize}
  \item Более ясную семантику.  Программы больше соответствуют
    абстрактным математическим объектам.

    \pause

  \item Б\'{о}льшая свобода исполнения операций, например
    распараллеливаемость.

    \pause
  \end{itemize}

Используя функции более гибко, мы имеем:

\begin{itemize}

\item Выразительность и элегантность.
    \pause

\item Лучшая параметризация и модульность программ.
    \pause

\item Удобные способы представления бесконечных данных.
    \pause

\end{itemize}
}


\frame{
  \frametitle{Денотационная семантика}

Функцию факториала на ML мы можем представить как
математическую (частичную) функцию \alert{$\num \to \num$}:

%\begin{red}
$$ \sem{\mbox{fact}}(n) = \left\{ \begin{array}{ll}
                                 n! & \mbox{if $n \geq 0$} \\
                                 \bot & \mbox{otherwise}
                          \end{array} \right. $$
%\end{red}

\noindent где \alert{$\bot$} - неопределённость.

Если у нас появляется состояние, то такое представление не работает.
Вот `функция' на C, которой не соответствует ни одна математическая
функция:

%\begin{red}
% \begin{verbatim}
%   int rand(void)
%   { static int n = 0;
%     return n = 2147001325 * n + 715136305;
%   }
% \end{verbatim}
%\end{red}

Она выдаёт различные значения при успешных вызовах!

}

\frame{
  \frametitle{Семантика императивных программ}

  Чтобы создать надлежащую семантику для императивных программ, нам
  необходимо явно определить состояние.  Например, мы можем создавать
  команды как:

  \begin{itemize}
\item Частичные функции \alert{$\Sigma \to \Sigma$} (Strachey)
    \pause

\item Отношения \alert{$\Sigma \times \Sigma$} (Hoare)
    \pause

\item Предикатные преобразователи, то есть всюду определённые функции
      \alert{$(\Sigma \to bool) \to (\Sigma \to bool)$} (Dijkstra)
    \pause
  \end{itemize}

Даже если позволить инструкцию \alert{\tt goto}, то этого мало и нам
нужна семантика, основанная на {\em продолжениях} (Wadsworth, Morris).

Все эти методы достаточно сложны.

В функциональных программах у нас есть возможность проверить их
корректность, или корректность определённых преобразований, или
оптимизаций.

}



\frame{
  \frametitle{Проблемы с функциональными программами}

Функциональное программирование не лишено недостатков.  Некоторые вещи
сложнее внедрить в чисто функциональную модель, например:

  \begin{itemize}
\item Ввод-вывод
    \pause

\item Интерактивные или постоянно запущенные программы (редакторы и
      др.)
    \pause

  \end{itemize}

Зачастую, чтобы добиться всего этого, можно использовать бесконечные
структуры данных.

Функциональные языки также в меньшей степени соответствуют
современному аппаратному обеспечению, поэтому функциональные программы
могут быть менее эффективными, а оценка времени исполнения и
потребляемых ресурсов~--- непростой.

ML не чисто функциональный язык, поэтому вы можете использовать присваивание
переменных, если это потребуется.  Большинство наших программ написано на
чисто функциональном подмножестве языка.
}


\frame{
  \frametitle{Обзор курса (1)}

Мы начнём с теоретического фундамента - $\lambda$-исчисления, и
дойдём до практического применения программирования на ML.

Ориентировочно треть курса посвящена теории и две трети практике.

Теоретические части:

\begin{enumerate}

\item Введение и обзор (эта лекция)
    \pause

\item $\lambda$-исчисление как формальная система
    \pause

\item $\lambda$-исчисление как язык программирования
    \pause

\item Типы

\end{enumerate}

}


\frame{
  \frametitle{Обзор курса (2)}

Практические или `прикладные' части курса:

\begin{enumerate}

\item Введение в ML
    \pause

\item Разбор полиморфизма
    \pause

\item Рекурсивные типы
    \pause

\item Доказательства программ
    \pause

\item Продвинутый ML
    \pause

\item Другие стили функционального программирования
    \pause

\item Примеры на ML (1)
    \pause

\item Примеры на ML (2)
    \pause

\end{enumerate}

}


\frame{
  \frametitle{$\lambda$-нотация}

$\lambda$-нотация~-- это способ определения функций, предложенный Алонзо
Чёрчем в 1930 году.  Мы пишем:

\alert{$$ \lamb{x} E[x] $$ }

чтобы определить `функцию от \alert{$x$}, которая выдаёт
\alert{$E[x]$}'.  Здесь \alert{$E[x]$}~-- это выражение, которое
содержит или не содержит \alert{$x$}.

Например, \alert{$\lamb{x} x$}~-- это функция тождественного отображения,
которая возвращает заданный аргумент, а \alert{$\lamb{x} x^2$}~-- это
функция возведения в квадрат.

Литера \alert{$\lambda$}~-- историческая случайность. Первоначально
Чёрч использовал обозначение \alert{$\hat{x}.\; E[x]$}, а серия ошибок
набора превратило его в нынешнюю форму. Иногда также пишут \alert{$x
  \mapsto E[x]$} и \alert{$[x]\; E[x]$}.

}


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }


% \frame{
%   \frametitle{}

%   \begin{itemize}
%   \end{itemize}
% }



\end{document}
