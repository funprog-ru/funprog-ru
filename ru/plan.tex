\chapter*{План лекций}

Этот раздел описывает как материал распределён по 12 лекциям курса, каждая из которых длиться немногим меньше часа.

%This chapter indicates roughly how the material is to be distributed over a
%course of twelve lectures, each of slightly less than one hour.

\begin{enumerate}

\item {\bf Введение и обзор} Функциональное и императивное
  программирование: различия, ``за'' и ``против''. Общая структура
  курса: как $\lambda$-исчисление превратилось в язык программирования
  общего назначения. $\lambda$-нотация: как разъясняет связывание
  переменных и как предоставляет средства общего анализа
  математической записи.  Каррирование.  Парадокс Рассела.

%\item {\bf Introduction and Overview} Functional and imperative programming:
%contrast, pros and cons. General structure of the course: how lambda calculus
%turns out to be a general programming language. Lambda notation: how it
%clarifies variable binding and provides a general analysis of mathematical
%notation. Currying. Russell's paradox.

\item {\bf $\lambda$-исчисление как формальная система} Свободные и
  связанные переменные.  Подстановка.  Правила преобразования.
  Эквивалентность $\lambda$-термов.  Экстенсиональность.  Редукция и
  её стратегии.  Теорема Чёрча-Россера: формулировка и следствия.
  Комбинаторы.

%\item {\bf Lambda calculus as a formal system} Free and bound variables.
%Substitution. Conversion rules. Lambda equality. Extensionality. Reduction and
%reduction strategies. The Church-Rosser theorem: statement and consequences.
%Combinators.

\item {\bf $\lambda$-исчисление как язык программирования} Основы
  вычислимости; полнота по Тьюрингу (без доказательства).
  Представление данных и основные операции: булевы значения, пары и
  кортежи, натуральные числа.  Декремент.  Написание рекурсивных
  функций: комбинаторы неподвижной точки. Let-выражения.
  $\lambda$-исчисление как декларативный язык.

%\item {\bf Lambda calculus as a programming language} Computability background;
%Turing completeness (no proof). Representing data and basic operations: truth
%values, pairs and tuples, natural numbers. The predecessor operation. Writing
%recursive functions: fixed point combinators. Let expressions. Lambda calculus
%as a declarative language.

\item {\bf Типы} Зачем нужны типы?  Ответы из программирования и логики.
  Простое типизированное $\lambda$-исчисление.  Типизация по Чёрчу и
  Карри.  Let-полиморфизм.  Наиболее общие типы и алгоритм Милнера.
  Жёсткая нормализация (без доказательства), и её негативное влияние
  на полноту по Тьюрингу.  Добавляем оператор рекурсии.

\item {\bf ML} ML как типизированное $\lambda$-исчисление с энергичным
  вычислением.  Подробности стратегии вычисления.  Условное выражение.
  Семейство языков ML.  Практика работы с ML.  Создание функций.
  Связывания и объявления.  Рекурсивные и полиморфные функции.
  Сравнение функций.

\item {\bf Более подробно о ML} Более подробно о работе с ML.
  Загрузка кода из файлов.  Комментарии.  Основные типы данных:
  процедурный, логические, числа и строки.  Встроенные операции.
  Конкретный синтаксис и инфиксные операции.  Дополнительные примеры.
  Рекурсивные типы и сопоставление с образцом.  Примеры: списки и
  рекурсивные функции для работы со списками.

\item {\bf Доказательство корректности программ} Проблема
  корректности.  Тестирование и верификация.  Область применимости
  верификации.  Функциональные программы как математические объекты.
  Примеры доказательства свойств программ: вычисление степени и~НОД,
  конкатенация и обращение списков.

\item {\bf Эффективный ML} Использование стандартных комбинаторов.
  Проход по списку и другие полезные примеры использования
  комбинаторов. Хвостовая рекурсия и аккумуляторы; почему хвостовая
  рекурсия более эффективна. Принудительное вычисление. Минимизация
  операций cons. Более эффективная реализация обращения данных.
  Использование `as'. Императивные возможности: исключения, ссылки,
  массивы и последовательность вычислений. Императивные возможности и
  типы; ограничение значения.

\item {\bf Примеры на ML I: символьное дифференцирование} Символьные
  вычисления.  Представление данных.  Приоритет операторов.
  Ассоциативные списки.  ???Prettyprinting выражений.  Устанавливаем
  принтер.  Дифференцирование.  Упрощение.  Проблема `правильного'
  упрощения.

\item {\bf Примеры на ML II: синтаксический анализ} Понятие грамматики,
  задача синтаксического анализа. Устранение неоднозначностей.
  Метод рекурсивного спуска. Реализация синтаксического анализа на языке~ML.
  Комбинаторы синтаксического анализа, примеры. Лексический анализ.
  Анализатор термов. Автоматический учёт приоритетов операций. Устранение
  возвратов. Сравнение с другими методами.

\item {\bf Примеры на ML III: арифметика вещественных чисел}
  Вещественные числа и конечные представления.  Вещественные числа как
  программы или функции.  Выбор представления вещественных чисел.  
  Целые числа произвольной разрядности.  Преобразование целочисленных
  значений в вещественные. Операции смены знака и вычисления абсолютной величины.
  Сложение: важность деления с округлением.  Умножение и деление на целое
  число.  Умножение: общий случай.  Обратные числа и деление.
  Отношения порядка и равенства.  Тестирование.  Устранение избыточных
  вычислений при помощи функций с памятью.

\item {\bf Примеры на ML IV: Prolog и доказательство теорем} Выражения
  Prolog.  Лексический анализ с учётом регистра.  Разбор и печать,
  включая списочный синтаксис.  Унификация.  Поиск с возвратом.
  Примеры выражений Prolog.  Доказательство теорем в стиле Prolog.
  Работа с формулами; ????negation normal form.  Базовое средство
  доказательства (?? prover); использование продолжений.  Примеры:
  Проблемы Pelletier и ???whodunit.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:

