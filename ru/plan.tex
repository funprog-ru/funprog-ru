\chapter*{План лекций}

Этот раздел описывает как материал распределён по 12 лекциям курса, каждая из которых длиться немногим меньше часа.

%This chapter indicates roughly how the material is to be distributed over a
%course of twelve lectures, each of slightly less than one hour.

\begin{enumerate}

\item {\bf Введение и обзор} Функциональное и императивное
  программирование: различия, ``за'' и ``против''. Общая структура
  курса: как $\lambda$-исчисление превратилось в язык программирования
  общего назначения. $\lambda$-нотация: как разъясняет связывание
  переменных и как предоставляет средства общего анализа
  математической записи.  Каррирование.  Парадокс Рассела.

%\item {\bf Introduction and Overview} Functional and imperative programming:
%contrast, pros and cons. General structure of the course: how lambda calculus
%turns out to be a general programming language. Lambda notation: how it
%clarifies variable binding and provides a general analysis of mathematical
%notation. Currying. Russell's paradox.

\item {\bf $\lambda$-исчисление как формальная система} Свободные и
  связанные переменные.  Подстановка.  Правила преобразования.
  Эквивалентность $\lambda$-термов.  Экстенсиональность.  Редукция и
  её стратегии.  Теорема Чёрча-Россера: формулировка и следствия.
  Комбинаторы.

%\item {\bf Lambda calculus as a formal system} Free and bound variables.
%Substitution. Conversion rules. Lambda equality. Extensionality. Reduction and
%reduction strategies. The Church-Rosser theorem: statement and consequences.
%Combinators.

\item {\bf $\lambda$-исчисление как язык программирования} Основы
  вычислимости; полнота по Тьюрингу (без доказательства).
  Представление данных и основные операции: булевы значения, пары и
  кортежи, натуральные числа.  Декремент.  Написание рекурсивных
  функций: комбинаторы неподвижной точки. Let-выражения.
  $\lambda$-исчисление как декларативный язык.

%\item {\bf Lambda calculus as a programming language} Computability background;
%Turing completeness (no proof). Representing data and basic operations: truth
%values, pairs and tuples, natural numbers. The predecessor operation. Writing
%recursive functions: fixed point combinators. Let expressions. Lambda calculus
%as a declarative language.

\item {\bf Типы} Зачем нужны типы?  Ответы из программирования и логики.
  Простое типизированное $\lambda$-исчисление.  Типизация по Чёрчу и
  Карри.  Let-полиморфизм.  Наиболее общие типы и алгоритм Милнера.
  Жёсткая нормализация (без доказательства), и её негативное влияние
  на полноту по Тьюрингу.  Добавляем оператор рекурсии.

\item {\bf ML} ML как типизированное $\lambda$-исчисление с энергичным
  вычислением.  Подробности стратегии вычисления.  Условное выражение.
  Семейство языков ML.  Практика работы с ML.  Создание функций.
  Связывания и объявления.  Рекурсивные и полиморфные функции.
  Сравнение функций.

\item {\bf Более подробно о ML} Более подробно о работе с ML.
  Загрузка кода из файлов.  Комментарии.  Базовые типы данных:
  процедурный, логические, числа и строки.  Встроенные операции.
  Конкретный синтаксис и инфиксные операции.  Дополнительные примеры.
  Рекурсивные типы и сопоставление с образцом.  Примеры: списки и
  рекурсивные функции для работы со списками.

\item {\bf Доказательство корректности программы} Проблема
  корректности.  Тестирование и верификация.  Пределы
  проверки.  Функциональные программы как математические объекты.
  Примеры доказательства программ: exponential, GCD, append и reverse.

\item {\bf Эффективный ML} Использование стандартных комбинаторов.
  Проход по списку и другие полезные примеры
  использования комбинаторов.  Хвостовая рекурсия и аккумуляторы;
  почему хвостовая рекурсия более эффективна.  Принудительное
  вычисление.  Минимизация операций cons.  Более эффективная
  реализация обращения данных. Использование `as'.  Императивные
  возможности: исключения, ссылки, массивы и последовательности.
  Императивные возможности и типы; ограничение значения.

\item {\bf Примеры на ML I: символьное дифференцирование} Символьные
  вычисления.  Представление данных.  Приоритет операторов.
  Ассоциативные списки.  ???Prettyprinting выражений.  Устанавливаем
  принтер.  Дифференцирование.  Упрощение.  Проблема `правильного'
  упрощения.

\item {\bf Примеры на ML II: рекурсивный нисходящий разбор} Грамматики
  и проблема разбора.  Избегаем неоднозначности. Рекурсивный
  нисходящий разбор.  Парсеры в ML.  Комбинаторы для парсеров;
  примеры.  Лексический анализ с использованием тех же приёмов.
  Парсер для термов выражений.  Автоматический разбор
  приоритетов (???precedence).  Избегаем возврата (???backtracking).
  Сравнение с другими приёмами.

\item {\bf Примеры на ML III: арифметика вещественных чисел}
  Вещественные числа и конечные представления.  Вещественные числа как
  программы или функции.  Наше собственное представление вещественных
  чисел.  Целые числа с произвольной точностью.  Комбинирование целых
  чисел с вещественными.  Отрицательные и абсолютные значения.
  Дополнение; важность деления с округлением.  Умножение и деление
  целых чисел.  Общий вариант умножения.  Инверсия и деление.
  Упорядочение и равенство.  Тестирование.  Избегаем
  повторной оценки с помощью функций с памятью.

\item {\bf Примеры на ML IV: Prolog и доказательство теорем} Выражения
  Prolog.  Лексический анализ с учётом регистра.  Разбор и печать,
  включая списочный синтаксис.  Унификация.  Поиск с возвратом.
  Примеры выражений Prolog.  Доказательство теорем в стиле Prolog.
  Работа с формулами; ????negation normal form.  Базовое средство
  доказательства (?? prover); использование продолжений.  Примеры:
  Проблемы Pelletier и ???whodunit.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:

