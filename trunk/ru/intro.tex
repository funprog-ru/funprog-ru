\chapter{Введение}

Программы написанные на традиционных языках программирования, таких
как FORTRAN, Algol, C и Modula-3, в своей работе опираются на
изменение значений набора переменных, называемых {\em
  состоянием}. Если мы пренебрежем операциями ввода-вывода, и
вероятностью того, что программа будет работать постоянно (например,
управляющая система для производства), то мы можем прийти к следующей
абстракции.  До выполнения, состояние имеет некоторое начальное значение
$\sigma$, представляющее собой входное значение для программы, а когда
программа завершается, то состояние имеет новое значение $\sigma'$,
представляющее результат(ы).  Кроме того, в ходе выполнения, каждая
команда изменяет состояние, которое следовательно проходит через
конечное число значений:

$$ \sigma = \sigma_0 \to \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n =
\sigma' $$

Например, в программе сортировки, состояние первоначально включает в
себя массив значений, а после того, как программа завершается,
состояние модифицируется таким образом, что эти значения будут
отсортированы, в то время как промежуточные состояния представляют
собой ход достижения данной цели.

Состояние обычно изменяется с помощью команд {\em присваивания}, часто
записываемых в виде {\tt v = E} или {\tt v := E}, где {\tt v}~--
переменная, а {\tt E}~-- некоторое выражение.  Эти команды могут
выполняться последовательно, путем их последовательной записи в
программе, зачастую разделяя их с помощью точки с запятой.  С помощью
выражений, таких как {\tt if} и {\tt while}, можно выполнять команды в
зависимости от условия, или циклически, зачастую полагаясь на другие
свойства текущего состояния.  В результате программа превращается в
набор инструкций по изменению состояния, и поэтому данный стиль
программирования часто называется {\em императивным} или {\em
  процедурным}.  Соответственно, традиционные языки программирования,
поддерживающие такой стиль, также известны как императивные или
процедурные языки.

Функциональное программирование представляет собой радикальное отличие
от этой модели.  По существу, функциональная программа~-- это просто
выражение, а выполнение~-- вычисление
выражения.\footnote{Функциональное программирование часто называют 
`(аппликативным программированием)', поскольку основной механизм~-- это
{\em аппликация (применение)} функции к аргументам.}  В общих чертах
мы можем увидеть как это возможно, используя следующие рассуждения.
Предположив, что императивная программа (вся целиком) детерминирована,
т.е. вывод полностью определяется вводом, мы можем сказать, что
финальное состояние, или тот фрагмент, который нас интересует,
являются функцией начального состояния, например $\sigma' =
f(\sigma)$.\footnote{Сравните замечание Наура \cite{raphael-spl},
  что мы можем записать любую программу в виде одного выражения
  $Output = Program(Input)$.}  В функциональном программировании эта
точка зрения имеет особое значение: программа~-- это выражение, которое
соответствует математической функции $f$.  Функциональные языки
программирования позволяют создавать такие выражения, предоставляя
мощные функциональные конструкции.

Функциональное программирование может противопоставляться
императивному как в негативном так и в позитивном виде.  К негативным
вещам можно отнести то, что функциональные программы не используют
переменные~-- т.е., {\em не имеют} состояния.  Соответственно, они не
могут использовать присваивание, поскольку не к чему присваивать.
Кроме того, идея последовательного выполнения команд, также
бессмыслена, поскольку первая команда не имеет никакого значения для
второй, поскольку нет никакого состояния, передаваемого между ними.  К
положительным вещам можно отнести то, что функциональные программы
могут использовать функции более изощрённым способом.  Функции могут
рассматриваться точно так же, как и более простые объекты, такие как
целые числа: они могут передаваться в другие функции как аргументы, и
возвращаться в качестве результатов, а также использоваться в
вычислениях.  Вместо последовательного и циклического выполнения,
функциональные языки программирования используют рекурсивные функции,
т.е. функции, определенные в терминах самих себя.  Большинство
традиционных языков программирования обеспечивают весьма скудные
возможности в этих областях. Язык C имеет некоторые ограниченные
возможности работы с функциями при помощи указателей, но не
позволяет создавать новые функции динамически. А язык FORTRAN вообще
не поддерживает рекурсию.

Для того, чтобы показать разницу между императивным и функциональным
программированием, используем функцию для вычисления факториала,
которая может быть записана в императивном стиле на языке C (без
использования необычных операторов присвоения языка C) в виде:

\begin{lstlisting}[language=C]
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{lstlisting}

\noindent в то время как, эта функция может быть записана на языке ML
(фукциональном языке программирования, который мы обсудим позже) в
виде рекурсивной функции:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

Можно отметить, что такое определение также может быть создано и для
языка C.  Однако, при более сложных использованиях функций,
функциональные языки относятся к отдельному классу.

\section{Достоинства функционального программирования}

На первый взгляд, язык без переменных или возможности
последовательного выполнения кажется совершенно непрактичным.  Это
впечатление не может быть разрушено с помощью нескольких слов,
написанных тут.  Но мы надеемся, что изучая материал, приведённый
далее, читатели получат представление о том, как можно сделать
множество интересных вещей, используя функциональный стиль
программирования.

Нет ничего таинственного в императивном стиле.  Многие свойства
императивных языков программирования развились в процессе
абстрагирования от типового компьютерного оборудования, от машинного
кода к ассемблерам, макроассемблерам, затем переход к  FORTRAN и
дальше. Нет причин предполагать, что такие языки представляют собой
наиболее удобный способ для взаимодействия человека и машины.  Кроме
того, архитектура оборудования тоже не содержит никаких тайн, и
компьютеры должны выполнять наши приказы, а не наоборот.  Полагаю, что
правильный подход не в том, чтобы начать с оборудования и продвигаться
вверх, а наоборот~-- начать работу с языка программирования, как
средства для описания алгоритмов, и затем двигаться {\em вниз} к оборудованию
\cite{dijkstra-discipline}.  В действительности, данная тенденция
может быть обнаружена и в традиционных языках программирования.  Даже
FORTRAN  позволяет записывать арифметические выражения обычным
способом.  Программист не обеспокоен задачей линеаризации вычисления
подвыражений и нахождения места для промежуточных результатов.

Это ведет к тому, что идея разработки языков программирования, сильно
отличающихся от традиционных, императивных языков, является вполне
законной.  Однако, для того, чтобы показать, что мы не просто
предлагаем изменения ради изменений, мы должны сказать несколько слов
о том, почему мы можем предпочитать функциональные языки
программирования императивным.

Возможно, главной причиной будет то, что программы на функциональных
языках более точно соответствуют математическим объектам, и их более
легко доказывать. Для того, чтобы показать что программа означает, мы
можем связать абстрактный математический смысл с программой или
командой~-- это цель {\em денотационной семантики} (семантика =
значение????смысл).  В императивных языках это должно делаться
непрямым способом, из-за неявной зависимости от значений состояния.  В
простых императивных языках, кто-то может связать команду с функцией
$\Sigma \to \Sigma$, где $\Sigma$~-- набор возможных значений
состояния.  Таким образом, команда получает некоторое состояние и
создает другое состояние.  Это может не закончиться (например, {\tt
  while true do x := x}), так что эта функция в общем является
частичной.  Иногда предпочитают использовать альтернативные семантики,
например, в терминах {\em преобразователей предикатов}
\cite{dijkstra-discipline}.  Но, если мы добавим возможности, которые
могут исказить последовательность выполнения более сложным способом,
например, {\tt goto}, или конструкиции {\tt break} и {\tt continue}
языка C, то даже эти объяснения не будут больше работать, поскольку
одна команда может привести к пропуску выполнения следующих команд.
Вместо этого, можно использовать более сложные семантики, основанные
на {\em продолжениях (continuations)}.

По контрасту с этим, функциональные программы, по
словам\citeN{henson-book}, `носят свою семантику с
собой'.\footnote{Дополнительно: денотационная семантика может быть
  рассмотрена как попытка превратить императивные языки в
  функциональные, путем явного объявления состояний.}  Мы можем
показать это на примере ML.  Базовые типы напрямую могут
рассматриваться как математические объекты.  Используя стандартную
запись $\sem{X}$ для `семантики $X$', мы можем сказать, например, что
$\sem{\mbox{int}} = \num$.  Так что функция ML {\tt fact},
определенная выражением:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

\noindent имеет один аргумент типа {\tt int}, и возвращает значение
типа {\tt int}, так что она просто является связанной с абстрактной
частичной функцией $\num \to \num$:

$$ \sem{\mbox{fact}}(n) = \left\{ \begin{array}{ll}
    n! & \mbox{if $n \geq 0$} \\
    \bot & \mbox{otherwise}
  \end{array} \right. $$

(Здесь $\bot$ обозначает неопределенность, поскольку для отрицательных
аргументов, программа не сможет завершиться).  Однако этот способ
простой интерпретации не работает для не-функциональных программ,
поскольку, так называемы `функции' могут быть не функциями в
математическом смысле.  Например, стандартная библиотека языка  C
имеет функциб {\tt rand()},  которая возвращает разные,
псевдо-случайные значения при последовательных вызовах.  Это может
быть сделано с помощью локальных статических переменных, используемых
для хранения предыдущих результатов, например, так:

\begin{lstlisting}[language=C]
  int rand(void)
  { static int n = 0;
    return n = 2147001325 * n + 715136305;
  }
\end{lstlisting}

Thus, one can see the abandonment of variables and assignments as the logical
next step after the abandonment of {\tt goto}, since each step makes the
semantics simpler. A simpler semantics makes reasoning about programs more
straightforward. This opens up more possibilities for correctness proofs, and
for provably correct transformations into more efficient programs.

Another potential advantage of functional languages is the following. Since the
evaluation of expressions has no side-effect on any state, separate
subexpressions can be evaluated in any order without affecting each other. This
means that functional programs may lend themselves well to parallel
implementation, i.e. the computer can automatically farm out different
subexpressions to different processors. By contrast, imperative programs often
impose a fairly rigid order of execution, and even the limited interleaving of
instructions in modern pipelined processors turns out to be complicated and
full of technical problems.

Actually, ML is not a purely functional programming language; it does have
variables and assignments if required. Most of the time, we will work inside
the purely functional subset. But even if we do use assignments, and lose some
of the preceding benefits, there are advantages too in the more flexible use of
functions that languages like ML allow. Programs can often be expressed in a
very concise and elegant style using higher-order functions (functions that
operate on other functions).\footnote{Elegance is subjective and conciseness is
not an end in itself. Functional languages, and other languages like APL, often
create a temptation to produce very short tricky code which is elegant to
cognoscenti but obscure to outsiders.} Code can be made more general, since it
can be parametrized even over other functions. For example, a program to add up
a list of numbers and a program to multiply a list of numbers can be seen as
instances of the same program, parametrized by the pairwise arithmetic
operation and the corresponding identity. In one case it is given $+$ and $0$
and in the other case, $*$ and $1$.\footnote{This parallels the notion of
abstraction in pure mathematics, e.g. that the additive and multiplicative
structures over numbers are instances of the abstract notion of a monoid. This
similarly avoids duplication and increases elegance.} Finally, functions can
also be used to represent {\em infinite} data in a convenient way --- for
example we will show later how to use functions to perform exact calculation
with real numbers, as distinct from floating point approximations.

At the same time, functional programs are not without their problems. Since
they correspond less directly the the eventual execution in hardware, it can be
difficult to reason about their exact usage of resources such as time and
space. Input-output is also difficult to incorporate neatly into a functional
model, though there are ingenious techniques based on infinite sequences.

It is up to readers to decide, after reading this book, on the merits of the
functional style. We do not wish to enforce any ideologies, merely to point out
that there {\em are} different ways of looking at programming, and that in the
right situations, functional programming may have considerable merits. Most of
our examples are chosen from areas that might loosely be described as `symbolic
computation', for we believe that functional programs work well in such
applications. However, as always one should select the most appropriate tool
for the job. It may be that imperative programming, object-oriented programming
or logic programming are more suited to certain tasks. Horses for courses.

\section{Outline}

For those used to imperative programming, the transition to functional
programming is inevitably difficult, whatever approach is taken. While some
will be impatient to get quickly to real programming, we have chosen to start
with lambda calculus, and show how it can be seen as the theoretical
underpinning for functional languages. This has the merit of corresponding
quite well to the actual historical line of development.

So first we introduce lambda calculus, and show how what was originally
intended as a formal logical system for mathematics turned out to be a
completely general programming language. We then discuss why we might want to
add types to lambda calculus, and show how it can be done. This leads us into
ML, which is essentially an extended and optimized implementation of typed
lambda calculus with a certain evaluation strategy. We cover the practicalities
of basic functional programming in ML, and discuss polymorphism and most
general types. We then move on to more advanced topics including exceptions and
ML's imperative features. We conclude with some substantial examples, which we
hope provide evidence for the power of ML.

\section*{Дополнительная литература}

Numerous textbooks on `functional programming' include a general introduction
to the field and a contrast with imperative programming --- browse through a
few and find one that you like. For example, \citeN{henson-book} contains a
good introductory discussion, and features a similar mixture of theory and
practice to this text. A detailed and polemical advocacy of the functional
style is given by \citeN{backus-liberated}, the main inventor of FORTRAN.
\citeN{gordon-io} discusses the problems of incorporating input-output into
functional languages, and some solutions. Readers interested in denotational
semantics, for imperative and functional languages, may look at
\citeN{winskel-sem}.

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
