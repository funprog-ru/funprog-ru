\chapter{Введение}

Программы написанные на традиционных языках программирования, таких
как FORTRAN, Algol, C и Modula-3, в своей работе опираются на
изменение значений набора переменных, называемых {\em
  состоянием}. Если мы пренебрежём операциями ввода-вывода, и
вероятностью того, что программа будет работать постоянно (например,
управляющая система для производства), то мы можем прийти к следующей
абстракции.  До выполнения, состояние имеет некоторое начальное значение
$\sigma$, представляющее собой входное значение для программы, а когда
программа завершается, то состояние имеет новое значение $\sigma'$,
представляющее результат(ы).  Кроме того, в ходе выполнения, каждая
команда изменяет состояние, которое следовательно проходит через
конечное число значений:

$$ \sigma = \sigma_0 \to \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n =
\sigma' $$

Например, в программе сортировки, состояние первоначально включает в
себя массив значений, а после того, как программа завершается,
состояние модифицируется таким образом, что эти значения будут
отсортированы, в то время как промежуточные состояния представляют
собой ход достижения данной цели.

Состояние обычно изменяется с помощью команд {\em присваивания}, часто
записываемых в виде {\tt v = E} или {\tt v := E}, где {\tt v}~--
переменная, а {\tt E}~-- некоторое выражение.  Эти команды могут
выполняться последовательно, путём их последовательной записи в
программе, зачастую разделяя их с помощью точки с запятой.  С помощью
выражений, таких как {\tt if} и {\tt while}, можно выполнять команды в
зависимости от условия, или циклически, зачастую полагаясь на другие
свойства текущего состояния.  В результате программа превращается в
набор инструкций по изменению состояния, и поэтому данный стиль
программирования часто называется {\em императивным} или {\em
  процедурным}.  Соответственно, традиционные языки программирования,
поддерживающие такой стиль, также известны как императивные или
процедурные языки.

Функциональное программирование представляет собой радикальное отличие
от этой модели.  По существу, функциональная программа~-- это просто
выражение, а выполнение~-- вычисление
выражения.\footnote{Функциональное программирование часто называют 
<<аппликативным программированием>>, поскольку основной механизм~-- это
{\em аппликация (применение)} функции к аргументам.}  В общих чертах
мы можем увидеть как это возможно, используя следующие рассуждения.
Предположив, что императивная программа (вся целиком) детерминирована,
т.е. вывод полностью определяется вводом; мы можем сказать, что
финальное состояние, или тот фрагмент, который нас интересует,
являются функцией начального состояния, например $\sigma' =
f(\sigma)$.\footnote{Сравните замечание Наура \cite{raphael-spl},
  что мы можем записать любую программу в виде одного выражения
  $Output = Program(Input)$.}  В функциональном программировании эта
точка зрения имеет особое значение: программа~-- это выражение, которое
соответствует математической функции $f$.  Функциональные языки
программирования позволяют создавать такие выражения, предоставляя
мощные функциональные конструкции.

Функциональное программирование может противопоставляться
императивному как в негативном так и в позитивном виде.  К негативным
вещам можно отнести то, что функциональные программы не используют
переменные~-- т.е., {\em не имеют} состояния.  Соответственно, они не
могут использовать присваивание, поскольку не к чему присваивать.
Кроме того, идея последовательного выполнения команд, также
бессмысленна, поскольку первая команда не имеет никакого значения для
второй, поскольку нет никакого состояния, передаваемого между ними.  К
положительным вещам можно отнести то, что функциональные программы
могут использовать функции более изощрённым способом.  Функции могут
рассматриваться точно так же, как и более простые объекты, такие как
целые числа: они могут передаваться в другие функции как аргументы, и
возвращаться в качестве результатов, а также использоваться в
вычислениях.  Вместо последовательного и циклического выполнения,
функциональные языки программирования используют рекурсивные функции,
т.е. функции, определённые в терминах самих себя.  Большинство
традиционных языков программирования обеспечивают весьма скудные
возможности в этих областях. Язык C имеет некоторые ограниченные
возможности работы с функциями при помощи указателей, но не
позволяет создавать новые функции динамически. А язык FORTRAN вообще
не поддерживает рекурсию.

Для того, чтобы показать разницу между императивным и функциональным
программированием, используем функцию для вычисления факториала,
которая может быть записана в императивном стиле на языке C (без
использования необычных операторов присвоения языка C) в виде:

\begin{lstlisting}[language=C]
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{lstlisting}

\noindent в то время как, эта функция может быть записана на языке ML
(функциональном языке программирования, который мы обсудим позже) в
виде рекурсивной функции:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

Можно отметить, что такое определение также может быть создано и для
языка C.  Однако, при более сложных использованиях функций,
функциональные языки относятся к отдельному классу.

\section{Достоинства функционального программирования}

На первый взгляд, язык без переменных или возможности
последовательного выполнения кажется совершенно непрактичным.  Это
впечатление не может быть разрушено с помощью нескольких слов,
написанных тут.  Но мы надеемся, что изучая материал, приведённый
далее, читатели получат представление о том, как можно сделать
множество интересных вещей, используя функциональный стиль
программирования.

Нет ничего таинственного в императивном стиле.  Многие свойства
императивных языков программирования развились в процессе
абстрагирования от типового компьютерного оборудования, от машинного
кода к ассемблерам, макроассемблерам, затем переход к  FORTRAN и
дальше. Нет причин предполагать, что такие языки представляют собой
наиболее удобный способ для взаимодействия человека и машины.  Кроме
того, архитектура оборудования тоже не содержит никаких тайн, и
компьютеры должны выполнять наши приказы, а не наоборот.  Полагаю, что
правильный подход не в том, чтобы начать с оборудования и продвигаться
вверх, а наоборот~-- начать работу с языка программирования, как
средства для описания алгоритмов, и затем двигаться {\em вниз} к оборудованию
\cite{dijkstra-discipline}.  В действительности, данная тенденция
может быть обнаружена и в традиционных языках программирования.  Даже
FORTRAN  позволяет записывать арифметические выражения обычным
способом.  Программист не обеспокоен задачей линеаризации вычисления
подвыражений и нахождения места для промежуточных результатов.

Это ведёт к тому, что идея разработки языков программирования, сильно
отличающихся от традиционных, императивных языков, является вполне
законной.  Однако, для того, чтобы показать, что мы не просто
предлагаем изменения ради изменений, мы должны сказать несколько слов
о том, почему мы могли бы предпочесть функциональные языки
программирования императивным.

Возможно, главной причиной будет то, что программы на функциональных
языках более точно соответствуют математическим объектам, и их легче
доказывать. Для того, чтобы показать что программа означает, мы можем
связать абстрактный математический смысл с программой или командой~--
это цель {\em денотационной семантики} (семантика = значение, смысл).
В императивных языках это должно делаться скорее побочным способом,
из-за неявной зависимости от значений состояния.  В простых
императивных языках, можно связать команду с функцией $\Sigma \to
\Sigma$, где $\Sigma$~-- множество допустимых значений состояния.
Таким образом, команда получает некоторое состояние и порождает другое
состояние.  Это может не закончиться (например, {\tt while true do x
  := x}), так что эта функция в общем является частичной.  Иногда, как
решение, предпочитают использовать альтернативные семантики, например,
в терминах {\em предикатных преобразователей}
\cite{dijkstra-discipline}.  Но, если мы добавим возможности, которые
могут сложным образом исказить последовательность выполнения,
например, {\tt goto}, или конструкции {\tt break} и {\tt continue}
языка C, то даже такие решения перестанут работать, поскольку одна
команда может привести к пропуску выполнения следующих команд.
Взамен, обычно используют более сложные семантики, основанные на {\em
  продолжениях (continuations)}.

В противоположность этому, функциональные программы, по
словам\citeN{henson-book}, <<носят свою семантику с
собой>>.\footnote{Дополнительно: денотационную семантику можно
  рассматривать как попытку превратить императивные языки в
  функциональные, путём явного объявления состояний.}  Мы можем
показать это на примере ML.  Основные типы напрямую могут
рассматриваться как математические объекты.  Используя стандартную
запись $\sem{X}$ для <<семантики $X$>>, мы можем сказать, например,
что $\sem{\mbox{int}} = \num$.  Так что функция ML {\tt fact},
определённая выражением:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

\noindent имеет один аргумент типа {\tt int}, и возвращает значение
типа {\tt int}, так что она просто является связанной с абстрактной
частичной функцией $\num \to \num$:

$$ \sem{\mbox{fact}}(n) = \left\{ \begin{array}{ll}
    n! & \mbox{if $n \geq 0$} \\
    \bot & \mbox{otherwise}
  \end{array} \right. $$

(Здесь $\bot$ обозначает неопределённость, поскольку для отрицательных
аргументов, программа не сможет завершиться).  Однако этот способ
простой интерпретации не работает для не-функциональных программ,
поскольку, так называемые <<функции>> могут быть не функциями в
математическом смысле.  Например, в стандартной библиотеке языка C
есть функция {\tt rand()}, которая возвращает различные,
псевдо-случайные значения при последовательных вызовах.  Это может
быть сделано с помощью локальных статических переменных, используемых
для хранения предыдущих результатов, например, так:

\begin{lstlisting}[language=C]
  int rand(void)
  { static int n = 0;
    return n = 2147001325 * n + 715136305;
  }
\end{lstlisting}

Таким образом, мы можем рассматривать отказ от переменных и
использования присвоений, как логический шаг после отказа от
\texttt{goto}, поскольку каждый шаг делает семантику проще.  Более
простая семантика делает доказательство программ более ясным.  Это
даёт нам больше возможностей для доказательства корректности программ,
и для доказуемо корректных преобразований в более эффективные
программы.

% Thus, one can see the abandonment of variables and assignments as the logical
% next step after the abandonment of {\tt goto}, since each step makes the
% semantics simpler. A simpler semantics makes reasoning about programs more
% straightforward. This opens up more possibilities for correctness proofs, and
% for provably correct transformations into more efficient programs.

У функциональных языков есть и другое потенциальное преимущество.
Поскольку вычисление выражений не имеет побочных эффектов для любых
состояний, то отдельные подвыражения могут вычисляться в произвольном
порядке, не влияя друг на друга.  Это означает, что функциональные
программы могут давать возможность параллельной обработки, т.е.,
компьютер может автоматически вычислять различные подвыражения на
разных процессорах.  В отличии от этого, императивные программы часто
задают жёсткий порядок вычислений, и даже ограниченное перемешивание
инструкций в современных процессорах с конвейерной обработкой, ведёт к
сложностям и возникновению технических проблем.

На самом деле, ML не является чисто функциональным языком
программирования; в нём есть переменные и присваивания, если
потребуется.  Большую часть времени, мы будем делать нашу работу
используя чисто функциональное подмножество языка.  Но даже если мы
будем использовать присваивания, и потеряем некоторые из ранее
перечисленных достоинств, то всё равно есть преимущества в более
гибком использовании функций, которые позволяют сделать языки,
подобные ML.  Программы часто могут быть выражены очень кратко и
элегантно путём использования функций высшего порядка (функции,
которые оперируют над другими функциями).\footnote{Элегантность
  субъективна, а краткость не ограничивается собой.  Функциональные
  языки, а также другие языки, такие как APL, часто создают соблазн
  создания очень короткого, хитроумного кода, который элегантен для
  знатоков, но непонятен для остальных.}  Код может быть более общим,
поскольку он может быть параметризован другими функциями.  Например,
программа, которая складывает список чисел и программа, которая
умножает список чисел, могут рассматриваться как объекты одной и той
же программы, которая параметризуется арифметической операцией над
парой чисел и единичным элементом.  В первом случае это будут $+$ и
$0$, а во втором~-- $*$ и $1$.\footnote{Это походит на понятие
  абстракции в чистой математике, например, что аддитивные и
  мультипликативные структуры над числами являются объектами
  абстрактного понятия <<моноид>>.  Это подобие помогает избегать
  дублирования и увеличивает элегантность.}  В заключение, функции
могут использоваться для представления {\em бесконечных} наборов
данных удобным способом, например, мы позже покажем как использовать
функции для выполнения вычислений с вещественными числами, в отличии
от использования приближений в виде чисел с плавающей запятой.

В то же время, функциональные программы не лишены собственных проблем.
Поскольку, они достаточно посредственно соответствуют конечному
выполнению на оборудовании, то может быть тяжело вычислить точное
использование ресурсов, таких как время и память.  Ввод-вывод также
тяжело ввести в функциональную модель, хотя существуют остроумные
способы, основанные на бесконечных последовательностях.

Читатели данной книги должны сами сделать заключение о достоинствах
функционального стиля.  Мы не хотим навязывать никакую идеологию,
только хотим показать, что {\em существуют} разные подходы к
программированию, и что в соответствующих ситуациях, функциональное
программирование может иметь значительные достоинства.  Большинство
наших примеров выбрано из областей, которые могут быть определены как
<<символьные вычисления>>.  Мы верим, что функциональные программы
успешно работают в таких приложениях.  Однако, как всегда, человек
должен использовать наиболее подходящие для работы инструменты.
Возможно, что императивное, объектно-ориентированное или логическое
программирование лучше подходят для определённых задач.

\section{Конспект}

Для тех, кто использовал императивное программирование, переход к
функциональному будет неизбежно тяжёл, независимо от используемого
подхода.  Хотя есть люди, которые нетерпеливо ожидают перехода к
непосредственному программированию, мы выбрали другой подход~-- мы
начнём с $\lambda$-исчисления, и покажем как оно может быть
использовано как теоретическая основа для функциональных языков.  У
такого подхода есть достоинство, что он хорошо соответствует
актуальной истории разработки функциональных языков.

Так что сначала мы введём $\lambda$-исчисление, и покажем как то, что
в оригинале предназначалось как формальная логическая система для
математики превратилось в язык программирования общего назначения.
Затем мы обсудим, зачем мы хотим добавить типы в $\lambda$-исчисление,
и покажем как это можно сделать.  Это приведёт нас к ML, который по
существу является оптимизированной реализацией типизированного
$\lambda$-исчисления с определённой стратегией вычисления выражений.
Мы рассмотрим практические основы функционального программирования на
ML, и обсудим полиморфизм и основные типы данных.  Затем мы перейдём к
более сложным темам, таким как исключения и императивные возможности
ML.  В заключение, мы приведём несколько реальных примеров, которые,
как мы надеемся, подтвердят мощь ML.

\section*{Дополнительная литература}

Существует бесчисленное количество книг о <<функциональном
программировании>>, включая общее введение и описание отличий от
императивного программирования~-- просмотрите несколько и выберите ту,
которая вам нравится.  Например, \citeN{henson-book} содержит хорошее
вводное обсуждение, и содержит хорошую смесь теории и практики.
Детальная и спорная пропаганда функционального стиля программирования
приведена в \citeN{backus-liberated}, главного вдохновителя FORTRAN.
\citeN{gordon-io} обсуждает проблемы введения ввода-вывода в
функциональные языки, а также приводит некоторые решения.  Читатели,
заинтересовавшиеся денотационной семантикой для императивных и
функциональных языков, могут прочитать \citeN{winskel-sem}.

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
