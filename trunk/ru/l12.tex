\documentclass{fp-slides}

\begin{document}

\defverbatim[colored]\PrologTerm{
  \begin{lstlisting}[frame=single]
  type term = Var of string
            | Fn of string * (term list);;
\end{lstlisting}}

\defverbatim[colored]\Token{
  \begin{lstlisting}[frame=single]
  type token = Variable of string
             | Constant of string
             | Punctuation of string;;
\end{lstlisting}}

\defverbatim[colored]\Lex{
  \begin{lstlisting}[frame=single]
let lex =
  let several p = many (some p) in
  let collect(h,t) = h^(itlist (prefix ^) t "") in
  let upper_alpha s = "A" <= s & s <= "Z" or s = "_"
  and lower_alpha s = "a" <= s & s <= "z" or
                      "0" <= s & s <= "9"
  and punct s = s = "(" or s = ")" or s = "[" or
                s = "]" or s = "," or s = "."
  and space s = s = " " or s = "\n" or s = "\t" in
  let alnum s = upper_alpha s or lower_alpha s in
  let symbolic s = not space s & not alnum s &
                   not punct s in
  let rawvariable = some upper_alpha ++ several alnum
        >> (Variable o collect)
  and rawconstant = (some lower_alpha ++ several alnum
     || some symbolic ++ several symbolic)
        >> (Constant o collect)
  and rawpunct = some punct >>  Punct in
  let token = (rawvariable || rawconstant || rawpunct)
              ++ several space >> fst in
  let tokens = (several space ++ many token) >> snd in
  let alltokens = (tokens ++ finished) >> fst in
  fst o alltokens o explode;;
\end{lstlisting}}

\defverbatim[colored]\Unify{
  \begin{lstlisting}[frame=single]
let rec unify tm1 tm2 insts =
  match tm1 with
    Var(x) ->
      (try let tm1' = assoc x insts in
           unify tm1' tm2 insts
       with Not_found ->
           augment (x,tm2) insts)
  | Fn(f1,args1) ->
      match tm2 with
        Var(y) ->
          (try let tm2' = assoc y insts in
               unify tm1 tm2' insts
           with Not_found ->
               augment (y,tm1) insts)
      | Fn(f2,args2) ->
          if f1 = f2
          then itlist2 unify args1 args2 insts
          else raise (error "functions do not match");;
\end{lstlisting}}

\defverbatim[colored]\OccursIn{
  \begin{lstlisting}[frame=single]
let rec occurs_in x =
  fun (Var y) -> x = y
    | (Fn(_,args)) -> exists (occurs_in x) args;;

let rec subst insts = fun
   (Var y) -> (try assoc y insts with Not_found -> tm)
 | (Fn(f,args)) -> Fn(f,map (subst insts) args);;

let raw_augment =
  let augment1 theta (x,s) =
    let s' = subst theta s in
    if occurs_in x s & not(s = Var(x))
    then raise (error "Occurs check")
    else (x,s') in
  fun p insts -> p::(map (augment1 [p]) insts);;

let augment (v,t) insts =
  let t' = subst insts t in match t' with
    Var(w) -> if w <= v then
                if w = v then insts
                else raw_augment (v,t') insts
              else raw_augment (w,Var(v)) insts
  | _ -> if occurs_in v t'
         then raise (error "Occurs check")
         else raw_augment (v,t') insts;;
\end{lstlisting}}

\defverbatim[colored]\BackTracking{
  \begin{lstlisting}[frame=single]
let rec first f =
  fun [] -> raise (error "No rules applicable")
    | (h::t) -> try f h with error _ -> first f t;;

let rec expand n rules insts goals =
  first (fun rule ->
    if goals = [] then insts else
    let conc,asms =
      rename_rule (string_of_int n) rule in
    let insts' = unify conc (hd goals) insts in
    let local,global = partition
      (fun (v,_) -> occurs_in v conc or
              exists (occurs_in v) asms) insts' in
    let goals' = (map (subst local) asms) @
                 (tl goals) in
    expand (n + 1) rules global goals') rules;;
\end{lstlisting}}

\defverbatim[colored]\OdO{
  \begin{lstlisting}[frame=single]
let rec rename s =
  fun (Var v) -> Var("~"^v^s)
    | (Fn(f,args)) -> Fn(f,map (rename s) args);;
let rename_rule s (conc,asms) =
  (rename s conc,map (rename s) asms);;
\end{lstlisting}}

\defverbatim[colored]\OdOO{
  \begin{lstlisting}[frame=single]
type outcome = No | Yes of (string * term) list;;

let prolog rules goal =
  try let insts = expand 0 rules [] [goal] in
      Yes(filter (fun (v,_) -> occurs_in v goal)
                 insts)
  with error _ -> No;;
\end{lstlisting}}

\defverbatim[colored]\PrologExamplesO{
  \begin{lstlisting}[frame=single]
#let rules = parse_rules
  "male(albert).
   male(edward).
   female(alice).
   female(victoria).
   parents(edward,victoria,albert).
   parents(alice,victoria,albert).
   sister_of(X,Y) :-
     female(X),
     parents(X,M,F),
     parents(Y,M,F).";;
rules : (term * term list) list =
 [`male(albert)`, []; `male(edward)`, [];
  `female(alice)`, []; `female(victoria)`, [];
  `parents(edward,victoria,albert)`, [];
  `parents(alice,victoria,albert)`, [];
  `sister_of(X,Y)`,
    [`female(X)`; `parents(X,M,F)`; `parents(Y,M,F)`]]
#prolog rules ("sister_of(alice,edward)");;
- : outcome = Yes []
#prolog rules (parse_term "sister_of(alice,X)");;
- : outcome = Yes ["X", `edward`]
#prolog rules (parse_term "sister_of(X,Y)");;
- : outcome = Yes ["Y", `edward`; "X", `alice`]
\end{lstlisting}}

\defverbatim[colored]\PrologExamplesOO{
  \begin{lstlisting}[frame=single]
#let r = parse_rules
  "append([],L,L).
   append([H|T],L,[H|A]) :- append(T,L,A).";;
r : (term * term list) list =
 [`append([],L,L)`, [];
  `append(H . T,L,H . A)`, [`append(T,L,A)`]]
#prolog r (parse_term "append([1,2],[3],[1,2,3])");;
- : outcome = Yes []
#prolog r (parse_term "append([1,2],[3,4],X)");;
- : outcome = Yes ["X", `1 . (2 . (3 . (4 . [])))`]
#prolog r (parse_term "append([3,4],X,X)");;
- : outcome = No
#prolog r (parse_term "append([1,2],X,Y)");;
- : outcome = Yes ["Y", `1 . (2 . X)`]
\end{lstlisting}}

\defverbatim[colored]\PrologExamplesOOO{
  \begin{lstlisting}[frame=single]
#prolog r (parse_term "append(X,[3,4],X)");;
\end{lstlisting}}

\defverbatim[colored]\ProcForm{
  \begin{lstlisting}[frame=single]
let rec proc tm =
  match tm with
    Fn("~",[t]) -> Fn("~",[proc t])
  | Fn("&",[t1; t2]) -> Fn("&",[proc t1; proc t2])
  | Fn("|",[t1; t2]) -> Fn("|",[proc t1; proc t2])
  | Fn("-->",[t1; t2]) ->
        proc (Fn("|",[Fn("~",[t1]); t2]))
  | Fn("<->",[t1; t2]) ->
        proc (Fn("&",[Fn("-->",[t1; t2]);
                      Fn("-->",[t2; t1])]))
  | Fn("forall",[x; t]) -> Fn("forall",[x; proc t])
  | Fn("exists",[x; t]) -> Fn("exists",[x; proc t])
  | t -> t;;
\end{lstlisting}}

\defverbatim[colored]\NnfCode{
  \begin{lstlisting}[frame=single]
let rec nnf_p tm =
  match tm with
    Fn("~",[t]) -> nnf_n t
  | Fn("&",[t1; t2]) -> Fn("&",[nnf_p t1; nnf_p t2])
  | Fn("|",[t1; t2]) -> Fn("|",[nnf_p t1; nnf_p t2])
  | Fn("forall",[x; t]) -> Fn("forall",[x; nnf_p t])
  | Fn("exists",[x; t]) -> Fn("exists",[x; nnf_p t])
  | t -> t

and nnf_n tm =
  match tm with
    Fn("~",[t]) -> nnf_p t
  | Fn("&",[t1; t2]) -> Fn("|",[nnf_n t1; nnf_n t2])
  | Fn("|",[t1; t2]) -> Fn("&",[nnf_n t1; nnf_n t2])
  | Fn("forall",[x; t]) -> Fn("exists",[x; nnf_n t])
  | Fn("exists",[x; t]) -> Fn("forall",[x; nnf_n t])
  | t -> Fn("~",[t]);;
\end{lstlisting}}

\defverbatim[colored]\Prover{
  \begin{lstlisting}[frame=single]
let rec prove fm unexp pl nl n cont i =
  if n < 0 then raise (error "No proof") else
  match fm with
    Fn("&",[p;q]) ->
        prove p (q::unexp) pl nl n cont i
  | Fn("|",[p;q]) ->
        prove p unexp pl nl n
        (prove q unexp pl nl n cont) i
  | Fn("forall",[Var x; p]) ->
        let v = mkvar() in
        prove (subst [x,Var v] p) (unexp@[fm])
              pl nl (n - 1) cont i
  | Fn("exists",[Var x; p]) ->
        let v = mkvar() in prove(subst [x,Fn(v,[])] p)
                           unexp pl nl (n - 1) cont i
  | Fn("~",[t]) ->
        (try first (fun t' -> let i' = unify t t' i in
                              cont i') pl
         with error _ -> prove (hd unexp) (tl unexp)
                               pl (t::nl) n cont i)
  | t ->
        (try first (fun t' -> let i' = unify t t' i in
                              cont i') nl
         with error _ -> prove (hd unexp) (tl unexp)
                               (t::pl) nl n cont i);;
\end{lstlisting}}

\defverbatim[colored]\ProverExampleO{
  \begin{lstlisting}[frame=single]
let prover =
  let rec prove_iter n t =
    try let insts = prove t [] [] [] n I [] in
        let globinsts = filter
          (fun (v,_) -> occurs_in v t) insts in
        n,globinsts
    with error _ -> prove_iter (n + 1) t in
  fun t -> prove_iter 0 (nnf_n(proc(parse_term t)));;
\end{lstlisting}}

\defverbatim[colored]\ProverExampleOO{
  \begin{lstlisting}[frame=single]
#let P1 = prover "p --> q <-> ~(q) --> ~(p)";;
P1 : int * (string * term) list = 0, []
#let P13 = prover "p | q & r <-> (p | q) & (p | r)";;
P13 : int * (string * term) list = 0, []
#let P16 = prover "(p --> q) | (q --> p)";;
P16 : int * (string * term) list = 0, []
#let P18 = prover "exists(Y,forall(X,p(Y)-->p(X)))";;
P18 : int * (string * term) list = 2, []
#let P19 = prover "exists(X,forall(Y,forall(Z,
                (p(Y)-->q(Z))-->p(X)-->q(X))))";;
P19 : int * (string * term) list = 6, []
\end{lstlisting}}

\defverbatim[colored]\ProverExampleOOO{
  \begin{lstlisting}[frame=single]
#let P55 = prover
  "lives(agatha) & lives(butler) & lives(charles) &
   (killed(agatha,agatha) | killed(butler,agatha) |
    killed(charles,agatha)) &
   (forall(X,forall(Y,
     killed(X,Y) --> hates(X,Y) & ~(richer(X,Y))))) &
   (forall(X,hates(agatha,X)
             --> ~(hates(charles,X)))) &
   (hates(agatha,agatha) & hates(agatha,charles)) &
   (forall(X,lives(X) & ~(richer(X,agatha))
             --> hates(butler,X))) &
   (forall(X,hates(agatha,X) --> hates(butler,X))) &
   (forall(X,~(hates(X,agatha)) | ~(hates(X,butler))
             | ~(hates(X,charles))))
   --> killed(agatha,agatha)";;
P55 : int * (string * term) list = 6, []
\end{lstlisting}}

\defverbatim[colored]\ProverExampleOOOO{
  \begin{lstlisting}[frame=single]
#let P55' = prover
  "......
   --> killed(X,agatha)";;
P55' : int * (string * term) list = 6, ["X", `agatha`]
\end{lstlisting}}


\section*{Ï≈À√…— 12. “…Õ≈“Ÿ Œ¡ ML IV: “œÃœ« … ‰œÀ¡⁄¡‘≈Ãÿ”‘◊œ Ù≈œ“≈Õ}

\frame{
  \frametitle{Ù≈ÕŸ}
  \begin{itemize}
   \item ˜Ÿ“¡÷≈Œ…— ◊ “œÃœ«≈: ¡Œ¡Ã…⁄ … –≈ﬁ¡‘ÿ
%  \item Prolog terms: parsing and printing
    \maybepause

  \item ıŒ…∆…À¡√…— … –œ…”À ” ◊œ⁄◊“¡‘œÕ ◊ –“œÃœ«≈
%  \item Unification and Prolog backtracking
    \maybepause

  \item “…Õ≈“Ÿ Œ¡ “œÃœ«≈
%  \item Prolog examples
    \maybepause

   \item “œ”‘œ≈ ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ
%  \item A simple theorem prover
    \maybepause

  \item “…Õ≈“Ÿ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ
%  \item Theorem proving examples

  \end{itemize}
}



\frame{
  \frametitle{Ô¬⁄œ“}
%  \frametitle{Overview}

  “œÃœ« ‹‘œ <<ƒ≈ÀÃ¡“¡‘…◊ŒŸ >> —⁄ŸÀ –“œ«“¡ÕÕ…“œ◊¡Œ…— –œ–’Ã—“ŒŸ 
  ◊ œ¬Ã¡”‘… …””Ã≈ƒœ◊¡Œ…  –œ È”À’””‘◊≈ŒŒœÕ’ ÈŒ‘≈ÃÃ≈À‘’.
%  Prolog is another <<declarative>> language, popular in Artificial Intelligence
%  research.

%  You will learn more about it in the lecture course <<Prolog for Artificial
%  Intelligence>>.

  ¸‘œ Ãœ«…ﬁ≈”À…  —⁄ŸÀ –“œ«“¡ÕÕ…“œ◊¡Œ…—, … «œ◊œ“…‘”—, ﬁ‘œ œŒ
  <<“≈Ã—√…œŒŒŸ >>, ¡ Œ≈ ∆’ŒÀ√…œŒ¡ÃÿŒŸ .
%  It is a logic programming language, and is said to be <<relational>> rather than
%  functional.

  Â«œ ”‘“¡‘≈«…— –œ…”À¡, œ¬“¡‘ŒŸ  (Ãœ«…ﬁ≈”À… ) ◊Ÿ◊œƒ ” ’Œ…∆…À¡√…≈  …
  –œ…”ÀœÕ ” ◊œ⁄◊“¡‘œÕ, —◊Ã—¿‘”— –œÃ≈⁄ŒŸÕ… ƒÃ— €…“œÀœ«œ À“’«¡
  –“…Ãœ÷≈Œ… , ‘¡À…» À¡À: ¬¡⁄Ÿ ƒ¡ŒŒŸ», ‹À”–≈“‘ŒŸ≈ ”…”‘≈ÕŸ … ”“≈ƒ”‘◊¡
  ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ.
%  Its standard search strategy, backward chaining with unification and
%  backtracking, is useful for a wide range of applications including databases,
%  expert systems and theorem provers.

  ÌŸ –œÀ¡÷≈Õ, À¡À Œ¡ ML ”ƒ≈Ã¡‘ÿ ’“≈⁄¡ŒŒŸ  ◊¡“…¡Œ‘ …Œ‘≈“–“≈‘¡‘œ“¡
  “œÃœ«.
%  We will show how to implement a cut-down Prolog interpreter in ML.

  œ”Ã≈ ‹‘œ«œ, …”–œÃÿ⁄’— ‘≈ ÷≈ ”“≈ƒ”‘◊¡ … Õ≈‘œƒŸ ÕŸ ”œ⁄ƒ¡ƒ…Õ –“œ”‘œ≈
  ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ.
%  We will then use the same tools and techniques to build a simple theorem
%  prover.
}


\frame{
  \frametitle{˜Ÿ“¡÷≈Œ…— ◊ “œÃœ«≈}
%  \frametitle{Prolog terms}

  ‰¡ŒŒŸ≈ … Àœƒ ◊ “œÃœ«≈ –“≈ƒ”‘¡◊Ã—¿‘”— ” –œÕœ›ÿ¿ ≈ƒ…Œœ  ”…”‘≈ÕŸ
  ‘≈“Õœ◊ –≈“◊œ«œ –œ“—ƒÀ¡.
%  Prolog code and data is represented using a uniform system of first order
%  terms.

  ÌŸ ¬’ƒ≈Õ –“≈ƒ”‘¡◊Ã—‘ÿ …» ◊ ◊…ƒ≈ “≈À’“”…◊Œœ«œ ‘…–¡ ”»œ÷≈«œ ” ‘≈Õ,
  Àœ‘œ“Ÿ  ÕŸ …”–œÃÿ⁄œ◊¡Ã… ƒÃ— Õ¡‘≈Õ¡‘…ﬁ≈”À…» ◊Ÿ“¡÷≈Œ… .
%  We will represent this using a recursive type similar to the one used for
%  mathematical expressions.

  \PrologTerm

  ˙¡Õ≈‘ÿ‘≈, ﬁ‘œ ÕŸ “¡””Õ¡‘“…◊¡≈Õ ÀœŒ”‘¡Œ‘Ÿ À¡À ∆’ŒÀ√…… ¬≈⁄ ¡“«’Õ≈Œ‘œ◊.
%  Note that we treat constants as nullary functions, i.e. functions that take an
%  empty list of arguments.

  Ù¡Õ, «ƒ≈ “¡Œÿ€≈ …”–œÃÿ⁄œ◊¡Ã”— {\tt Const s}, ‘≈–≈“ÿ ¬’ƒ≈‘ {\tt Fn(s,[])}.
%  Where we would formerly have used {\tt Const s}, we will now use
%  {\tt Fn(s,[])}.

  ˙¡Õ≈‘…Õ ‘¡À÷≈, ﬁ‘œ ÕŸ ¬’ƒ≈Õ “¡””Õ¡‘“…◊¡‘ÿ ∆’ŒÀ√…… “¡⁄Œœ  ¡“Œœ”‘…
  (“¡⁄Œœ«œ ﬁ…”Ã¡ –“…Œ…Õ¡≈ÕŸ» ¡“«’Õ≈Œ‘œ◊) À¡À “¡⁄Ã…ﬁŒŸ≈, ƒ¡÷≈ ≈”Ã…
  ’ Œ…» œƒ…Œ¡Àœ◊Ÿ≈ …Õ≈Œ¡.
%  Note that we will treat functions of different arities (different numbers of
%  arguments) as distinct, even if they have the same name.
}



\frame{
   \frametitle{Ï≈À”…ﬁ≈”À…  ¡Œ¡Ã…⁄ (1)}
%  \frametitle{Lexical analysis (1)}

   ˜ “œÃœ«≈ …ƒ≈Œ‘…∆…À¡‘œ“Ÿ, Àœ‘œ“Ÿ≈ Œ¡ﬁ…Œ¡¿‘”— ” ⁄¡«Ã¡◊Œœ  ¬’À◊Ÿ …Ã…
   –œƒﬁ£“À…◊¡Œ…—, “¡””Õ¡‘“…◊¡¿‘”— À¡À –≈“≈Õ≈ŒŒŸ≈, ¡ ƒ“’«…≈
   ”…Õ◊œÃÿŒœ-√…∆“œ◊Ÿ≈ …ƒ≈Œ‘…∆…À¡‘œ“Ÿ Œ¡“—ƒ’ ” ﬁ…”Ã¡Õ…, “¡””Õ¡‘“…◊¡¿‘”—
   À¡À ÀœŒ”‘¡Œ‘Ÿ.
%  In Prolog, identifiers that begin with an {\em upper case} letter or an
%  underscore are treated as variables, while other alphanumeric identifiers,
%  along with numerals, are treated as constants.

   Ó¡–“…Õ≈“ {\tt X} … {\tt Answer}~-- ‹‘œ –≈“≈Õ≈ŒŒŸ≈, ‘œ«ƒ¡ À¡À {\tt
     x} … {\tt john}~-- ÀœŒ”‘¡Œ‘Ÿ.
%  For example {\tt X} and {\tt Answer} are variables while {\tt x} and
%  {\tt john} are constants.

   Û…Õ◊œÃÿŒŸ≈ …ƒ≈Œ‘…∆…À¡‘œ“Ÿ, ‘¡À÷≈ À¡À ÀœŒ”‘¡Œ‘Ÿ Œ≈ “¡⁄Ã…ﬁ¡¿‘”—, ◊
   œ‘Ã…ﬁ…… œ‘ ”…Õ◊œÃœ◊ –’ŒÀ‘’¡√……: Ã≈◊œ  … –“¡◊œ  ”Àœ¬œÀ, ⁄¡–—‘œ  …
   ‘œﬁÀ… ” ⁄¡–—‘œ  - …» “¡⁄Ã…ﬁ¡‘ÿ ¬’ƒ≈Õ.
%  We will lump all symbolic identifiers together as constants too, but we will
%  distinguish the punctuation symbols: left and right brackets, commas and
%  semicolons.

   Ó≈–’ŒÀ‘’¡√…œŒŒŸ≈ ”…Õ◊œÃŸ ”œ¬…“¡¿‘”— ◊Õ≈”‘≈ ƒœ ”‘“œÀ… Œ¡…¬œÃÿ€≈ 
   ◊œ⁄Õœ÷Œœ  ƒÃ…ŒŸ.  Ù¡À…Õ œ¬“¡⁄œÕ Œ≈ ‘“≈¬’≈‘”—, ﬁ‘œ¬Ÿ ”…Õ◊œÃÿŒŸ 
   …ƒ≈Œ‘…∆…À¡‘œ“ ”œ”‘œ—Ã ‘œÃÿÀœ …⁄ œƒŒœ«œ ”…Õ◊œÃ¡.
%  Non-punctuation symbols are collected together into the longest strings
%  possible, so symbolic identifiers need not consist only of one character.

  \Token
}



\frame[shrink=10]{
   \frametitle{Ï≈À”…ﬁ≈”À…  ¡Œ¡Ã…⁄ (2)}
%  \frametitle{Lexical analysis (2)}

  \Lex
}


\frame{
  \frametitle{Û…Œ‘¡À”…ﬁ≈”À…  ¡Œ¡Ã…⁄ … –≈ﬁ¡‘ÿ}
%  \frametitle{Parsing and printing}

  Û…”‘≈Õ¡ –≈ﬁ¡‘… œ”‘¡£‘”— ◊ ‘œﬁŒœ”‘… ‘¡Àœ  ÷≈ À¡Àœ  ¬ŸÃ¡ “¡Œÿ€≈.
%  The printer is exactly the same as before.

  Û…Œ‘¡À”…ﬁ≈”À…  ¡Œ¡Ã…⁄¡‘œ“ –œﬁ‘… ‘¡Àœ  À¡À “¡Œÿ€≈; –œ◊‘œ“…Õ ﬁ‘œ ÕŸ
  ƒœ–’”À¡≈Õ ⁄¡–…”ÿ Œ≈Àœ‘œ“Ÿ» œ–≈“¡‘œ“œ◊, ‘¡À…» À¡À ”Ãœ÷≈Œ…≈, ◊
  …Œ∆…À”Œœ  ∆œ“Õ≈.  ÌŸ ‘¡À÷≈ ƒœ–’”À¡≈Õ ”–≈√…¡ÃÿŒ’¿ ⁄¡–…”ÿ ƒÃ— ”–…”Àœ◊.
%  The parser is almost the same as before; again we allow some operators like
%  addition to be written infix. We also allow a special syntax for lists.

  ÌŸ “¡””Õ¡‘“…◊¡≈Õ {\tt [x1,x2,\ldots,xn]} À¡À Àœ“œ‘À’¿ ⁄¡–…”ÿ ƒÃ—
  {\tt cons(x1,cons(x2,\ldots,cons(xn,nil)))}
%  We regard {\tt [x1,x2,\ldots,xn]} as shorthand for
%  {\tt cons(x1,cons(x2,\ldots,cons(xn,nil)))}

  «ƒ≈ {\tt cons}~-- ‹‘œ ∆’ŒÀ√…— ƒÃ— ”œ⁄ƒ¡Œ…— ”–…”Àœ◊, –œƒœ¬Œœ {\tt ::}
  ◊ ML.  ≈ﬁ¡‘¡≈‘”— œŒ¡ À¡À …Œ∆…À”Œ¡— ‘œﬁÀ¡.  Ù¡À÷≈ ƒœ–’”‘…Õœ
  …”–œÃÿ⁄œ◊¡‘ÿ {\tt [H|T]} ◊Õ≈”‘œ {\tt cons(H,T)}.
%  where {\tt cons} is the function corresponding to a list constructor,
%  just like {\tt ::} in ML. The printer writes it as an infix dot.
%  Also, {\tt [H|T]} is allowed instead of {\tt cons(H,T)}.

  {\em “¡◊…Ãœ} ◊ “œÃœ«≈ ‹‘œ œƒŒ¡ …⁄ ”Ã≈ƒ’¿›…» ∆œ“Õ:
%  A Prolog {\em rule} is of one of these forms:
  \begin{eqnarray*}
    term\mbox{.}    & &                                             \\
    term            & \mbox{ :- } & term,\ldots,term\mbox{.}
  \end{eqnarray*}
  \noindent ‰Ã— Œ…» ’ Œ¡” ≈”‘ÿ ”…Œ‘¡À”…ﬁ≈”À…  ¡Œ¡Ã…⁄¡‘œ“, Àœ‘œ“Ÿ 
  ◊œ⁄◊“¡›¡≈‘ {\tt term * term list}.
%  \noindent We have a parser for these, returning a {\tt term * term list}.
}



\frame{
  \frametitle{ıŒ…∆…À¡√…—}
%  \frametitle{Unification}

  “œÃœ« …”–œÃÿ⁄’≈‘ Œ¡¬œ“ –“¡◊…Ã ƒÃ— “¡⁄“≈€≈Œ…— ‘≈À’›≈  {\em √≈Ã…},
  –Ÿ‘¡—”ÿ ”œ–œ”‘¡◊…‘ÿ œƒŒœ …⁄ –“¡◊…Ã ” √≈Ãÿ¿.
%  Prolog uses a set of rules to solve a current {\em goal} by trying to match one
%  of the rules against the goal.

  “¡◊…Ãœ, ”œ”‘œ—›…≈ …⁄ ≈ƒ…Œ”‘◊≈ŒŒœ«œ ‘≈“Õ¡, Õœ÷Œœ ”“¡⁄’ “¡⁄“≈€…‘ÿ √≈Ãÿ.
%  A rule consisting of a single term can solve a goal immediately.

  ˜ ”Ã’ﬁ¡≈ –“¡◊…Ã¡ ◊…ƒ¡ \alert{$term \mbox{ :- }
    term_1,\ldots,term_n\mbox{.}$}, ‘œ ﬁ‘œ¬Ÿ “¡⁄“≈€…‘ÿ √≈Ãÿ,
  ”œ–œ”‘¡◊…Õ’¿ ” ‘≈“ÕœÕ \alert{$term$}, “œÃœ«’ Œ≈œ¬»œƒ…Õœ “¡⁄“≈€…‘ÿ
  À¡÷ƒŸ  ‘≈“Õ \alert{$term_i$} À¡À –œƒ√≈Ãÿ.
%  In the case of a rule \alert{$term \mbox{ :- } term_1,\ldots,term_n\mbox{.}$},
%  if the goal matches \alert{$term$}, then Prolog needs to solve each \alert{
%    $term_i$} as a subgoal in order to finish the original goal.

  ÔƒŒ¡Àœ, √≈Ã… … –“¡◊…Ã¡ Õœ«’‘ Œ≈ ”œ◊–¡ƒ¡‘ÿ ◊ ‘œﬁŒœ”‘….  ˜ ”œ”‘¡◊ √≈Ã…
  … ”œ–œ”‘¡◊Ã—≈Õœ«œ –“¡◊…Ã¡ Õœ«’‘ ◊»œƒ…‘ÿ –≈“≈Õ≈ŒŒŸ≈, … –“… ”“¡◊Œ≈Œ……
  √≈Ã… ” –“¡◊…ÃœÕ –≈“≈Õ≈ŒŒŸ≈ Õœ«’‘ –“…”◊¡…◊¡‘ÿ (–“¡◊…ÃÿŒœ ¬ŸÃœ ¬Ÿ
  «œ◊œ“…‘ÿ ”◊—⁄Ÿ◊¡‘ÿ) ”œœ‘◊≈‘”‘◊’¿›…≈ ⁄Œ¡ﬁ≈Œ…—. Ù¡Àœ≈ ”“¡◊Œ≈Œ…≈ ”œ
  ”◊—⁄Ÿ◊¡Œ…≈Õ Œ¡⁄Ÿ◊¡≈‘”— {\em ’Œ…∆…À¡√…≈ }.
%  However, goals and rules do not have to be exactly the same. Instead, Prolog
%  assigns variables in both to make them match up. This process is called {\em
%    unification}.

  ¸‘œ œ⁄Œ¡ﬁ¡≈‘, ﬁ‘œ ◊ ÀœŒ≈ﬁŒœÕ ”ﬁ£‘≈ ÕŸ Õœ÷≈Õ –œÃ’ﬁ…‘ÿ ﬁ¡”‘ŒŸ  ”Ã’ﬁ¡ 
  …⁄Œ¡ﬁ¡ÃÿŒœ  √≈Ã…, Œ¡–“…Õ≈“ –œÃ’ﬁ…‘ÿ \alert{$P(f(X))$} ◊Õ≈”‘œ
  \alert{$P(Y)$}.
%  This means that we can end up proving a special case of the original goal, e.g.
%  \alert{$P(f(X))$} instead of \alert{$P(Y)$}.
}



\frame{
  \frametitle{ıŒ…∆…À¡√…—: –“…Õ≈“Ÿ … ¡Ã«œ“…‘Õ}

  ˛‘œ¬Ÿ ’Œ…∆…√…“œ◊¡‘ÿ ◊Ÿ“¡÷≈Œ…— \alert{$f(g(X),Y)$} …
  \alert{$f(g(a),X)$} Œ≈œ¬»œƒ…Õœ ”◊—⁄¡‘ÿ \alert{$X = a$} … \alert{$Y =
    a$}.  Ùœ«ƒ¡ œ¬¡ ‘≈“Õ¡ ¬’ƒ’‘ …Õ≈‘ÿ ◊…ƒ \alert{$f(g(a),a)$}.
%  To unify \alert{$f(g(X),Y)$} and \alert{$f(g(a),X)$} we need to set
%\alert{$X = a$} and \alert{$Y = a$}. Then both terms are
%\alert{$f(g(a),a)$}.

  ‰Ã— ’Œ…∆…À¡√…… \alert{$f(a,X,Y)$} … \alert{$f(X,a,Z)$} Œ≈œ¬»œƒ…Õœ
  ”◊—⁄¡‘ÿ \alert{$X = a$} … \alert{$Y = Z$}, ‘œ«ƒ¡ œ¬¡ ‘≈“Õ¡ ¬’ƒ’‘
  “¡◊ŒŸ \alert{$f(a,a,Z)$}.
%  To unify \alert{$f(a,X,Y)$} and \alert{$f(X,a,Z)$} we need to set
%\alert{$X = a$} and \alert{$Y = Z$}, and then both terms are
%\alert{$f(a,a,Z)$}.

  Ó≈◊œ⁄Õœ÷Œœ ’Œ…∆…√…“œ◊¡‘ÿ \alert{$f(X)$} … \alert{$X$}.
%  It is impossible to unify \alert{$f(X)$} and \alert{$X$}.

  Â”‘ÿ œ¬›…  ”–œ”œ¬ œ‘Ÿ”À¡Œ…— {\em Œ¡…¬œÃ≈≈ œ¬›≈ } ’Œ…∆…À¡√…….
%  There is a systematic procedure for finding a {\em most general}
%unifier.

  Á“’¬œ «œ◊œ“—, œƒŒœ◊“≈Õ≈ŒŒœ ¡Œ¡Ã…⁄…“’≈Õ œ¬¡ ‘≈“Õ¡ Õ≈‘œƒœÕ
  “≈À’“”…◊Œœ«œ ”–’”À¡ …, Œ¡ ƒ— –≈“≈Õ≈ŒŒ’¿ ◊ œƒŒœÕ …⁄ ‘≈“Õœ◊, ”◊—⁄¡‘ÿ
  ≈£ ” ”œœ‘◊≈‘”‘◊’¿›…Õ –œƒ‘≈“ÕœÕ ƒ“’«œ«œ ‘≈“Õ¡.

%  Roughly, one descends the two terms recursively in parallel, and on
%finding a variable on either side, assigns it to whatever the term on
%the other side is.

  Ó≈œ¬»œƒ…Õœ –“œ◊≈“—‘ÿ, ﬁ‘œ –≈“≈Õ≈ŒŒ¡— Œ≈ ¬ŸÃ¡ ”◊—⁄¡Œ¡ ” ƒ“’«…Õ
  ⁄Œ¡ﬁ≈Œ…≈Õ … ﬁ‘œ œŒ¡ Œ≈ …”–œÃÿ⁄’≈‘”— ◊ ‘≈“Õ≈, ” Àœ‘œ“ŸÕ œŒ¡ ”◊—⁄¡Œ¡.
%  One needs to check that the variable hasn't already been assigned to
%something else, and that it doesn't occur in the term being assigned
%to it (as in the last example above).
}



\frame[shrink=10]{
  \frametitle{ıŒ…∆…À¡√…—: Àœƒ}

  ÌŸ –“œ◊≈“—≈Õ À¡÷ƒ’¿ –≈“≈Õ≈ŒŒ’¿ ¬ŸÃ¡ Ã… œŒ¡ ”◊—⁄¡Œ¡, ”œ«Ã¡”Œœ Œ¡¬œ“’
  ’÷≈ ”◊—⁄¡ŒŒŸ» –≈“≈Õ≈ŒŒŸ».
%   We have a set of existing instantiations, and we
%  look each variable up to see if it is already assigned before
%  proceeding.

  \Unify

  ÌŸ …”–œÃÿ⁄’≈Õ Œ¡¬œ“ ’÷≈ ”◊—⁄¡ŒŒŸ» –≈“≈Õ≈ŒŒŸ» À¡À ¡ÀÀ’Õ’Ã—‘œ“.
%  We use the existing instantiations as an accumulator.
}


\frame[shrink=10]{
  \frametitle{œ–œÃŒ—≈Õ Œ¡¬œ“ ⁄¡ƒ¡ŒŒŸ» –≈“≈Õ≈ŒŒŸ»}
%  \frametitle{Augmenting instantiations}
  \OccursIn
}



\frame[shrink=10]{
  \frametitle{œ…”À ” ◊œ⁄◊“¡‘œÕ}

  “œÃœ« ◊Ÿ–œÃŒ—≈‘ –œ…”À ◊ «Ã’¬…Œ’, Œœ œŒ Õœ÷≈‘ …”–œÃÿ⁄œ◊¡‘ÿ ◊œ⁄◊“¡‘:
  ƒœ–’”‘…Õ –“¡◊…Ãœ ’”–≈€Œœ ’Œ…∆…√…“’≈‘ √≈Ãÿ, Œœ –œ”Ã≈ƒ’¿›…≈ √≈Ã… Œ≈
  Õœ«’‘ ¬Ÿ‘ÿ “¡⁄“≈€≈ŒŸ –“… ‘≈À’›…» ”◊—⁄Ÿ◊¡Œ…—». Ùœ«ƒ¡ ◊Ÿ–œÃŒ—≈‘”—
  ◊œ⁄◊“¡‘, ”◊—⁄Ÿ◊¡Œ…≈ –≈“≈Õ≈ŒŒŸ» œ”◊œ¬œ÷ƒ¡≈‘”—, … ” ‘≈À’›≈  √≈Ãÿ¿
  ”◊≈“—≈‘”— ƒ“’«œ≈ –“¡◊…Ãœ.
  % Prolog proceeds by depth-first search, but it may backtrack: even
  % if a rule unifies successfully, if all the remaining goals cannot
  % be solved under the resulting instantiations, then another initial
  % rule is tried. Thus we consider the whole list of goals rather
  % than one at a time:

  \BackTracking
}



\frame[shrink=10]{
  \frametitle{‰œ–œÃŒ…‘≈ÃÿŒŸ≈ ÕœÕ≈Œ‘Ÿ}

  ˙¡Õ≈‘…Õ, ﬁ‘œ ƒÃ— À¡÷ƒœ«œ –“¡◊…Ã¡, ÕŸ ”œ⁄ƒ¡£Õ Œœ◊Ÿ  Œ¡¬œ“ –≈“≈Õ≈ŒŒŸ».
%  Note that we produce fresh variables for the rules each time:

  \OdO

  Ó¡ÀœŒ≈√, ”œ¬…“¡≈Õ ◊”£ ◊œ≈ƒ…Œœ:
%  Finally, we package everything up:

  \OdOO

  Ú≈⁄’Ãÿ‘¡‘ ∆’ŒÀ√……~~- ”œœ¬›≈Œ…≈ œ ‘œÕ, ﬁ‘œ √≈Ãÿ …Ã… Œ≈ Õœ÷≈‘ ¬Ÿ‘ÿ
  “¡⁄“≈€≈Œ¡, …Ã… “¡⁄“≈€¡≈‘”— ” ⁄¡ƒ¡ŒŒŸÕ… ”◊—⁄Ÿ◊¡Œ…—Õ…. ˜ –œ”Ã≈ƒŒ≈Õ
  ”Ã’ﬁ¡≈ ÕŸ ◊œ⁄◊“¡€¡≈Õ ‘œÃÿÀœ œƒ…Œ œ‘◊≈‘ (œƒ…Œ Œ¡¬œ“ ”◊—⁄¡ŒŒŸ»
  –≈“≈Õ≈ŒŒŸ»), Œœ Õœ÷Œœ …⁄Õ≈Œ…‘ÿ Àœƒ ‘¡À, ﬁ‘œ¬Ÿ ◊Ÿ◊œƒ…Ã…”ÿ ◊”≈
  ◊œ⁄Õœ÷ŒŸ≈ “≈€≈Œ…—.
%  This says either that the goal cannot be solved, or that it can be
%  solved with the given instantiations. Note that we only return one
%  answer in this case, but this is easy to fix.

}

\frame[shrink=10]{
  \frametitle{“…Õ≈“Ÿ Œ¡ “œÃœ«≈ (1)}

  \PrologExamplesO
}

\frame{
  \frametitle{“…Õ≈“Ÿ Œ¡ “œÃœ«≈ (2)}

  \PrologExamplesOO

  “œÃœ« Õ≈Œ≈≈ <<’–“¡◊Ã—≈ÕŸ >> ﬁ≈Õ ML, –œ‹‘œÕ’ ’ Œ≈«œ ≈”‘ÿ ”◊œ…
  œ«“¡Œ…ﬁ≈Œ…—, Œ¡–“…Õ≈“, ”Ã≈ƒ’¿›…  Àœƒ ⁄¡√…ÀÃ…◊¡≈‘”—.
%  Prolog is less `directional' than ML. However it has its
%  limitations, e.g.  the following will loop indefinitely:

  \PrologExamplesOOO
}




\frame{
  \frametitle{‰œÀ¡⁄¡‘≈Ãÿ”‘◊œ ‘≈œ“≈Õ ◊ ”‘…Ã≈ “œÃœ«}
%  \frametitle{Prolog-style theorem proving}

  Ì≈‘œƒ, …”–œÃÿ⁄’≈ÕŸ  ◊ –œ…”À≈ “œÃœ«¡, Õœ÷Œœ –“…”–œ”œ¬…‘ÿ ƒÃ—
  ”œ⁄ƒ¡Œ…— ”“≈ƒ”‘◊ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ, ◊Œ≈”— ◊ Œ≈«œ Œ≈¬œÃÿ€…≈
  …⁄Õ≈Œ≈Œ…—.  “…Õ≈“Ÿ ‘¡À…» ”‘“≈ƒ”‘◊ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ◊ÀÃ¿ﬁ¡¿‘ PTTP
  (Û‘…À≈Ãÿ, 1988) … \mbox{{\sf lean}$T^{\!\!\textstyle A}\!\!P$}
  (Beckert and Possega 1994).

% #ISSUE: ˜œ⁄Õœ÷Œœ Œ≈œ¬»œƒ…Õœ “¡⁄Õ≈”‘…‘ÿ ””ŸÃÀ’ Œ¡
%         http://www.ai.sri.com/~stickel/pttp.html

%  With a few minor changes, Prolog-style search can be used for
%  general theorem proving. Examples of such provers include PTTP
%  (Stickel, 1988) and \mbox{{\sf lean}$T^{\!\!\textstyle A}\!\!P$}
%  (Beckert and Possega 1994).

  ıŒ…∆…À¡√…— —◊Ã—≈‘”— ‹∆∆≈À‘…◊ŒŸÕ Õ≈‘œƒœÕ ƒÃ— œ‘Ÿ”À¡Œ…— œ–‘…Õ¡ÃÿŒœ«œ
  ”–œ”œ¬¡ …”–œÃÿ⁄œ◊¡Œ…— –≈“≈Õ≈ŒŒŸ», ”Œ¡¬÷£ŒŒŸ» À◊¡Œ‘œ“œÕ œ¬›Œœ”‘…
  (“¡◊…√, Úœ¬…Œ”œŒ 1960).
% #ISSUE: Œ¡ƒœ –“œ◊≈“…‘ÿ … ’‘œﬁŒ…‘ÿ ”≈Õ¡Œ‘…À’ ‹‘œ«œ –“≈ƒÃœ÷≈Œ…— --lg

%  Unification is an efficient method for deciding how to specialize
%  universally quantified variables (Prawitz, Robinson 1960).

  Ó¡–“…Õ≈“, …Õ≈— –“¡◊…Ã¡ \alert{$\all{X} p(X) \Imp q(X)$ … $p(f(a))$},
  Õœ÷Œœ ’Œ…∆…√…“œ◊¡‘ÿ œ¬¡ ◊Ÿ“¡÷≈Œ…—, ◊ÀÃ¿ﬁ¡¿›…≈ \alert{$p$} … ‘≈Õ
  ”¡ÕŸÕ ”◊—⁄¡‘ÿ \alert{$X$} ” \alert{$f(a)$}. Ó¡–“œ‘…◊, ”¡ÕŸ≈ “¡ŒŒ…≈
  ”…”‘≈ÕŸ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ ‘≈œ“≈Õ –Ÿ‘¡Ã…”ÿ ”‘“œ…‘ÿ ◊”≈◊œ⁄Õœ÷ŒŸ≈ ‘≈“ÕŸ …⁄
  ƒœ”‘’–ŒŸ» ÀœŒ”‘¡Œ‘ … ∆’ŒÀ√… .

%  For example, given the facts that \alert{$\all{X} p(X) \Imp q(X)$}
%  and \alert{ $p(f(a))$}, we can unify the two expressions involving
%  \alert{$p$} and thus discover that we need to set \alert{$X$} to
%  \alert{$f(a)$}. By contrast, the very earliest theorem provers tried
%  all possible terms!

  Ô¬ŸﬁŒœ, –œ…”À ◊ «Ã’¬…Œ’ ⁄¡√…ÀÃ…◊¡≈‘”—, –œ‹‘œÕ’ Œ¡Õ Œ≈œ¬»œƒ…Õœ
  Œ≈ÕŒœ«œ …⁄Õ≈Œ…‘ÿ ”‘“¡‘≈«…¿ –œ…”À¡ “œÃœ«.  ÌŸ ¬’ƒ≈Õ …”–œÃÿ⁄œ◊¡‘ÿ
  {\em –œ…”À ◊«Ã’¬ÿ ” …‘≈“¡‘…◊ŒŸÕ –œ«“’÷≈Œ…≈Õ}.

%  Usually, depth-first search would go into an infinite loop, so we
%  need to modify the Prolog strategy slightly. We will use {\em depth
%    first iterative deepening}.
}


\frame{
  \frametitle{Ú¡¬œ‘¡ ” ∆œ“Õ’Ã¡Õ…}
%  \frametitle{Manipulating formulas}

  ‰Ã— œ¬œ⁄Œ¡ﬁ≈Œ…— ∆œ“Õ’Ã ¬’ƒ≈Õ …”–œÃÿ⁄œ◊¡‘ÿ ‘≈“ÕŸ –≈“◊œ«œ –œ“—ƒÀ¡.
  ‰œ¬¡◊…Õ ‘¡À÷≈ Œœ◊Ÿ≈ ÀœŒ”‘¡Œ‘Ÿ ƒÃ— Ãœ«…ﬁ≈”À…» œ–≈“¡‘œ“œ◊, Œ≈Àœ‘œ“Ÿ≈
  …⁄ Àœ‘œ“Ÿ» - …Œ∆…À”ŒŸ≈.

%  We will simply use our terms to denote formulas, introducing new
%  constants for the logical operators. Many of these are written
%  infix.

  \begin{center}
  \begin{tabular}{|l|l|}
  \hline
  Ô–≈“¡‘œ“   & ˙Œ¡ﬁ≈Œ…≈                            \\
  \hline
  {\tt \~{}}(p)    & Œ≈ p                         \\
  p {\tt \&} q     & p … q                       \\
  p {\tt |} q      & p …Ã… q                        \\
  p {\tt -->} q    & p ◊Ã≈ﬁ£‘ q (…Õ–Ã…À¡√…—)                  \\
  p {\tt <->} q    & p ‘œÃÿÀœ … ≈”Ã… ‘œÃÿÀœ q (‹À◊…◊¡Ã≈Œ‘Œœ”‘ÿ)            \\
  forall(X,p)      & ƒÃ— ◊”≈» X, p  (À◊¡Œ‘œ“ œ¬›Œœ”‘…)                \\
  exists(X,p)      & ”’›≈”‘◊’≈‘ X ‘¡Àœ  ﬁ‘œ p (À◊¡Œ‘œ“ ”’›≈”‘◊œ◊¡Œ…—)\\
  \hline
  \end{tabular}
  \end{center}

  ·Ãÿ‘≈“Œ¡‘…◊ŒŸ  –œƒ»œƒ ⁄¡ÀÃ¿ﬁ¡≈‘”— ◊ ƒœ¬¡◊Ã≈Œ…… œ‘ƒ≈ÃÿŒœ«œ ‘…–¡ ƒÃ—
  ∆œ“Õ’Ã, Œœ ‘œ«ƒ¡ –œ‘“≈¬’≈‘”— ƒœ¬¡◊…‘ÿ Àœƒ … ƒÃ— ”…Œ‘¡À”…ﬁ≈”Àœ«œ
  “¡⁄¬œ“¡, … –≈ﬁ¡‘….  È⁄ ”œœ¬“¡÷≈Œ…  –“œ”‘œ‘Ÿ œ«“¡Œ…ﬁ…Õ”— –≈“◊ŸÕ
  “≈€≈Œ…≈Õ.
%  An alternative would be to introduce a separate type of formulas, but this
%  would require separate parsing and printing support. We will avoid this, for
%  the sake of simplicity.
}

\frame[shrink=10]{
  \frametitle{“≈ƒ◊¡“…‘≈ÃÿŒ¡— œ¬“¡¬œ‘À¡ ∆œ“Õ’Ã}
%  \frametitle{Preprocessing formulas}

  Ôﬁ≈◊…ƒŒœ, –“œ«“¡ÕÕ¡ ’–“œ”‘…‘”—, ≈”Ã… œ”Œœ◊Œ¡— ﬁ¡”‘ÿ ”“≈ƒ”‘◊¡
  ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ Œ≈ ¬’ƒ≈‘ “¡¬œ‘¡‘ÿ ” …Õ–Ã…À¡√…—Õ… … ‹À◊…◊¡Ã≈Œ‘Œœ”‘—Õ….
  ÛÃ≈ƒœ◊¡‘≈ÃÿŒœ, ”Œ¡ﬁ¡Ã¡ œ–“≈ƒ≈Ã…Õ ∆’ŒÀ√…¿, ⁄¡Õ≈Œ—¿›’¿ …» ÀœÕ¬…Œ¡√…≈ 
  ƒ“’«…» œ–≈“¡‘œ“œ◊.

%  It's convenient if the main part of the prover need not cope with
%  implications and `if and only if's. Therefore we first define a
%  function that eliminates these in favour of the other connectives.

  \ProcForm

  “…◊≈ƒ£Õ ∆œ“Õ’Ã’ ◊ ‘¡À Œ¡⁄Ÿ◊¡≈Õ’¿ <<œ‘“…√¡‘≈ÃÿŒ’¿ Œœ“Õ¡ÃÿŒ’¿
  ∆œ“Õ’>>~~- ∆œ“Õ’Ã’ …⁄ ‹Ã≈Õ≈Œ‘¡“ŒŸ» ‘≈“Õœ◊ … …» œ‘“…√¡Œ… , ”◊—⁄¡ŒŒŸ»
  ” –œÕœ›ÿ¿ œ–≈“¡‘œ“œ◊ <<È>>, <<ÈÏÈ>> … À◊¡Œ‘œ“œ◊.

%  The next step is to push the negations down the formula, putting it
%  into so-called `negation normal form' (NNF).
}

\frame[shrink=10]{
  \frametitle{ÔÓÊ Àœƒ}
%  \frametitle{NNF code}

  ÌŸ œ–“≈ƒ≈Ã…Õ ƒ◊≈ ◊⁄¡…ÕŒœ “≈À’“”…◊ŒŸ≈ ∆’ŒÀ√……, Àœ‘œ“Ÿ≈ ”œ⁄ƒ¡¿‘ ÔÓÊ
  ƒÃ— ∆œ“Õ’ÃŸ … ƒÃ— ≈£ œ‘“…√¡Œ…—.
%  We define two mutually recursive functions that create NNF for a
%  formula, and its negation.

  \NnfCode

  ÌŸ –“≈œ¬“¡⁄’≈Õ œ‘“…√¡Œ…≈ ⁄¡ƒ¡ŒŒœ  ∆œ“Õ’ÃŸ ◊ œ‘“…√¡‘≈ÃÿŒ’¿ Œœ“Õ¡Ãÿ’¿
  ∆œ“Õ’, ¡ œ”Œœ◊Œœ≈ ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ –œ–“œ¬’≈‘ –œÃ’ﬁ…‘ÿ …⁄
  ‹‘œ«œ –“œ‘…◊œ“≈ﬁ…≈.
%  We will convert the negation of the input formula into negation
%  normal form, and the main prover will then try to derive a
%  contradiction from it.
}


\frame{
  \frametitle{Ô”Œœ◊Œœ≈ ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡}
%  \frametitle{The main prover}

  Ó¡ À¡÷ƒœÕ ‹‘¡–≈ ƒœÀ¡⁄Ÿ◊¡‘≈Ãÿ …Õ≈≈‘ ‘≈À’›’¿ ∆œ“Õ’Ã’, ”–…”œÀ ∆œ“Õ’Ã,
  Àœ‘œ“Ÿ≈ ≈›£ –“≈ƒ”‘œ…‘ “¡””Õœ‘“≈‘ÿ … ”–…”œÀ Ã…‘≈“¡Ãœ◊. ÔŒ –Ÿ‘¡≈‘”—
  –œÃ’ﬁ…‘ÿ –“œ‘…◊œ“≈ﬁ…≈.
%  At each stage, the prover has a current formula, a list of formulas yet to be
%  considered, and a list of literals. It is trying to reach a contradiction.

  Â”Ã… ‘≈À’›¡— ∆œ“Õ’Ã¡~-- {\tt p \& q}, ‘œ {\tt p} … {\tt q}
  “¡””Õ¡‘“…◊¡¿‘”— –œ œ‘ƒ≈ÃÿŒœ”‘…, ‘.≈ {\tt p} ƒ≈Ã¡≈‘”— ‘≈À’›≈ 
  ∆œ“Õ’Ãœ , ¡ {\tt q} ƒœ¬¡◊Ã—≈‘”— À ∆œ“Õ’Ã¡Õ <<Œ¡ “¡””Õœ‘“≈Œ…≈>>.

%  If the current formula is {\tt p \& q}, then consider {\tt p} and
%  {\tt q} separately, i.e. make {\tt p} the current formula and add
%  {\tt q} to the formulas to be considered.

  Â”Ã… ‘≈À’›¡— ∆œ“Õ’Ã¡ …Õ≈≈‘ ◊…ƒ {\tt p | q}, ‘œ ƒ≈Ã¡≈‘”— –œ–Ÿ‘À¡
  –œÃ’ﬁ…‘ÿ –“œ‘…◊œ“≈ﬁ…≈ ”Œ¡ﬁ¡Ã¡ ” {\tt p}, ¡ ⁄¡‘≈Õ ” {\tt q}.
%  If the current formula is {\tt p | q}, then try to get a
%  contradiction from {\tt p} and then from {\tt q}.

  Â”Ã… ‘≈À’›¡— ∆œ“Õ’Ã¡~~- {\tt forall(X, p)}, ƒÃ— ⁄¡Õ≈›≈Œ…— {\tt X}
  ◊◊œƒ…‘”— Œœ◊¡— –≈“≈Õ≈ŒŒ¡—, –“¡◊…ÃÿŒœ≈ ⁄Œ¡ﬁ≈Œ…≈ Õœ÷≈‘ ¬Ÿ‘ÿ –œÃ’ﬁ≈Œœ
  –œ⁄÷≈, –“… ’Œ…∆…À¡√…….
%  If the current formula is {\tt forall(X,p)}, invent a new variable to
%  replace {\tt X}: the right value can be discovered later by unification.

  Â”Ã… ‘≈À’›¡— ∆œ“Õ’Ã¡~~- {\tt exists(X,p)}, ƒÃ— ⁄¡Õ≈›≈Œ…— {\tt X}
  ◊◊œƒ…‘”— Œœ◊¡— ÀœŒ”‘¡Œ‘¡.
%  If the current formula is {\tt exists(X,p)}, invent a new constant to
%  replace {\tt X}.

  ˜ –“œ‘…◊ŒœÕ ”Ã’ﬁ¡≈, ∆œ“Õ’Ã¡ ƒœÃ÷Œ¡ ¬Ÿ‘ÿ Ã…‘≈“¡ÃœÕ, ‘¡À ﬁ‘œ ƒ≈Ã¡≈‘”—
  –œ–Ÿ‘À¡ ’Œ…∆…√…“œ◊¡‘ÿ ≈«œ –“œ‘…◊œ“≈ﬁ…◊ŸÕ Ã…‘≈“¡ÃœÕ.
%  Otherwise, the formula must be a literal, so try to unify it with a
%  contradictory literal.

  Â”Ã… ’Œ…∆…À¡√…— Œ≈ ’ƒ¡Ã¡”ÿ, Ã…‘≈“¡Ã ƒœ¬¡◊Ã—≈‘”— ◊ ”–…”œÀ Ã…‘≈“¡Ãœ◊,
  ¡ ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ –≈“≈»œƒ…‘ À œ¬“¡¬œ‘À≈ ”Ã≈ƒ’¿›≈  ∆œ“Õ’ÃŸ.
%  If this fails, add it to the list of literals, and proceed with the next
%  formula.
}



\frame{
  \frametitle{“œƒœÃ÷≈Œ…—}
%  \frametitle{Continuations}

  Ó¡Õ Œ≈œ¬»œƒ…Õ¡ ”‘“¡‘≈«…— ◊œ⁄◊“¡‘¡, –œ»œ÷¡— Œ¡ –“œÃœ«œ◊”À’¿: ‘œÃÿÀœ
  ≈”Ã… ‘≈À’›…≈ ”◊—⁄Ÿ◊¡Œ…— –œ⁄◊œÃ—¿‘ “¡⁄“≈€…‘ÿ ◊”≈ œ”‘¡◊€…≈”— √≈Ã…, ÕŸ
  ƒœ–’”À¡≈Õ …».
%  We desire a similar backtracking strategy to Prolog: only if the current
%  instantiations allow all remaining goals to be solved do we accept it.

  Ìœ÷Œœ ¬ŸÃœ ¬Ÿ ”Œœ◊¡ …”–œÃÿ⁄œ◊¡‘ÿ ”–…”À…, Œœ ƒ¡◊¡ ‘≈ –œ–“œ¬’≈Õ {\em
    –“œƒœÃ÷≈Œ…—}({\em continuations}).  “œƒœÃ÷≈Œ…≈~~- ‹‘œ ∆’ŒÀ√…—,
  –≈“≈ƒ¡¿›¡—”— ƒ“’«œ  ∆’ŒÀ√……, Àœ‘œ“¡— Õœ÷≈‘ ◊Ÿ⁄Ÿ◊¡‘ÿ”— …⁄ –œ”Ã≈ƒŒ≈ 
  <<ƒÃ— ◊Ÿ–œÃŒ≈Œ…— œ”‘¡‘œﬁŒŸ» ◊Ÿﬁ…”Ã≈Œ… >>.
%  We could use lists again, but instead we use {\em continuations}. A
%  continuation is a function that is passed to another function and can be called
%  from within it to <<perform the rest of the computation>>.

  ˜ Œ¡€≈Õ ”Ã’ﬁ¡≈ œŒ¡ –“…Œ…Õ¡≈‘ ”–…”œÀ ” –≈“≈Õ≈ŒŒŸÕ… … –Ÿ‘¡≈‘”—
  “¡⁄“≈€…‘ÿ œ”‘¡◊€…≈”— √≈Ã… –“… ⁄¡ƒ¡ŒŒŸ» ”◊—⁄Ÿ◊¡Œ…—».
%  In our case, it takes a list of instantiations and tries to solve the remaining
%  goals under these instantiations.

  ÛÃ≈ƒœ◊¡‘≈ÃÿŒœ ◊Õ≈”‘œ –œ–Ÿ‘œÀ —◊Œœ “¡⁄“≈€…‘ÿ œ”‘¡◊€…≈”— √≈Ã…, ÕŸ
  –“œ”‘œ ◊Ÿ⁄Ÿ◊¡≈Õ ∆’ŒÀ√…¿-–“œƒœÃ÷≈Œ…≈.
%  Thus, rather than explicitly trying to solve all remaining goals, we simply try
%  calling the continuation.
}


\frame[shrink=10]{
  \frametitle{Û“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡: Àœƒ}
%  \frametitle{Prover code}

  \Prover
}

\frame[shrink=10]{
  \frametitle{Û“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡: –“…Õ≈“Ÿ (1)}
%  \frametitle{Prover examples (1)}

  È, Œ¡ÀœŒ≈√, ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡:
%  We set up the final prover as follows:

  \ProverExampleO

  Û“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ –Ÿ‘¡≈‘”— Œ¡ ‘… ƒœÀ¡⁄¡‘≈Ãÿ”‘◊œ ” Œ¡…Õ≈Œ≈≈
  œ¬›…Õ… ”◊—⁄Ÿ◊¡Œ…—Õ… –≈“≈Õ≈ŒŒŸ»; ≈”Ã… ‹‘œ ’ƒ¡£‘”—, œŒ ◊œ⁄◊“¡›¡≈‘ …»
  ﬁ…”Ãœ … ”¡Õ… ⁄Œ¡ﬁ≈Œ…— –≈“≈Õ≈ŒŒŸ».
%  It tries to find the proof with the fewest universal instantiations.
%  It returns the number required and any toplevel instantiations.

  \ProverExampleOO
}


\frame[shrink=10]{
  \frametitle{Û“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡: –“…Õ≈“Ÿ (2)}
%  \frametitle{Prover examples (2)}

  “…Õ≈“ –œ¬œÃÿ€≈:
%  A bigger example is the following:

  \ProverExampleOOO

  Ê¡À‘…ﬁ≈”À… ”“≈ƒ”‘◊œ ƒœÀ¡⁄¡‘≈Ãÿ”‘◊¡ Õœ÷≈‘ “¡¬œ‘¡‘ÿ ƒ≈‘≈À‘…◊œÕ:
% In fact, the prover can work out `whodunit':

  \ProverExampleOOOO
}

\end{document}
