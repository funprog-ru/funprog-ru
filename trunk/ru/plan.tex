\chapter*{План лекций}

Этот раздел описывает как материал распределён по 12 лекциям курса,
каждая из которых длиться немногим меньше часа.

%This chapter indicates roughly how the material is to be distributed over a
%course of twelve lectures, each of slightly less than one hour.

\begin{enumerate}

\item {\bf Введение и обзор} Функциональное и императивное
  программирование: различия, ``за'' и ``против''. Общая структура
  курса: как $\lambda$-исчисление превратилось в язык программирования
  общего назначения. $\lambda$-нотация: как разъясняет связывание
  переменных и как предоставляет средства общего анализа
  математической записи.  Каррирование.  Парадокс Рассела.

%\item {\bf Introduction and Overview} Functional and imperative programming:
%contrast, pros and cons. General structure of the course: how lambda calculus
%turns out to be a general programming language. Lambda notation: how it
%clarifies variable binding and provides a general analysis of mathematical
%notation. Currying. Russell's paradox.

\item {\bf $\lambda$-исчисление как формальная система} Свободные и
  связанные переменные.  Подстановка.  Правила преобразования.
  Эквивалентность $\lambda$-термов.  Экстенсиональность.  Редукция и
  её стратегии.  Теорема Чёрча-Россера: формулировка и следствия.
  Комбинаторы.

%\item {\bf Lambda calculus as a formal system} Free and bound variables.
%Substitution. Conversion rules. Lambda equality. Extensionality. Reduction and
%reduction strategies. The Church-Rosser theorem: statement and consequences.
%Combinators.

\item {\bf $\lambda$-исчисление как язык программирования} Основы
  вычислимости; Тьюрингова полнота (без доказательства).
  Представление данных и основные операции: булевы значения, пары и
  кортежи, натуральные числа.  ??? The predecessor operation.
  Написание рекурсиыных функций: ???? fixed point
  combinators. Let-выражения.  $\lambda$-исчисление как декларативный
  язык.

\item {\bf Типы} Почему типы?  Ответы из программирования и логики.
  Simply typed lambda calculus. Church and Curry typing. Let
  polymorphism. Most general types and Milner's algorithm. Strong
  normalization (no proof), and its negative consequences for Turing
  completeness. Adding a recursion operator.

\item {\bf ML} ML as typed lambda calculus with eager evaluation. Details of
evaluation strategy. The conditional. The ML family. Practicalities of
interacting with ML. Writing functions. Bindings and declarations. Recursive
and polymorphic functions. Comparison of functions.

\item {\bf Более подробно о ML} More about interaction with ML. Loading from files.
Comments. Basic data types: unit, booleans, numbers and strings. Built-in
operations. Concrete syntax and infixes. More examples. Recursive types and
pattern matching. Examples: lists and recursive functions on lists.

\item {\bf Доказательство корректности программы} The correctness
  problem. Testing and verification. The limits of
  verification. Functional programs as mathematical objects. Examples
  of program proofs: exponential, GCD, append and reverse.

\item {\bf Эффективный ML} Using standard combinators. List iteration and other
useful combinators; examples. Tail recursion and accumulators; why tail
recursion is more efficient. Forcing evaluation. Minimizing consing. More
efficient reversal. Use of `as'. Imperative features: exceptions, references,
arrays and sequencing. Imperative features and types; the value restriction.

\item {\bf Примеры на ML I: символьное дифференцирование} Символьные
  вычисления.  Представление данных.  Приоритет операторов. Association
  lists. Prettyprinting expressions. Installing the
  printer. Differentiation. Simplification. The problem of the `right'
  simplification.

\item {\bf Примеры на ML II: рекурсивный нисходящий разбор} Grammars and the parsing
problem. Fixing ambiguity. Recursive descent. Parsers in ML. Parser
combinators; examples. Lexical analysis using the same techniques. A parser for
terms. Automating precedence parsing. Avoiding backtracking. Comparison with
other techniques.

\item {\bf Примеры на ML III: exact real arithmetic} Real numbers and finite
representations. Real numbers as programs or functions. Our representation of
reals. Arbitrary precision integers. Injecting integers into the reals.
Negation and absolute value. Addition; the importance of rounding division.
Multiplication and division by integers. General multiplication. Inverse and
division. Ordering and equality. Testing. Avoiding reevaluation through memo
functions.

\item {\bf Примеры на ML IV: Prolog и доказательство теорем} Prolog terms.
Case-sensitive lexing. Parsing and printing, including list syntax.
Unification. Backtracking search. Prolog examples. Prolog-style theorem
proving. Manipulating formulas; negation normal form. Basic prover; the use of
continuations. Examples: Pelletier problems and whodunit.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
