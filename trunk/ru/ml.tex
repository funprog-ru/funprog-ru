\chapter{``Вкус'' ТО}

В предыдущих главах мы начали с чистого $lambda$-исчисления, а затем
систематически расширяли его новыми возможностями.  Например, мы
добавили конструкцию `let' как примитив, чтобы сделать полиморфическое
типизирование более полезным, а также оператор рекурсии, для того,
чтобы восстановить мощь вычислений, которая была потеряна после
введения типов.  Двигаясь дальше по этому пути, мы в конечном счете
достигли ML, при этом имея возможность простого взгляда на мир
используя типизированное $lambda$-исчисление.

Следующей стадией является избавление от выражения таких типов данных
как логические значения и натуральные числа через $lambda$-термы, и
создания примитивов для них.  Так что мы получим новые примитивные
типы, такие как {\tt bool} и {\tt int} (положительные и отрицательные
целые числа) и новые конструктора типов, такие как $\times$,~--- шаг,
который мы предчувствовали в последней главе.  С этими изменениями
также связаны новые константы и новые правила преобразования.
Например, выражение $2 + 2$ вычисляется с использованием машинной
арифметики, вместо преобразования его в нумералы Черча и выполнения
$\beta$-преобразований.  Эти дополнительные преобразования,
рассматриваемые как расширение обычных $lambda$-операций, часто
называются `$\delta$-преобразованиями'.  Мы увидим в течении курса как
язык ML расширен по сравнению с чистым $lambda$-исчислением.  Первым
делом мы должны обратиться к фундаментальному вопросу стратегии оценки
выражений ML.

\section{Энергичное вычисление}

Мы сказали, что с теоретической точки зрения, нормальный порядок
(сверху вниз, слева направо) редукции выражений более предпочтителен,
поскольку, если любая стратегия завершается, то она и будет выбрана
(???this one will).\footnote{Эта стратегия подобна некоторым,
  используемым в традиционных языках, таких как Algol 60, где на нее
  ссылались как на {\em вызов по имени}.}  Однако, этот подход имеет
некоторые практические дефекты.  Например, рассмотрим следующее
выражение:

$$ (\lamb{x} x + x + x)\; (10 + 5) $$

При использовании нормального порядка редукции мы получаем $(10 + 5) +
(10 + 5) + (10 + 5)$, и на следующих шагах редукции мы должны
вычислить три отдельных вхождения (??? instances) одного и того же
выражения.  На практике это совершенно недопустимо.  Существует два
основных решения данной проблемы, эти решения делят мир
функционального программирования на два лагеря.

Первым решением является придерживание нормального порядка редукции,
но при этом пытаться оптимизировать реализацию так, чтобы множественные
подвыражения, возникающие при таком подходе, использовались совместно,
и никогда не вычислялись более одного раза.  Внутри выражения
представляются как связанные ацикличные графы, а не деревья.  Этот
подход известен как {\em ленивое (lazy)} или {\em вызов по
  необходимости (call-by-need)} вычисление, поскольку выражения
вычисляются только тогда, когда они необходимы.

Вторым решением является попытка перевернуть теоретические размышления
о стратегии редукции с ног на голову, и вычислять аргументы функции до
передачи значений.  Этот подход известен как {\em аппликативный
  порядок} или {\em энергичное} вычисление.  Последнее имя возникло
из-за того, что аргументы функции вычисляются даже тогда, когда они не
нужны, например, $t$ в $(\lamb{x} y)\; t$.  Конечно, энергичное
вычисление означает, что некоторые выражения могут зацикливаться,
тогда как они могут завершаться при работе в ленивом режиме.  Но это
считается допустимым, поскольку этих вещей достаточно легко избежать на
практике.  В любом случае, стратегия энергичного вычисления является
стандартной для многих языков программирования, таких как C, где на
нее ссылаются как на {\em вызов по значению (call by value)}.

ML использует энергичное вычисление по двум основным причинам.
Управление редукцией и совместным использованием, которое возникает
при ленивом вычислении, является достаточно сложным, и реализация
может быть относительно неэффективной и усложненной.  Если программист
не особо заботлив, то память может заполниться не вычисленными
выражениями, и в общем тяжело понять потребление памяти программами.
В действительности, многие реализации ленивого вычисления стараются
оптимизировать их, путем использования энергичных вычислений в тех
местах, где семантика не отличается.\footnote{Они стараются выполнить
  {\em анализ строгости}~--- один из видов статического анализа,
  который часто помогает определить, что аргументы должны быть
  вычислены \cite{mycroft-thesis}.}  В противоположность этому, в ML
мы всегда сначала вычисляем аргументы функций, и только затем
выполняем $\beta$-редукцию~--- это просто и эффективно, и легко
реализуется с использованием стандартных технологий построения
компиляторов.

Второй причиной для выбора аппликативного порядка вычислений является
то, что ML не является {\em чистым} функциональным языком, а имеет
императивные возможности (переменные, присваивание и т.п.).
Следовательно, порядок вычисления подвыражений может сделать {\em
  семантику} отличающейся, а не просто затрагивает эффективность.
Если используется ленивое вычисление, то для программиста становится
практически невозможным показать (в нетривиальной программе) когда
какое подвыражение вычисляется.  В энергичной системе ML, нужно лишь
помнить простое правило вычисления.

Однако важно осознавать, что стратегия вычислений ML  {\em не} просто
снизу вверх, в противоположность нормальному порядку редукции. В
действительности ML {\em никогда не вычисляет содержимое
  $lambda$-выражений}.  (В частности, он не когда не
редуцирует$\eta$-???redexes, в только $\beta$-???redexes.)  При
вычислении  $(\lamb{x} s[x])\; t$, сначала вычисляется $t$.  Однако
$s[x]$ не затрагивается, поскольку оно является содержимым
$lambda$-выражения.  Кроме того, любое подвыражение  $t$, которое
является содержимым $lambda$-выражения, также остается нетронутым.
Вот точные правила вычисления:

\begin{itemize}

\item Константы вычисляются сами в себя.

\item Вычисления заканчиваются на $\lambda$-абстракциях, и не
  затрагивают их содержимого.  В частности, не выполняется
  $\eta$-преобразование.

\item При вычислении комбинации $s\; t$ {\em сначала} вычисляются и
  $s$ и $t$. Предполагая, что вычисляемая форма $s$ является
  $lambda$-абстракцией, то выполняется $\beta$-преобразование верхнего
  уровня, и процесс повторяется.

\end{itemize}

Порядок вычисления $s$ и $t$ отличается в зависимости от версии ML.  В
той версии, которую мы будем использовать, сначала всегда
вычисляется~$t$.  Строго говоря, мы также должны задать правило для
{\tt let}-выражений, поскольку, как упоминалось, они теперь
рассматриваются как примитивы.  Однако, с точки зрения вычислений, они
могут рассматриваться как обычно, как $lambda$-выражения, примененные
к аргументу, с понимаем того, что  rand???? будет вычислен первым.
Для того, чтобы сделать это явным, правило для 

$$ \mbox{let}\; x = s\; \mbox{in}\; t $$

\noindent гласит, что сначала вычисляются все $s$, а результат
подставляется вместо $x$ в $t$, и в заключение, вычисляется новое
значение $t$.  Давайте рассмотрим некоторые примеры вычисления
выражений:

\begin{eqnarray*}
(\lamb{x} (\lamb{y} y + y)\; x) (2 + 2)
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x) 4   \\
& \goesto & (\lamb{y} y + y) 4                  \\
& \goesto & 4 + 4                               \\
& \goesto & 8
\end{eqnarray*}

Заметьте, что под-терм $(\lamb{y} y + y)\; x$ {\em не редуцируется},
поскольку он находится внутри $lambda$-выражения.  Однако,
что редуцируемые термы, \emph{не} находящиеся внутри $lambda$-выражений
обоих функций, а также аргумент, редуцируются до того, как вычисляется
применения функции, например, второй шаг будет следующим:

\begin{eqnarray*}
((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; (2 + 2)
& \goesto & ((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; 4           \\
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x)\; 4                   \\
& \goesto & (\lamb{y} y + y)\; 4                                  \\
& \goesto & 4 + 4
\end{eqnarray*}

Факт, что ML не вычисляет внутри $lambda$-выражений, является ключевым
для высококвалифицированных программистов на ML.  Это дает возможность
точного контроля за вычислением выражений, и может использоваться для
имитации многих полезных вещей из стратегии ленивого вычисления.  Мы
увидим очень простые примеры в следующем разделе.

\section{Результаты энергичного вычисления}

Использование энергичного вычисления заставляет нас объявить некоторые
дополнительные возможности как примитивы, с их собственными
специальными процедурами редукции, вместо того, чтобы реализовать их
напрямую, в терминах $lambda$-исчисления.  В частности, мы не можем
больше рассматривать условную конструкцию:

$$ \mbox{if}\; b\; \mbox{then}\; e_1\; \mbox{else}\; e_2 $$

\noindent как применение обычного трехкомпонентного (тернарного) оператора:

$$ \mbox{COND}\; b\; e_1\; e_2 $$

Причина заключается в том, что в любом случае, из-за применения
энергичного вычисления, мы вычисляем все выражения $b$, $e_1$ и $e_2$,
\emph{до} вычисления содержимого $\mbox{COND}$.  Обычно это пагубно.
Например, заново рассмотрим наше определение функции для вычисления
факториала:

$$ \mbox{let rec fact}(n) = \mbox{if ISZERO}\; n\; \mbox{then}\; 1\;
                            \mbox{else}\; n * \mbox{fact}(\mbox{PRE}\; n) $$

Если условие будет вычислять все свои аргументы, то для вычисления 
$\mbox{fact}(0)$, ветвь `else' также должна быть вычислена, что
в свою очередь вызывает вычисление $\mbox{fact}(\mbox{PRE}\; 0)$.  И
это в свою очередь вызывает вычисление $\mbox{fact}(\mbox{PRE}\;
(\mbox{PRE}\; 0))$, и т.д.  Соответственно, вычисление превратиться в
бесконечный цикл.

Таким образом, мы делаем условия примитивной конструкцией, и изменяем
обычную стратегию редукции таким образом, что  {\em сначала}
вычисляется логическое выражение, а затем вычисляется {\em только
  одно} из двух ветвей условия.

А что происходит с самим процессом рекурсии?  Мы предполагаем
понимание рекурсивных определений в терминах рекурсивного оператора
$Rec$ с его собственным правилом редукции:

$$ Rec\; f \goesto f(Rec\; f) $$

\noindent он также будет зацикливаться при использовании стратегии
энергичного вычисления:

$$  Rec\; f \goesto f(Rec\; f) \goesto f(f(Rec\; f)) \goesto f(f(f(Rec\; f)))
\goesto \cdots $$

Однако, нам необходимо лишь очень простое изменение в правиле
редукции, которое заставит работать правильно:

$$ Rec\; f \goesto f(\lamb{x} Rec\; f\; x) $$

Теперь, $lambda$-выражение справа означает, что $\lamb{x} Rec\; f\; x$
вычисляется само в себя, и только после того, как выражение будет
редуцирует следующие подстановки в теле $f$, вычисление продолжится.

\section{Семейство языков ML}

Мы говорили о `ML' так, как будто это один язык.  На самом деле
существует много вариантов ML, даже включая `Lazy ML', реализацию
университета Chalmers в Швеции, которая базируется на ленивых
вычислениях.  Наиболее популярная версия ML в образовании~--- это
`Standard ML', но мы будет использовать другую версию, называющуюся
CAML (`camel') Light.\footnote{Это имя означает `Categorical Abstract
  Machine', метод реализации, лежащий в ее основе.}  Мы выбрали CAML
Light по следующим причинам:

\begin{itemize}

\item реализация имеет небольшой объем и хорошо переносима между
  платформами, так что она эффективно работает на Unix, PC, Macs, и
  других.

\item Система очень проста, синтаксически и семантически, что делает
  ее достаточно простой для изучения.

\item Система хорошо подходит для практического использования,
  например, она имеет интерфейс с библиотекам на языке C и
  поддерживает стандартную, раздельную компиляцию, совместимую с {\tt
    make}.

\end{itemize}

Однако, мы будем изучать достаточно общие техники, и любой написанный
код, может быть запущен (с небольшими синтаксическими изменениями) на
любой версии ML, и часто, на других функциональных языках.

\section{Запуск ML}

ML уже установлен на рабочий сервер (Thor).  Для того, чтобы
использовать его, вам необходимо поместить каталог с исполняемыми
файлами CAML в переменную среды {\tt PATH}.  Это может быть сделано
следующим образом (предполагая, что вы используете командный процессор
`bash' или что-то из его семейства):

\begin{boxed}
\begin{verbatim}
  PATH="$PATH:/home/jrh13/caml/bin"
  export PATH
\end{verbatim}
\end{boxed}%$

Чтобы не вводить эти команды при каждом заходе на сервер, вы можете
вставить эти команды в конец вашего файла {\tt .bash\_profile}, или
его эквивалента для вашего командного процессора.  Теперь, для
использования CAML в интерактивном режиме, вам просто надо набрать
{\tt camllight}, и программа должна запуститься и выдать приглашение
(`{\tt \#}'):

\begin{boxed}
\begin{verbatim}
  $ camllight
  >       Caml Light version 0.73

  #
\end{verbatim}
\end{boxed}%$

Для того, чтобы выйти из системы, просто наберите {\tt ctrl/d} или
{\tt quit();;} в строке приглашения.  Если вы заинтересованы в
установке CAML Light на ваш собственный компьютер, то вы должны
прочитать следующую Web-страницу для получения подробной информации:

\begin{boxed}
\begin{verbatim}
  http://pauillac.inria.fr/caml/
\end{verbatim}
\end{boxed}

\section{Взаимодействие с ML}

Когда ML выдает вам строку приглашения, вы можете вводить выражения,
завершаемые двумя последовательными знаками ``точка с запятой'', он
будет вычислять их и выдавать результат.  На компьютерном жаргоне
говорят, что ML находится в состоянии ``цикл read-eval-print
(считать-вычислить-напечатать)???'': выражения считываются,
вычисляются и печатаются результаты.  Например, ML может быть
использован как простой калькулятор:

\begin{boxed}
\begin{verbatim}
  #10 + 5;;
  - : int = 15
\end{verbatim}
\end{boxed}

Система не только возвращает ответ, но также выдает  {\em тип}
выражения, который определяется автоматически.  Система может сделать
это, поскольку знает тип встроенного оператора сложения {\tt +}.  С
другой стороны, если для выражения не может быть определен тип, то
система отвергнет его, и постарается выдать сообщение о том, почему
произошла ошибка.  В сложных случаях, сообщения об ошибках  достаточно
тяжело понять.

\begin{boxed}
\begin{verbatim}
  #1 + true;;
  Toplevel input:
  >let it = 1 + true;;
  >             ^^^^
  This expression has type bool,
  but is used with type int.
\end{verbatim}
\end{boxed}

Поскольку ML является функциональным языком, то выражения могут иметь
тип-функцию.  Для $lambda$-выражения $\lamb{x} t[x]$ ML предоставляет
следующий синтаксис~--- {\tt fun x -> t[x]}.  Например, мы можем
определить функцию ``следующий successor'':

\begin{boxed}
\begin{verbatim}
  #fun x -> x + 1;;
  - : int -> int = <fun>
\end{verbatim}
\end{boxed}

Как и в предыдущем примере, тип выражения (сейчас это {\tt int ->
  int}), выводится из выдается на экран.  Однако сама функция не
печатается; система лишь выдает {\tt <fun>}.  Это сделано потому, что
внутреннее представление функций не слишком читабельно.\footnote{CAML
  не хранит их как синтаксические деревья, а компилирует в байт-код.}
Функции применяются к аргументам, также как и в $lambda$-исчислении,
путем комбинирования.  Например:

\begin{boxed}
\begin{verbatim}
  #(fun x -> x + 1) 4;;
  - : int = 5
\end{verbatim}
\end{boxed}

Снова, как в $lambda$-исчислении, применение функции ассоциируется
слева, и вы можете написать карированные функции, используя  то же
самое соглашение по упрощению множественных $\lambda$-выражений (т.е.,
{\tt fun}-й).  Например, все следующие выражения эквивалентны:

\begin{boxed}
\begin{verbatim}
  #((fun x -> (fun y -> x + y)) 1) 2;;
  - : int = 3
  #(fun x -> fun y -> x + y) 1 2;;
  - : int = 3
  #(fun x y -> x + y) 1 2;;
  - : int = 3
\end{verbatim}
\end{boxed}

\section{Связывания и объявления}

Конечно, это не совсем удобно~--- вычислять все выражение за один шаг;
вместо этого, мы можем использовать {\tt let} для связывания полезных
подвыражений с именами. Это может быть сделано следующим образом:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1 in
   successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent Для связывания функций может использоваться более элегантная
конструкция:

\begin{boxed}
\begin{verbatim}
  #let successor x = x + 1 in
  successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent и можно использовать рекурсию, лишь добавлением ключевого
слова {\tt rec}:

\begin{boxed}
\begin{verbatim}
  #let rec fact n = if n = 0 then 1
                    else n * fact(n - 1) in
   fact 6;;
  - : int = 720
\end{verbatim}
\end{boxed}

Использованием {\tt and}, мы можем сделать несколько связываний
одновременно, и определить взаимно рекурсивные функции. Например, вот
две простых, хотя сильно неэффективных, функций, которые определяют,
является ли натуральное число четным или нечетным:

\begin{boxed}
\begin{verbatim}
  #let rec even n = if n = 0 then true else odd (n - 1)
       and odd n  = if n = 0 then false else even (n - 1);;
  even : int -> bool = <fun>
  odd : int -> bool = <fun>
  #even 12;;
  - : bool = true
  #odd 14;;
  - : bool = false
\end{verbatim}
\end{boxed}

В действительности, любое связывание может быть сделано отдельно от
его применения.  ML помнит набор связанных переменных и пользователь
может пополнять данный набор интерактивно.  Просто уберите {\tt in} и
завершите фразу двойной точкой с запятой:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1;;
  successor : int -> int = <fun>
\end{verbatim}
\end{boxed}

\noindent После этого объявления, любая последующая фраза может
использовать функцию {\tt successor}, например:

\begin{boxed}
\begin{verbatim}
  #successor 11;;
  - : int = 12
\end{verbatim}
\end{boxed}

Заметьте, что мы не делаем {\em присвоений} {\em переменных}.  Каждое
связывание выполняется только раз, когда система анализирует введенные
данные; оно не может быть повторено или изменено.  Оно может быть
перезаписано новым определением с тем же именем, но это не присвоение,
в своем обычном значении, поскольку последовательность событий связана
только с процессом {\em компиляции}, а не с динамикой {\em выполнения}
программы.  Конечно, отходя от интерактивного получения ответа от
системы, мы можем полностью заменить все двойные точки с запятой,
записанные после объявлений, на {\tt in} и вычислить все за раз.  В
этом примере мы можем увидеть, что переписывание определений в
действительности соответствует определению новой локальной переменной,
которая ``прячет'' предыдущую, ``охватывающую'' переменную, в
соответствии с обычными правилами $lambda$-исчисления.  Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let y = 2;;
  y : int = 2
  #let x = 3;;
  x : int = 3
  #x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

\noindent является тем же самым, что и:

\begin{boxed}
\begin{verbatim}
  #let x = 1 in
   let y = 2 in
   let x = 3 in
   x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

Обязательно заметьте, что следуя $lambda$-исчислению, связывание
переменных является {\em статическим}, например, первое связывание
{\tt x} используется до того, как будет сделано новое связывание, и
любое его использование до нового определения, не будет затронуто
новым определением.  Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let f w = w + x;;
  f : int -> int = <fun>
  #let x = 2;;
  x : int = 2
  #f 0;;
  - : int = 1
\end{verbatim}
\end{boxed}

Первые версии LISP, однако, использовали {\em динамическое}
связывание, когда переопределение переменной также распространялось на
предыдущие использования этой переменной, так что аналогичная
последовательность команд, должна будет вернуть число 2.  В
действительности это считалось ошибкой, но скоро программисты начали
использовать эту возможность.  Это означало, что когда некоторая
низкоуровневая функция изменялась, то изменения распространялись на
все ее применения в других функциях без необходимости в их
перекомпиляции.  Эта возможность продолжала существовать долгое время
во многих диалектах LISP, но в конечном счете победила идея, что
статическое связывание лучше.  В Common LISP по умолчанию используется
статическое связывание, но динамическое связывание можно разрешить,
если необходимо, используя ключевое слово {\tt special}.

\section{Полиморфические функции}

Мы можем определить полиморфические функции, такие как оператор
тождественного отображения:

\begin{boxed}
\begin{verbatim}
  #let I = fun x -> x;;
  I : 'a -> 'a = <fun>
\end{verbatim}
\end{boxed}

ML печатает переменные типов (??? type variables) как {\tt 'a}, {\tt
  'b} и~т.д.  Они должны быть ASCII-представлением для $\alpha$,
$\beta$ и~т.д.  Мы можем использовать полиморфическую функцию с
разными типами:

\begin{boxed}
\begin{verbatim}
  #I true;;
  - : bool = true
  #I 1;;
  - : int = 1
  #I I I I 12;;
  - : int = 12
\end{verbatim}
\end{boxed}

В данном примере каждое использование {\tt I} имеет отличающийся тип,
и интуитивно соотносится к отдельной функции.  Давайте определим все
комбинаторы:

\begin{boxed}
\begin{verbatim}
  #let I x = x;;
  I : 'a -> 'a = <fun>
  #let K x y = x;;
  K : 'a -> 'b -> 'a = <fun>
  #let S f g x = (f x) (g x);;
  S : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c = <fun>
\end{verbatim}
\end{boxed}

Заметьте, что система сохраняет пути передачи типов, хотя, даже в
последнем случае, они достаточно сложные.  Теперь, вспоминая, что $I =
S\; K\; K$; давайте попробуем сделать это на ML:\footnote{Мы отмечаем,
  что с точки зрения отсутствия типов, $S\; K\; A = I$ для любого $A$.
  Однако, читатель может попробовать, например, $S\; K\; S$ и
  убедиться, что основной тип, является менее общим, чем ожидалось.}

\begin{boxed}
\begin{verbatim}
  #let I' = S K K;;
  I' : '_a -> '_a = <fun>
\end{verbatim}
\end{boxed}

\noindent Выражение имеет правильный тип,\footnote{Игнорируйте
  подчеркивания.  Это связано с типизированием императивных
  возможностей, и мы обсудим это позже.} и может быть легко проверено
на конкретных случаях, например:

\begin{boxed}
\begin{verbatim}
  #I' 3 = 3;;
  - : bool = true
\end{verbatim}
\end{boxed}

В приведенных примерах полиморфических функций, система очень быстро
выводит наиболее общий тип для каждого выражения, и тип, который она
выводит, является простым.  Это обычно и происходит на практике, но
существуют патологические случаи, например, следующий пример,
приведенный в \citeN{mairson-ml}.  Тип этого выражения вычисляется
около 10 секунд, и занимает более 4000 строк на 80-символьном
терминале.

\begin{boxed}
\begin{lstlisting}
  let pair x y = fun z -> z x y in
  let x1 = fun y -> pair y y in
  let x2 = fun y -> x1(x1 y) in
  let x3 = fun y -> x2(x2 y) in
  let x4 = fun y -> x3(x3 y) in
  let x5 = fun y -> x4(x4 y) in
  x5(fun z -> z);;
\end{lstlisting}
\end{boxed}

Мы сказали, что программист на ML никогда не вводит тип.  Это правда в
том смысле, что ML уже выделит наиболее общий тип для выражения.
Однако, иногда бывает полезно {\em ограничить} вывод типа.  Это не
заставит работать код, который до этого не работал, но может
использоваться как документация для понимания того, для чего этот код
предназначен; также возможно использовать более короткие синонимы для
сложных типов.  Ограничение типа может быть задано в ML путем
добавления {\em аннотации типа} после некоторого выражения(й).
Аннотации типов состоят из двоеточия, за которым указан тип.  Обычно
не имеет значения то, где эти аннотации добавлены, если они есть, то
они заставляют использовать соответствующие ограничения.  Например,
вот несколько альтернативных вариантов ограничения функции
идентичности к типу {\tt int -> int}:

\begin{boxed}
\begin{verbatim}
  #let I (x:int) = x;;
  I : int -> int = <fun>
  #let I x = (x:int);;
  I : int -> int = <fun>
  #let (I:int->int) = fun x -> x;;
  I : int -> int = <fun>
  #let I = fun (x:int) -> x;;
  I : int -> int = <fun>
  #let I = ((fun x -> x):int->int);;
  I : int -> int = <fun>
\end{verbatim}
\end{boxed}

\section{Эквивалентность функций}

Вместо сравнения действий $I$ и $I'$ на отдельные аргументы, такие как
$3$, может показаться, что мы можем разрешить данный вопрос путем
сравнения самих функций.  Однако, это не работает:

\begin{boxed}
\begin{verbatim}
  #I' = I;;
  Uncaught exception: Invalid_argument "equal: functional value"
\end{verbatim}
\end{boxed}

В общем, {\em запрещено} сравнивать функции, хотя существует несколько
специальных случаев, когда функции явно являются одинаковыми, приводя
к получению {\tt true}:

\begin{boxed}
\begin{verbatim}
  #let f x = x + 1;;
  f : int -> int = <fun>
  #let g x = x + 1;;
  g : int -> int = <fun>
  #f = f;;
  - : bool = true
  #f = g;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #let h = g;;
  h : int -> int = <fun>
  #h = f;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #h = g;;
  - : bool = true
\end{verbatim}
\end{boxed}

Почему существуют эти ограничения?  Разве в ML функции не являются
объектами высшего порядка?  Да, но к сожалению, (extensional)
эквивалентность функций не вычислима.  Это следует из различных
классических теорем в теории рекурсии, таких как {\em Неразрешимости
  проблемы остановки (unsolvability of the halting problem)} and {\em
  Теорема Райса (Rice's theorem)}.\footnote{Вы увидете доказательства
  в курсе теории вычеслений.  Теорема Райса~--- результат чрезвычайно
  сильной неразрешимости, что предполагает, что {\em любое}
  нетривиальное свойство функции, соответствующей программе,
  невычислимо из ее текста.  Отличной книгой по теории вычислений
  является~\citeN{davis-weyuker}.}  Позвольте нам дать конкретный
пример, почему это может быть так.  Это все еще открытая проблема~---
будет ли следующая функция завершена для всех ее аргументов,
предположение, что это так, известно как {\em Гипотеза Коллатца
  (Collatz conjecture)}:\footnote{Хороший обзор этой проблемы, и
  попытки решить ее, приведены в~\citeN{lagarias-collatz}.  Честно
  говоря, мы должны использовать целые числа с неограниченной
  точностью, а не машинную арифметику.  Позже мы увидим как это
  сделать.}

\begin{boxed}
\begin{verbatim}
  #let rec collatz n =
     if n <= 1 then 0
     else if even(n) then collatz(n / 2)
     else collatz(3 * n + 1);;
  collatz : int -> int = <fun>
\end{verbatim}
\end{boxed}

Что ясно, хотя, что если оно завершается, то возвращает~$0$. Теперь
рассмотрим следующую тривиальную функцию:

\begin{boxed}
\begin{verbatim}
  #let f (x:int) = 0;;
  f : int -> int = <fun>
\end{verbatim}
\end{boxed}

Решением уравнения {\tt collatz = f}, компьютер должен подтвердить
гипотезу Коллатца.  Очень легко придумать другие примеры для открытых
математических проблем.

Представляется возможным перехватить применение оператора
эквивалентности к функциям и типам, построенных из них, на этапе
проверки типов, а не в момент выполнения.  Типы, которые не вовлекают
использование функций такими способами, известны как {\em типы
  эквивалентности (equality types)}, поскольку всегда возможно
протестировать объекты таких типов на эквивалентность.  С другой
стороны, это делает систему типов более сложной.  Однако, некоторые
могут аргументировать, что статическая проверка типов должна быть
расширена насколько это возможно.

\section*{Дополнительная литература}

Много книг о функциональном программировании содержат информацию об
общих вещах, которые мы обсуждали, таких как стратегии вычислений.
Хорошее элементарное введение в CAML Light и функциональное
программирование можно найти в~\citeN{mauny-tutorial}.
\citeN{paulson-ml}~также является хорошей книгой, хотя основывается на
Standard~ML.

\section*{Примеры}

\begin{enumerate}

\item Предположим, что `функция-условие', определенная {\tt ite(b,x,y)
    = if b then x else y} является функцией, которая может работать с
  аргументами типа {\tt bool}.  Существует ли способ написать функцию
  факториала?

\item Используйте правила типизирования приведенные в предыдущей главе
  для того, чтобы вывести формальное доказательство, что
  комбинатор~$S$ имеет тот тип, который выдается~ML.

\item Напишите простую, рекурсивно определенную функцию для возведения
  в степень целых чисел, т.е. вычисляющую $x^n$ для $n \geq 0$.
  Напишите две функции на ML, эквивалентность которых соответствует
  истинности последней теоремы Ферма: не существует целых чисел $x$,
  $y$, $z$ и натурального числа $n > 2$, так что $x^n + y^n = z^n$, за
  исключением тривиального случая, когда $x = 0$ или $y = 0$.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
