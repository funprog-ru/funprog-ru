\documentclass{fp-slides}

\begin{document}

%%%%%%%%%%%%%%% Define code blocks

\defverbatim[colored]\factCcode{
  \begin{lstlisting}[frame=single,language=C]
    int fact(int n)
    { int x = 1;
      while (n > 0)
      { x = x * n;
        n = n - 1;
      }
      return x;
    }
  \end{lstlisting}}

\defverbatim[colored]\DefRecExpr{
  \begin{lstlisting}[frame=single]
    #type term = Var of string
               | Const of string
               | Fn of string * (term list);;
    Type term defined.
  \end{lstlisting}}


\defverbatim[colored]\UsingExpr{
  \begin{lstlisting}[frame=single]
  Fn("-",
    [Fn("/",[Fn("sin",[Fn("+",[Var "x";
                               Var "y"])]);
             Fn("cos",[Fn("-",[Var "x";
                               Fn("exp",
                                  [Var "y"])])])]);
     Fn("ln",[Fn("+",[Const "1"; Var "x"])])]);;
  \end{lstlisting}}


\defverbatim[colored]\KeepPrecCodeOne{
  \begin{lstlisting}[frame=single]
  #let infixes =
     ["+",10; "-",10; "*",20; "/",20];;
  \end{lstlisting}}


\defverbatim[colored]\KeepPrecCodeTwo{
  \begin{lstlisting}[frame=single]
  #let rec assoc a ((x,y)::rest) =
     if a = x then y else assoc a rest;;
  \end{lstlisting}}


\defverbatim[colored]\KeepPrecCodeThree{
  \begin{lstlisting}[frame=single]
  #let get_precedence s = assoc s infixes;;
  \end{lstlisting}}

\defverbatim[colored]\PrecModifCode{
  \begin{lstlisting}[frame=single]
  #let infixes =
     ref ["+",10; "-",10; "*",20; "/",20];;
  ...
  #let get_precedence s =
     assoc s (!infixes);;
  get_precedence : string -> int = <fun>
  #get_precedence "^";;
  Uncaught exception: Match_failure
  #infixes := ("^",30)::(!infixes);;
  - : unit = ()
  #get_precedence "^";;
  - : int = 30
  \end{lstlisting}}


\defverbatim[colored]\FindInfixCodeOne{
  \begin{lstlisting}[frame=single]
  #let is_infix s =
     try get_precedence s; true
     with _ -> false;;
  \end{lstlisting}}


\defverbatim[colored]\FindInfixCodeTwo{
  \begin{lstlisting}[frame=single]
  #let can f x =
     try f x; true
     with _ -> false;;
  can : ('a -> 'b) -> 'a -> bool = <fun>
  #let is_infix = can get_precedence;;
  is_infix : string -> bool = <fun>
  \end{lstlisting}}


\defverbatim[colored]\PrintCode{
  \begin{lstlisting}[frame=single]
  #let rec string_of_term prec =
     fun (Var s) -> s
       | (Const c) -> c
       | (Fn(f,args)) ->
         if length args = 2 & is_infix f then
           let prec' = get_precedence f in
           let s1 = string_of_term prec'
                      (hd args)
           and s2 = string_of_term prec'
                      (hd(tl args)) in
           let ss = s1^" "^f^" "^s2 in
           if prec' <= prec then "("^ss^")" else ss
         else
           f^"("^(string_of_terms args)^")"
   and string_of_terms t =
     match t with
         [] -> ""
       | [t] -> string_of_term 0 t
       | (h::t) -> (string_of_term 0 h)^","^
                   (string_of_terms t);;
  \end{lstlisting}}

  

\defverbatim[colored]\PrintInstCode{
  \begin{lstlisting}[frame=single]
  ##open "format";;
  #let print_term s =
     open_hvbox 0;
     print_string
      ("`"^(string_of_term 0 s)^"`");
     close_box();;
  print_term : term -> unit = <fun>
  #install_printer "print_term";;
  - : unit = ()
\end{lstlisting}}


\defverbatim[colored]\BeforeAfterCode{
  \begin{lstlisting}[frame=single]
  #t;;
  t : term =
   Fn
    ("-",
     [Fn
       ("/",
        [Fn ("sin", [Fn ("+", [Var "x"; Var "y"])]);
         Fn ("cos", [Fn ("-", [Var "x"; Fn ("exp",
                                      [Var "y"])])])]);
      Fn ("ln", [Fn ("+", [Const "1"; Var "x"])])])
  #install_printer "print_term";;
  - : unit = ()
  #t;;
  t : term = `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`
  #let x = t;;
  x : term = `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`
  #(x,t);;
  - : term * term =
  `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`,
  `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`
  #[x; t; x];;
  - : term list =
   [`sin(x + y) / cos(x - exp(y)) - ln(1 + x)`;
    `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`;
    `sin(x + y) / cos(x - exp(y)) - ln(1 + x)`]
  \end{lstlisting}}


\defverbatim[colored]\DiffCode{
  \begin{lstlisting}[frame=single]
  let rec differentiate x tm = match tm with
    Var y -> if y = x then Const "1" else Const "0"
  | Const c -> Const "0"
  | Fn("-",[t]) -> Fn("-",[differentiate x t])
  | Fn("+",[t1;t2]) -> Fn("+",[differentiate x t1;
                                differentiate x t2])
  | Fn("-",[t1;t2]) -> Fn("-",[differentiate x t1;
                                differentiate x t2])
  | Fn("*",[t1;t2]) ->
     Fn("+",[Fn("*",[differentiate x t1; t2]);
             Fn("*",[t1; differentiate x t2])])
  | Fn("inv",[t]) -> chain x t
     (Fn("-",[Fn("inv",[Fn("^",[t;Const "2"])])]))
  | Fn("^",[t;n]) -> chain x t
    (Fn("*",[n; Fn("^",[t; Fn("-",[n; Const "1"])])]))
  | Fn("exp",[t]) -> chain x t tm
  | Fn("ln",[t]) -> chain x t (Fn("inv",[t]))
  | Fn("sin",[t]) -> chain x t (Fn("cos",[t]))
  | Fn("cos",[t]) -> chain x t
     (Fn("-",[Fn("sin",[t])]))
  | Fn("/",[t1;t2]) -> differentiate x
     (Fn("*",[t1; Fn("inv",[t2])]))
  | Fn("tan",[t]) -> differentiate x
     (Fn("/",[Fn("sin",[t]); Fn("cos",[t])]))
  and chain x t u =  Fn("*",[differentiate x t; u]);;
  \end{lstlisting}}


\defverbatim[colored]\DiffSample{
 \begin{lstlisting}[frame=single]
  #let t1 = Fn("sin",[Fn("*",[Const "2";
                              Var "x"])]);;
  t1 : term = `sin(2 * x)`
  #differentiate "x" t1;;
  - : term = `(0 * x + 2 * 1) * cos(2 * x)`
  #let t2 = Fn("tan",[Var "x"]);;
  t2 : term = `tan(x)`
  #differentiate "x" t2;;
  - : term =
   `(1 * cos(x)) * inv(cos(x)) +
    sin(x) * ((1 * -(sin(x))) *
    -(inv(cos(x) ^ 2)))`
  #differentiate "y" t2;;
  - : term =
   `(0 * cos(x)) * inv(cos(x)) +
    sin(x) * ((0 * -(sin(x))) *
    -(inv(cos(x) ^ 2)))`
\end{lstlisting}}


\defverbatim[colored]\SimplCodeOne{
 \begin{lstlisting}[frame=single]
  #let simp = fun
    (Fn("+",[Const "0"; t])) -> t
  | (Fn("+",[t; Const "0"])) -> t
  | (Fn("-",[t; Const "0"])) -> t
  | (Fn("-",[Const "0"; t])) -> Fn("-",[t])
  | (Fn("+",[t1; Fn("-",[t2])])) -> Fn("-",[t1; t2])
  | (Fn("*",[Const "0"; t])) -> Const "0"
  | (Fn("*",[t; Const "0"])) -> Const "0"
  | (Fn("*",[Const "1"; t])) -> t
  | (Fn("*",[t; Const "1"])) -> t
  | (Fn("*",[Fn("-",[t1]); Fn("-",[t2])])) ->
       Fn("*",[t1; t2])
  | (Fn("*",[Fn("-",[t1]); t2])) ->
       Fn("-",[Fn("*",[t1; t2])])
  | (Fn("*",[t1; Fn("-",[t2])])) ->
       Fn("-",[Fn("*",[t1; t2])])
  | (Fn("-",[Fn("-",[t])])) -> t
  | t -> t;;
\end{lstlisting}}


\defverbatim[colored]\SimplSampleOne{
  \begin{lstlisting}[frame=single]
    #let rec dsimp = fun
     (Fn(fn,args)) ->
          simp(Fn(fn,map dsimp args))
   | t -> simp t;;
 \end{lstlisting}}


\defverbatim[colored]\SimplSampleTwo{
  \begin{lstlisting}[frame=single]
  #dsimp(differentiate "x" t1);;
  - : term = `2 * cos(2 * x)`
  #dsimp(differentiate "x" t2);;
  - : term = `cos(x) * inv(cos(x)) +
              sin(x) *
              (sin(x) * inv(cos(x) ^ 2))`
  #dsimp(differentiate "y" t);;
  - : term = `0`
 \end{lstlisting}}

%%%%%%%%%%%%%%%


\frame{\titlepage}

\section*{Лекция 9. Примеры на ML: Символьное Дифференцирование}

\frame{
  \frametitle{Темы}
  \begin{itemize}
  \item Символьные вычисления
    %\item Symbolic computation
    \maybepause

  \item Представление данных
         %\item Data representation
    \maybepause

  \item Система вывода
         %\item Prettyprinting
    \maybepause

  \item Дифференцирование
         %%\item Differentiation
    \maybepause

  \item Упрощение посредством переписывания
         %%\item Simplification by rewriting
    \maybepause

  \end{itemize}
}


\frame{
  \frametitle{ Символьные вычисления }

  Сейчас мы обсудим приложения, в которых проводятся манипуляции над
  математическими {\em выражениями }, в общем случае содержащими переменные.

  %%This covers applications where manipulation of mathematical 
  %%{\em expressions},in general containing variables, is emphasized at the
  %%expense of actual numerical calculation.

  Есть несколько удачных <<систем компьютерной алгебры>>, таких как 
  Axiom, Maple и Mathematica, все они могут выполнять определённые символьные 
  операции, полезные в математической работе.

  %%There are several successful `computer algebra systems' such as
  %%Axiom, Maple and Mathematica, which can do certain symbolic operations that 
  %%are useful in mathematics.

  Примеры таких операций: разложение полиномов, дифференцирование и 
  интегрирование  выражений.

  %%Examples include factorizing polynomials and differentiating and integrating
  %%expressions.

  Мы покажем, как ML может использоваться для подобных задач. Давайте рассмотрим 
  задачу символьного дифференцирования.

  %%We will show how ML can be used for such applications. Our example will be
  %%symbolic differentiation.

  Это проиллюстрирует все типичные части систем символьных вычислений: 
  представление данных, внутренние алгоритмы, разбор и вывод результатов.

  %%This will illustrate all the typical components of symbolic computation
  %%systems: data representation, internal algorithms, parsing and  
  %%prettyprinting.

}


\frame{
  \frametitle{ Представление данных }

  Мы  будем рассматривать выражения, которые строятся из переменных, констант  
  и $n$-арных операторов.

  %%We will allow mathematical expressions to be built up from variables and
  %%constants by the application of $n$-ary operators.

  Следовательно, мы задаём рекурсивный тип следующим образом:

  %%Therefore we define a recursive type as follows:

  \DefRecExpr 

  Например, выражение \alert{$sin(x + y) / cos(x - exp(y)) - ln(1 + x)$} 
  представляется:

  %%For example the expression \alert{$sin(x + y) / cos(x - exp(y)) - ln(1 + x)$} 
  %%is represented by:
 
  \UsingExpr 

}


\frame{
  \frametitle{ Нам требуется разбор и печать }

  Чтение и запись выражений в сыром виде довольно неудобны. Это общая проблема
  для всех систем символьных вычислений. Обычно требуются:
 
  %%Reading and writing expressions in their raw form is rather unpleasant. 
  %%This is a general problem in all symbolic computation systems. Typically one 
  %%wants:

  \begin{itemize}

  \item {\em Парсер}, принимающий ввод в человеко - читаемой форме,
  и транслирующий его во внутренние структуры.

  %%\item A {\em parser} to accept input in human-readable form and translate it
  %%into the internal representation 
  
  \item {\em Система вывода}, переводящая вывод из внутреннего представления
  в форму, удобную для пользователя.

  \end{itemize}

  Мы будем использовать синтаксический разбор как ещё один важный пример  
  функционального программирования, поэтому отложим обсуждение этого вопроса  
  на некоторое время. 

  %%We will use parsing as another major example of functional programming, so
  %%we will defer that for now.

  Однако сейчас мы напишем простенькую систему вывода для наших выражений.

  %%However we will now write a simple printer for our expressions.

}


\frame{
  \frametitle{ Вывод выражений }

  Как мы хотим печатать выражения? 
   
  %%How do we want to print expressions?

  \begin{itemize}

  \item Переменные и константы записываются по их именам.

  %%\item Variables and constants are just written as their names.

  \item Обычные $n$-арные функции, выводятся в виде 
  \alert{$f(x_1,\ldots,x_n)$}, т.е. записывается имя функции и рядом, в скобках
  список аргументов.

  %%\item Ordinary $n$-ary functions applied to arguments are written by
  %%juxtaposing the function and a bracketed list of arguments, e.g. {\red
  %%$f(x_1,\ldots,x_n)$}.

  \item Инфиксные бинарные функции, такие как \alert{$+$} записываются между
  своими аргументами.

  %%\item Infix binary functions like \alert{$+$} are written in between their
  %%arguments.

  \item Скобки используются по необходимости.
  
  %%\item Brackets are used where necessary for disambiguation.

  \item В целях сокращения использования скобок, для инфиксных операторов  
  вводится понятие приоритета.  

  %%\item Infix operators have a notion of precedence to reduce the need for
  %%brackets.

  \end{itemize}

}


\frame{
  \frametitle{ Сохранение приоритета }

  Мы можем завести список бинарных операторов с их приоритетами, вроде 
  следующего:
  
  %%We can have a list of binary operators together with their precedences,
  %%e.g.

  \KeepPrecCodeOne

  Списки такого вида, связывающие значения с ключами, называются {\em 
  ассоциативными списками}. Для того чтобы получить значение по ключу, 
  используется следующая функция:

  %%This sort of list, associating data with keys, is called an {\em association
  %%list}. To get the data associated with a key we use the following:

  \KeepPrecCodeTwo
  
  В нашем случае, мы определяем:

  %%In our case, we define:

  \KeepPrecCodeThree
  
  Этот алгоритм линейного поиска неэффективен, но прост и подходит для простых 
  примеров. Для неучебных приложений больше подойдёт использование хеширования.

  %%This procedure of linear search is inefficient, but it is simple and adequate
  %%for small examples. Techniques like hashing are better for heavyweight
  %%applications.

}


\frame{
  \frametitle{ Делаем приоритеты изменяемыми }

  Из - за статического связывания, изменение списка инфиксных операторов не 
  меняет {\tt get\_precedence}.

  %%Because of static binding, changing the list of infixes does not change
  %%{\tt get\_precedence}.

  Однако, мы можем сделать {\tt infixes} ссылкой, а значит изменяемым:

  %%However we can make {\tt infixes} a reference instead and then it is
  %%modifiable:

  \PrecModifCode 

  Такое решение не является чисто функциональным, но, возможно, более 
  естественно.
  %% BUG# Может всё же стоит заменить код на pure functional way, во избежание
  %% использования ссылок до их определения??? -- dimiii

  %%This setup is not purely functional, but is perhaps more natural.

}


\frame{
  \frametitle{ Определение инфиксных операторов }

  Мы будем считать оператор инфиксным, только если он встречается в списке 
  {\tt infixes} с приоритетом. Мы можем записать:

  %%We will treat an operator as infix just if it appears in the list of infixes
  %%with a precedence. We can do:

  \FindInfixCodeOne

  
  \noindent поскольку {\tt get\_precedence} не определена на   
  неинфиксных операторах, и, поэтому, выбросит исключение. Альтернативный (~и~более правильный~) 
  способ использует вспомогательную функцию {\tt can}, 
  которая проверяет успешность применения её первого аргумента ко второму:
  
  %%\noindent because {\verb+get_precedence+} fails on non-infixes. An
  %%alternative coding is to use an auxiliary function {\tt can} which 
  %%finds out whether the application of its first argument to its seconds 
  %%succeeds::
  
 \FindInfixCodeTwo
}



\frame{
  \frametitle{ Печать: обсуждение }

  Печать задаётся двумя взаимно рекурсивными функциями.

  %%The printer consists of two mutually recursive functions.

  Функция {\tt string\_of\_term} принимает два аргумента. Первый - это
  <<приоритетный оператор>>,  а второй - терм.

  %%The function {\verb+string_of_term+} takes two arguments. The first 
  %%is a `currently active precedence', and the second is the term.

  Например, при печати правого аргумента из \alert{x * (y + z)},
  приоритетным оператором является {\alert *} - произведение. При этом, если
  второй аргумент является аппликацией инфиксного оператора (в нашем случае 
  {\alert +}), и меньшего приоритета, то он окружается скобками.

  %%For example, in printing the right-hand argument of {\tt x * (y + 
  %%z)},  the currently active precedence is the precedence of {\tt *}.   
  %%If the function prints an application of an infix operator (here {\tt
  %% +}), it puts brackets round it unless its own precedence is higher.

  Вторая функция через запятую печатает список термов. Это нужно для вывода 
  списка аргументов  функций вида \alert{$f(x_1,\ldots,x_n), n > 2$}.
  
  %%We have a second, mutually recursive, function, to print a list of terms
  %%separated by commas. This is for the argument lists of non-unary and 
  %%non-infix  functions of the form \alert{ $f(x_1,\ldots,x_n)$}.
}


\frame{
  \frametitle{ Печать: код }

  \PrintCode 
}

\frame{
  \frametitle{ Печать: установка }

  CAML Light поддерживает установку системы печати, задаваемой пользователем.

  %%CAML Light has special facilities for installing user-defined printers in 
  %%the toplevel read-eval-print loop.

  После того, как система печати установлена пользователем, работа в 
  интерпретаторе будет проходить через неё и каждый терм, введённый 
  пользователем, будет выводится ею.

  %%Once our printer is installed, anything of type {\tt term} will 
  %%be printed using it.

  Для взаимодействия с интерпетатором мы используем некоторые специальные  
  функции из библиотеки {\t format}  CAML  Light.

  %%We use some special functions from the CAML Light {\tt format} library to 
  %%make sure that our printer interacts with the toplevel loop.

  \PrintInstCode 

}


\frame{
  \frametitle{ До и после }

  \BeforeAfterCode 

}


\frame{
  \frametitle{ Дифференцирование: алгоритм }

  Есть хорошо известные (изучаемые в школе) правила дифференцирования сложных  
  выражений.

  %%There is a well-known method (taught in schools) to differentiate 
  %%complicated expressions.

  \begin{itemize}

  \item Если выражение - одна из элементарных функций одного аргумента, например 
  \alert{$sin(x)$}, 
  то результат дифференцирования - известная производная этой функции.

  %\item If the expression is one of the standard functions applied to an
  %argument, e.g. \alert{$sin(x)$}, return the known derivative.

  \item Если выражение представимо в форме \alert{$f(x) + g(x)$}, то по правилу 
  суммы, результат дифференцирования есть  \alert{$f'(x) + g'(x)$}. 
  Аналогично для разности.

  %\item If the expression is of the form \alert{$f(x) + g(x)$} then apply 
  %the rule for sums, returning \alert{$f'(x) + g'(x)$}. Likewise for 
  %subtraction etc.

  \item Если выражение задано в форме \alert{$f(x) * g(x)$}, применяется {\em правило
  Лейбница}, т.е. возвращается \alert{$f'(x) * g(x) + f(x) * g'(x)$}.

  %\item If the expression is of the form \alert{$f(x) * g(x)$} then apply the
  %product rule, i.e. return \alert{$f'(x) * g(x) + f(x) * g'(x)$}.

  \item Если выражение является одной из композицией стандартных функций:  
  \alert{$f(g(x))$}, то применяется правило последовательного 
  дифференцирования, результат которого: \alert{$g'(x) * f'(g(x))$}.

  %\item If the expression is one of the standard functions applied to a 
  %composite argument, say \alert{$f(g(x))$} then apply the Chain Rule and so  
  %give \alert{$g'(x) * f'(g(x))$}.

  \end{itemize}

  Эти правила легко переводятся в рекурсивные алгоритмы.

}


\frame{
  \frametitle{ Дифференцирование: код }

  \DiffCode 

}


\frame{
  \frametitle{ Примеры дифференцирования }

  Попробуем несколько примеров:

  %%Let's try a few examples:

  \DiffSample 
}


\frame{
  \frametitle{ Упрощение выражений }

  Кажется, всё хорошо работает, но при этом не делается некоторых очевидных
  упрощений, таких как: \alert{$0 * x = 0$}. Так получается частично от того, 
  что  мы применяем рекурсивные правила, такие как правило последовательного 
  дифференцирования композиции, даже в тривиальных случаях. 
  Запишем функцию, выполняющую упрощение:

  %%It seems to work OK, but it isn't making certain obvious simplifications,
  %%like \alert{$0 * x = 0$}. These arise partly because we apply the recursive
  %%rules like the chain rule even in trivial cases. We'll write a simplifier:

  \SimplCodeOne
}


\frame{
  \frametitle{ Примеры упрощения }

  Мы должны применить {\tt simp} рекурсивно, по индукции:
  
  %We need to apply {\tt simp} recursively, bottom-up:

  \SimplSampleOne
  
  Теперь мы получаем лучшие результаты:
  
  %Now we get better results:
  
  \SimplSampleTwo
  
  Есть и другие способы упрощения, например  
  \alert{$cos(x) * inv(cos(x)) =  1$}. 
  Хорошее алгебраическое упрощение - это сложная задача!
  
  %%There are still other simplifications to be made, e.g. \alert{$cos(x) *
  %%inv(cos(x)) = 1$}. Good algebraic simplification is a difficult problem!

}


\end{document}


