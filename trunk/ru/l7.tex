\documentclass{fp-slides}

\begin{document}

\defverbatim[colored]\ExampleExp{
  \begin{lstlisting}[frame=single]
   #let rec exp x n =
     if n = 0 then 1
     else x * exp x (n - 1);;
  \end{lstlisting}}

\defverbatim[colored]\ExampleGcd{
  \begin{lstlisting}[frame=single]
  #let rec gcd x y =
       if y = 0 then x
       else gcd y (x mod y);;
  \end{lstlisting}}

\defverbatim[colored]\ExampleAppend{
  \begin{lstlisting}[frame=single]
  #let rec append l1 l2 =
     match l1 with
       [] -> l2
     | (h::t) -> h::(append t l2);;
  \end{lstlisting}}

\defverbatim[colored]\ExampleRev{
  \begin{lstlisting}[frame=single]
  #let rec rev =
     fun [] -> []
       | (h::t) -> append (rev t) [h];;
  rev : 'a list -> 'a list = <fun>
  #rev [1;2;3];;
  - : int list = [3; 2; 1]
  \end{lstlisting}}


\frame{\titlepage}

\section*{Лекция 7. Доказательство корректности программ}

\frame{
  \frametitle{Темы}

  \begin{itemize}
  \item Проблема корректности
    % \item The correctness problem
    \maybepause

  \item Тестирование и верификация
    % \item Testing and verification
    \maybepause

  \item Завершимость и полнота
    % \item Termination and totality
    \maybepause

  \item Вычисление степени и~НОД
    % \item Exponential and gcd
    \maybepause

  \item Конкатенация и обращение списков
    % \item Appending and reversing
    \maybepause

  \end{itemize}

}



\frame{
  \frametitle{Проблема корректности}
  % \heading{The correctness problem}

  Программы пишут, чтобы они выполняли определённую задачу.
  % Programs are written to perform some particular task.

  Однако, программисты знают, что зачастую достаточно сложно написать
  программу, которая делает то, что требуется.
  % However, it is often very hard to write a program that performs
  % its intended function --- as programmers know well.

  На практике, в большинстве объёмных программ есть <<ошибки>>.
  % In practice, most large programs have <<bugs>>.

  Некоторые ошибки безобидны, другие~--- раздражают.
  % Some bugs are harmless, others merely irritating.

  Они могут вызвать финансовые катастрофы или проблемы отношений между
  компаниями (например ошибка Pentium FDIV).
  % They can cause financial and public relations disasters (e.g. the
  % Pentium FDIV bug).

  Иногда ошибки могут быть смертельно опасными.
  % In some situation bugs can be deadly.

  {\color{Green} Питер Ньюман: <<Компьютерные риски>>}
  % {\green Peter Neumann: <<Computer Related Risks>>.}

}

\frame{
  \frametitle{Опасные ошибки}
  % \heading{Dangerous bugs}

  Вот несколько задач, где ошибки могут быть смертельно опасными:
  % Some situations where bugs can be deadly include:

  \begin{itemize}
  \item Электрокардиостимулятор
    % \item Heart pacemakers
    \maybepause

  \item Авиационные автопилоты
    % \item Aircraft autopilots
    \maybepause

  \item Системы управления двигателем и антиблокировочные тормозные
    системы
    % \item Car engine management systems and antilock braking systems
    \maybepause

  \item Приборы радиационной терапии
    % \item Radiation therapy machines
    \maybepause

  \item Системы управления ядерных реакторов
    % \item Nuclear reactor controllers
    \maybepause

  \end{itemize}

  Про такие задачи говорят, что они {\em критичны к наличию ошибок}.
  % These applications are said to be {\em safety critical}.
}

\frame{
  \frametitle{Тестирование и верификация}
  % \heading{Testing and verification}

  Один из хороших способов отыскания ошибок это всестороннее
  тестирование.
  % One good way to track down bugs is through extensive testing.

  Однако, обычно оказывается, что потенциальных вариантов
  использования слишком много, чтобы можно было полностью их все
  проверить, поэтому всё же возможно, что останутся не обнаруженные
  ошибки.
  % But usually there are too many possible situations to try them all
  % exhaustively, so there may still be bugs lying undetected.

  Тестирование программ может быть полезным для демонстрации наличия
  ошибок, но показать их отсутствие оно в состоянии лишь в отдельных
  редких случаях.
  % Program testing can be very useful for demonstrating the presence of bugs, but
  % it is only in a few unusual cases where it can demonstrate their absence.

  Альтернатива тестированию это {\em верификация}, когда мы пытаемся
  {\em доказать}, что программа работает так, как требуется.
  % An alternative is {\em verification}, where we try to {\em prove} that a
  % program behaves as required.

  Рассмотрим простое математическое отношение: \alert{$$
    \Sigma_{n=0}^{n=N} n = \frac{N (N + 1)}{2} $$} Мы можем {\em
    проверить} его для множества определённых значений~$N$, но проще и
  надёжнее {\em доказать} её (по индукции).
  % Consider ordinary mathematical theorems, like
  % \alert{$$ \Sigma_{n=0}^{n=N} n = \frac{N (N + 1)}{2} $$}
  % We can {\em test} this for many particular values of $N$, but it is easier and
  % more satisfactory simply to {\em prove} it (e.g. by induction).

}

\frame{
  \frametitle{Ограничения верификации}
  % \heading{The limits of verification}

  Верификацию можно представить в виде диаграммы:
  % The enterprise of verification can be represented by this diagram:

  {\color{Green}
    \bigskip
    \begin{picture}(140,140)(0,0)
      \put(40,0){\dashbox(150,25){Реализация системы}}
      % \put(40,0){\dashbox(150,25){Actual system}}
      \put(40,40){\framebox(150,25){Математическая модель системы}}
      % \put(40,40){\framebox(150,25){Mathematical model}}
      \put(40,80){\framebox(150,25){Математическая спецификация требований}}
      % \put(40,80){\framebox(150,25){Mathematical specification}}
      \put(40,120){\dashbox(150,25){Требования к системе}}
      % \put(40,120){\dashbox(150,25){Actual requirements}}
      \put(115,25){\vector(0,1){15}}
      \put(115,65){\thicklines \vector(0,1){15}}
      \put(115,105){\vector(0,1){15}}
    \end{picture}}
  \bigskip

  Лишь центральная связь математически точна.  Остальные остаются
  неформальными~--- всё, что мы можем сделать, это постараться сохранять
  их максимально простыми и прозрачными.
  % It is only the central link that is mathematically precise. The others are
  % still informal --- all we can do is try to keep them small.
}





\frame{
  \frametitle{Верификация функциональных программ}
  % \heading{Verifying functional programs}

  Мы уже заметили раньше, что для функциональных программ легче
  проводить формальное доказательство, потому что они напрямую
  соответствуют математическим функциям, которые они представляют.
  % We suggested earlier that functional programs might be easier to
  % reason about formally, because they correspond directly to the
  % mathematical functions that they represent.

  Это спорно, но мы попробуем по крайней мере показать, что
  достаточно легко доказывать простые функциональные программы.
  % This is arguable, but at least we will try to show that reasoning
  % about some simple functional programs is straightforward.

  Но надо помнить, что в основном функциональные программы это {\em
    частичные} функции.  Иногда требуется отдельное доказательство
  завершимости вычислений.
  % We need to remember that, in general, functional programs are {\em partial}
  % functions. Sometimes we need a separate argument to establish termination.

  Часто свойства функций (включая завершимость), определённых
  рекурсивно, можно доказать по индукции в силу двойственности этих
  двух понятий.
  % Often, the proofs proceed by induction, parallelling the
  % definition of the functions involved by recursion.
}

\frame{
  \frametitle{Вычисление степени (1)}
  % \heading{Exponentiation (1)}

  Вспомним следующее простое определение функции потенцирования
  натуральных чисел:
  % Recall the following simple definition of natural number
  % exponentiation:

  \ExampleExp

  Мы докажем, что она удовлетворяет следующей спецификации:
  % We will prove that this satisfies the following specification:

  \alert{Для любого $n \geq 0$ и произвольного~$x$ функция
    $\mbox{exp}\; x\; n$ завершается и $\mbox{exp}\; x\; n = x^n$}
  % \alert{For all $n \geq 0$ and $x$, $\mbox{exp}\; x\; n$ terminates and
  %   $\mbox{exp}\; x\; n = x^n$}

  Функция определена посредством (примитивной) рекурсии.
  % The function is defined by (primitive) recursion.

  Доказательство проводится по (математической) индукции.
  % The proof is by (step-by-step, mathematical) induction.
}
\frame{
  \frametitle{Вычисление степени (2)}
  % \heading{Exponentiation (2)}

  \begin{itemize}
  \item Если \alert{$n = 0$}, то по определению \alert{$\mbox{exp}\;
      x\; n = 1$}.  Так как для любого целого \alert{$x$}, мы имеем
    \alert{$x^0 = 1$}, таким образом базис индукции выполняется.
    % \item If \alert{$n = 0$}, then by definition
    %   \alert{$\mbox{exp}\; x\; n = 1$}.  Since for any integer
    %   \alert{$x$}, we have \alert{$x^0 = 1$}, so the desired fact is
    %   established.
    \maybepause

  \item Допустим что \alert{$\mbox{exp}\; x\; n = x^n$} верно.  Так
    как \alert{$n \geq 0$}, то \alert{$n + 1 \not= 0$} тоже верно.
    Поэтому:
    % \item Suppose we know \alert{$\mbox{exp}\; x\; n = x^n$}.
    %   Because \alert{$n \geq 0$}, we also know \alert{$n + 1 \not=
    %     0$}. Therefore:
    \alert{
      \begin{eqnarray*}
        \mbox{exp}\; x\; (n + 1)   & = & x * \mbox{exp}\; x\; ((n + 1) - 1)     \\
        & = & x * \mbox{exp}\; x\; n                 \\
        & = & x * x^n                                \\
        & = & x^{n + 1}
      \end{eqnarray*}}
    \maybepause
  \end{itemize}
  \qed

  Заметим, что мы приняли \alert{$0^0 = 1$}.  Пример того, как точно
  надо составлять техническую спецификацию!
  % Note that we assume \alert{$0^0 = 1$}, an example of how one must state the
  % specification precisely!
}

\frame{
  \frametitle{Вычисление~НОД (1)}
  % \heading{Greatest common divisor (1)}

  Определим функцию для вычисления НОД двух целых чисел, используя
  алгоритм Евклида.
  % We define a function to calculate the gcd of two integers using
  % Euclid's algorithm.

  \ExampleGcd

  Мы хотим доказать что:
  % We want to prove:

  \alert{Для любых $x$ и $y$, вычисление $\mbox{gcd}\; x\; y$
    завершается с результатом равным НОД($x$, $y$).}
  % \alert{For any integers $x$ and $y$, $\mbox{gcd}\; x\; y$ terminates and returns
  %   a gcd of $x$ and $y$.}

  Тут нам надо быть аккуратными со спецификацией.  Каков НОД двух
  отрицательных чисел?
  % Here we need to be even more careful about the specification. What
  % is a gcd of two negative numbers?
}

\frame{
  \frametitle{Вычисление~НОД (2)}
  % \heading{Greatest common divisor (2)}

  Мы пишем \alert{$x | y$} и говорим <<alert{$x$} делит alert{$y$}>>,
  что означает что \alert{$y$} является целочисленным делителем
  \alert{$x$}, то есть существует такое целое \alert{$d$}, что
  \alert{$y = d x$}.
  % We write \alert{$x | y$}, pronounced <<alert{$x$} divides alert{$y$}>>, to mean
  % that \alert{$y$} is an integral multiple of \alert{$x$}, i.e. there is some
  % integer \alert{$d$} with \alert{$y = d x$}.

  Мы говорим что \alert{$d$} это {\em общий делитель} \alert{$x$} и
  \alert{ $y$} если \alert{$d | x$} и \alert{$d | y$}.
  % We say that \alert{$d$} is a {\em common divisor} of \alert{$x$} and \alert{$y$}
  % if \alert{$d | x$} and \alert{$d | y$}.

  Мы говорим что \alert{$d$} это {\em наибольший} общий делитель если:
  % We say that \alert{$d$} is a {\em greatest} common divisor if:

  \begin{itemize}
  \item Верно \alert{$d | x$} и \alert{$d | y$}
    % \item We have \alert{$d | x$} and \alert{$d | y$}
    \maybepause

  \item Для любого другого \alert{$d'$}, если \alert{$d' | x$} и \alert{$d'
      | y$} то \alert{$d' | d$}.
    % \item For any other integer \alert{$d'$}, if \alert{$d' | x$}
    %   and \alert{$d' | y$} then \alert{$d' | d$}.
    \maybepause

  \end{itemize}

  Заметим, что мы не указываем знак у НОД за исключением случая, когда
  оба \alert{$x$} и \alert{$y$} нули.  Спецификация совершенно не
  привязывает реализацию.
  % Note that unless \alert{$x$} and \alert{$y$} are both zero, we do not specify the
  % sign of the gcd. The specification does not constrain the implementation
  % completely.
}

\frame{
  \frametitle{Вычисление~НОД (3)}
  % \heading{Greatest common divisor (3)}

  Функция {\tt gcd} уже не определена через {\em примитивную}
  рекурсию.
  % Now we come to the proof. The {\tt gcd} function is no longer defined by
  % {\em primitive} recursion.

  На шаге алгоритма Евклида {\tt gcd x y} определена в терминах
  {\tt gcd y (x mod y)}.
  % In fact, {\tt gcd x y} is defined in terms of {\tt gcd y (x mod
  %   y)} in the step case.

  Поэтому мы не прибегаем к пошаговой математической индукции, а
  используем {\em трансфинитную} индукцию по \alert{$|y|$}.
  % We do not, therefore, proceed by step-by-step mathematical induction, but by
  % {\em wellfounded} induction on \alert{$|y|$}.

  Идея в том, что эта величина (часто называемая {\em мера}) убывает в
  ходе рекурсии.  Мы можем использовать это свойство, чтобы доказать
  что вызов функции завершается, а также как опору для трансфинитной
  индукции.
  % The idea is that this quantity (often called a {\em measure}) decreases with
  % each call. We can use it to prove termination, and as a handle for wellfounded
  % induction.

  В запутанных рекурсиях сложно найти подходящее обоснованное
  упорядочение аргументов.  Но в большинстве случаев можно
  использовать этот простой подход <<меры>>.
  % In complicated recursions, finding the right wellfounded ordering on the
  % arguments can be tricky. But in many cases one can use this simple <<measure>>
  % approach.
}

\frame{
  \frametitle{Вычисление~НОД (4)}
  % \heading{Greatest common divisor (4)}

  Теперь мы представим доказательство.  
Возьмём
  некоторого~$n$, что для произвольного значения~$x$ и~$y$ такого,
  что~$|y| < n$ теорема справедлива. Основываясь на этом
  предположении, попробуем доказать, что она справедлива также для
  произвольного~$x$ при~$|y| = n$.  Здесь два частных случая.

  Возьмём произвольное \alert{ $n$}.  Предположим что теорема верна
  для всех аргументов \alert{$x$} и \alert{$y$}, таких что \alert{$|y|
    < n$}, и мы попробуем доказать её для всех \alert{$x$} и
  \alert{$y$}, таких что \alert{$|y| = n$}.  Здесь два случая.
  % Now we come to the proof. Fix some arbitrary \alert{$n$}. We suppose that
  % the theorem is established for all arguments \alert{$x$} and \alert{
  %   $y$} with \alert{$|y| < n$}, and we try to prove it for all \alert{
  %   $x$} and \alert{$y$} with \alert{$|y| = n$}. There are
  % two cases.

  Во-первых, предположим что \alert{$y = 0$}.  Тогда
  \alert{$\mbox{gcd}\; x\; y = x$} по определению.  Очевидно что
  \alert{$x | x$} и \alert{$x | 0$}, поэтому \alert{$x$} и есть общий
  делитель.
  % First, suppose that \alert{$y = 0$}. Then \alert{$\mbox{gcd}\; x\; y
  %   = x$} by definition. Now trivially \alert{$x | x$} and \alert{$x |
  %   0$}, so it is a common divisor.

  Предположим что \alert{$d$} является ещё одним общим делителем, т.е.
  \alert{$d | x$} и \alert{$d | 0$}.  Тогда мы сразу получаем
  \alert{$d | x$}, поэтому \alert{$x$} и есть {\em наибольший} общий
  делитель.
  % Suppose \alert{$d$} is another common divisor, i.e. \alert{$d | x$}
  % and \alert{$d | 0$}. Then immediately we get \alert{$d | x$}, so
  % $x$ is a {\em greatest} common divisor.

  Мы установили первую часть доказательства по индукции.
  % This establishes the first part of the induction proof.
}

\frame{
  \frametitle{Вычисление~НОД (5)}
  % \heading{Greatest common divisor (5)}

  Теперь предположим, что \alert{$y \not= 0$}.  Мы хотим применить
  индуктивное предположение к \alert{$\mbox{gcd}\; y\; (x\;
    \mbox{mod}\; y)$}.
  % Now suppose \alert{$y \not= 0$}. We want to apply the inductive
  % hypothesis to \alert{$\mbox{gcd}\; y\; (x\; \mbox{mod}\; y)$}.

  Для краткости мы будем писать \alert{$r = x\; \mbox{mod}\; y$}.
  Основное свойство функции {\tt mod}, которое мы будем использовать
  это, что для \alert{$y \not= 0$}, найдётся такое целое~\alert{$q$},
  что \alert{$x = q y + r$} и \alert{$|r| < |y|$}.
  % We will write \alert{$r = x\; \mbox{mod}\; y$} for short. The
  % basic property of the {\tt mod} function that we use is that,
  % since \alert{$y \not= 0$}, for some integer \alert{$q$} we have
  % \alert{$x = q y + r$} and \alert{$|r| < |y|$}.

  Поскольку \alert{$|r| < |y|$}, то согласно индуктивному предположению
  \alert{$d = \mbox{gcd}\; y\; (x\; \mbox{mod}\; y)$} является НОД для
  \alert{$y$} и \alert{$r$}.
  % Since \alert{$|r| < |y|$}, the inductive hypothesis tells us that
  % \alert{$d = \mbox{gcd}\; y\; (x\; \mbox{mod}\; y)$} is a gcd of
  % \alert{$y$} and \alert{$r$}.

  Нам осталось лишь показать, что он является НОД также и для
  \alert{$x$} и \alert{$y$}.  Конечно же он общий делитель ибо при
  \alert{$d | y$} и \alert{ $d | r$} имеем \alert{$d | x$} так как
  \alert{$x = q y + r$}.
  % We just need to show that it is a gcd of \alert{$x$} and
  % \alert{$y$}. It is certainly a common divisor, since if \alert{$d
  %   | y$} and \alert{$d | r$} we have \alert{$d | x$}, as \alert{$x
  %   = q y + r$}.

  Теперь допустим \alert{$d' | x$} и \alert{$d' | y$}.  Согласно тому
  же уравнению мы видим, что \alert{$d' | r$}.  Таким образом
  \alert{$d'$} является общим делителем \alert{$y$} и \alert{$r$}, но
  в соответствии с индуктивным предположением получаем \alert{$d' | d$}
  что и требовалось.
  % Now suppose \alert{$d' | x$} and \alert{$d' | y$}. By the same
  % equation, we find that \alert{$d' | r$}. Thus \alert{$d'$} is a
  % common divisor of \alert{$y$} and \alert{$r$}, but then by the
  % inductive hypothesis, \alert{$d' | d$} as required.
}

\frame{
  \frametitle{Конкатенация списков (1)}

  Теперь лучше рассмотрим пример касательно списков, а не чисел.
  Определим:
  % Now consider an example concerning lists rather than numbers.
  % Define:

  \ExampleAppend

  Предполагается, что эта функция для конкатенации (сцепления) двух
  списков.  Мы хотим доказать, что эта операция ассоциативна, т.е. для
  любых трёх списков \alert{$l_1$}, \alert{$l_2$} и \alert{$l_3$}
  имеем свойство: \alert{$$ \mbox{append}\; l_1\; (\mbox{append}\;
    l_2\; l_3) = \mbox{append}\; (\mbox{append}\; l_1\; l_2)\; l_3 $$}
  Мы можем использовать математическую индукцию по длине
  \alert{$l_1$}, но так как функция была задана с помощью структурной
  рекурсии над списками, то естественнее доказывать теорему используя
  {\em структурную индукцию}.
  % This is supposed to join together two lists. We want to prove that the
  % operation is associative, i.e. for any three lists \alert{$l_1$}, \alert{$l_2$}
  % and \alert{$l_3$} we have:
  % \alert{$$ \mbox{append}\; l_1\; (\mbox{append}\; l_2\; l_3) = \mbox{append}\;
  %   (\mbox{append}\; l_1\; l_2)\; l_3 $$}
  % We can proceed by induction on the length of \alert{$l_1$}, but since the
  % function was defined by structural recursion over lists, it is more natural to
  % prove the theorem by {\em structural induction}.

  Принцип такой: если свойство верно для пустого списка и при
  условии что оно верно для \alert{$t$}, то оно также
  верно и для любого \alert{$h::t$} то оно верно вообще
  для любого списка.
  % The principle is: if a property holds for the empty list, and whenever it holds
  % for \alert{$t$} it holds for any \alert{$h::t$}, then it holds for any list.
}

\frame{
  \frametitle{Конкатенация списков (2)}

  Используем структурную индукцию по \alert{$l_1$}.  Нам надо рассмотреть
  два случая.  Сначала, предположим что \alert{$l_1 = []$}.  Тогда мы имеем:
  % We proceed, then, by structural induction on \alert{$l_1$}. There are two cases
  % to consider. First, suppose \alert{$l_1 = []$}. Then we have:

  \alert{\begin{eqnarray*}
      & & \mbox{append}\; l_1\; (\mbox{append}\; l_2\; l_3)           \\
      & = & \mbox{append}\; []\; (\mbox{append}\; l_2\; l_3)          \\
      & = & \mbox{append}\; l_2\; l_3                                 \\
      & = & \mbox{append}\; (\mbox{append}\; []\; l_2)\; l_3          \\
      & = & \mbox{append}\; (\mbox{append}\; l_1\; l_2)\; l_3
    \end{eqnarray*}}

  Что и требовалось.
  % As required.

}

\frame{
  \frametitle{Конкатенация списков (3)}

  Теперь допустим, что \alert{$l_1 = h::t$}.  Мы в праве полагать, что
  для любого \alert{$l_2$} и \alert{$l_3$} выполняется:
  % Now suppose \alert{$l_1 = h::t$}. We may assume that for any \alert{$l_2$}
  % and \alert{$l_3$} we have:
  \alert{$$ \mbox{append}\; t\; (\mbox{append}\; l_2\; l_3) = \mbox{append}\;
    (\mbox{append}\; t\; l_2)\; l_3 $$}
  \noindent Поэтому:
  % \noindent Therefore:
  \alert{\begin{eqnarray*}
      & & \mbox{append}\; l_1\; (\mbox{append}\; l_2\; l_3)           \\
      & = & \mbox{append}\; (h::t)\; (\mbox{append}\; l_2\; l_3)      \\
      & = & h::(\mbox{append}\; t\; (\mbox{append}\; l_2\; l_3))      \\
      & = & h::(\mbox{append}\; (\mbox{append}\; t\; l_2)\; l_3)      \\
      & = & \mbox{append}\; (h::(\mbox{append}\; t\; l_2))\; l_3      \\
      & = & \mbox{append}\; (\mbox{append}\; (h::t)\; l_2)\; l_3      \\
      & = & \mbox{append}\; (\mbox{append}\; l_1\; l_2)\; l_3
    \end{eqnarray*}}
  Теорема доказана.
  % The theorem is proved.
}

\frame{
  \frametitle{Обращение списков (1)}

  Для последнего примера определим функцию обращения списков.
  % For a final example, let us define a function to reverse a list:
  \ExampleRev
  Мы докажем, что для любого списка \alert{$l$} верно следующее:
  % We will prove that for any list \alert{$l$} we have:
  \alert{$$ \mbox{rev} (\mbox{rev}\; l) = l $$}
  Опять же, тут структурная индукция.  Однако, нам потребуются две леммы,
  которые тоже можно доказать с помощью структурной индукции
  (подробности в конспектах):
  % This is again a structural induction. However we require two lemmas, which can
  % also be proved by structural induction (details in the notes):
  \alert{
    \begin{eqnarray*}
      \mbox{append}\; l\; [] & = & l          \\
      \mbox{rev}(\mbox{append}\; l_1\; l_2) & = & \mbox{append}\; (\mbox{rev}\; l_2)\; (\mbox{rev}\; l_1)
    \end{eqnarray*}}
}

\frame{
  \frametitle{Обращение списков (2)}

  Сначала рассмотрим случай, когда \alert{$l = []$}.  Доказательство
  просто:
  % First suppose that \alert{$l = []$}. Then the proof is easy:

  \alert{
    \begin{eqnarray*}
      \mbox{rev}(\mbox{rev}\; l)
      & = & \mbox{rev}(\mbox{rev}\; [])                               \\
      & = & \mbox{rev}\; []                                           \\
      & = & []                                                        \\
      & = & l
    \end{eqnarray*}
  }

  Теперь рассмотрим случай, когда \alert{$l = h::t$}, и мы знаем, что
  % Now suppose that \alert{$l = h::t$} and we know that

  \alert{$$ \mbox{rev}(\mbox{rev}\; t) = t $$}
}

\frame{
  \frametitle{Обращение списков (3)}

  \alert{
    \begin{eqnarray*}
      & & \mbox{rev}(\mbox{rev}\; l)                                  \\
      & = & \mbox{rev}(\mbox{rev}\; (h::t))                           \\
      & = & \mbox{rev}(\mbox{append}\; (\mbox{rev}\; t)\; [h])        \\
      & = & \mbox{append}\; (\mbox{rev}\; [h])\; (\mbox{rev} (\mbox{rev}\; t)) \\
      & = & \mbox{append}\; (\mbox{rev}\; [h])\; t                        \\
      & = & \mbox{append}\; (\mbox{rev}\; (h::[]))\; t                    \\
      & = & \mbox{append}\; (\mbox{append}\; []\; [h])\; t                    \\
      & = & \mbox{append}\; [h]\; t                                           \\
      & = & \mbox{append}\; (h::[])\; t                                       \\
      & = & h::(\mbox{append}\; []\; t)                                       \\
      & = & h::t                                                              \\
      & = & l
    \end{eqnarray*}}

}

\end{document}
