\chapter{Введение}

Программы, написанные на традиционных языках программирования, таких
как FORTRAN, Algol, C и Modula-3, в своей работе опираются на
изменение значений набора переменных, называемого {\em
  состоянием}. Если мы пренебрежём операциями ввода-вывода и
вероятностью того, что программа будет работать постоянно (например,
управляющая система для производства), то мы можем прийти к следующей
абстракции.  Первоначально состояние имеет некоторое значение
$\sigma$, представляющее собой входные данные для программы, а после
завершения её исполнения~--- новое значение~$\sigma'$,
представляющее результаты. Выполнение отдельных операторов сводится
к изменению ними состояния, которое последовательно проходит через
конечное число значений:

$$ \sigma = \sigma_0 \to \sigma_1 \to \sigma_2 \to \cdots \to \sigma_n =
\sigma' $$

Например, в программе сортировки состояние первоначально включает в
себя массив значений, а после того, как программа завершается,
состояние модифицируется таким образом, что эти значения становятся
упорядоченными, в то время как промежуточные состояния представляют
собой ход достижения данной цели.

Состояние обычно изменяется с помощью операторов {\em присваивания}, часто
записываемых в виде {\tt v = E} или {\tt v := E}, где {\tt v}~--
переменная, а {\tt E}~-- некоторое выражение. Последовательность выполнения
таких операторов задаётся в тексте программы их размещением друг за другом (при этом
часто в качестве разделителя применяется точка с запятой). С помощью составных
операторов, таких как {\tt if} и~{\tt while}, можно выполнять операторы в
зависимости от условия или циклически, часто полагаясь на другие
свойства текущего состояния.  В результате программа превращается в
%% ISSUE: не очень понятно, что автор имел в виду 
набор инструкций по изменению состояния, и поэтому данный стиль
программирования часто называется {\em императивным} или {\em
  процедурным}.  Соответственно, традиционные языки программирования,
поддерживающие такой стиль, также известны как императивные или
процедурные языки.

Функциональное программирование радикально отличается
от этой модели.  По существу, функциональная программа представляет собой просто
выражение, а выполнение программы~--- процесс его вычисления.%
\footnote{Функциональное программирование часто называют 
<<аппликативным программированием>>, поскольку основной его механизм~-- это
{\em аппликация (применение)} функции к аргументам.}  В общих чертах
мы можем понять, как это возможно, используя следующие рассуждения.
Предположим, что императивная программа (вся целиком) детерминирована,
т.е. выход полностью определяется входом; мы можем сказать, что
конечное состояние или тот его фрагмент, который нас интересует,
являются функцией начального состояния, например $\sigma' =
f(\sigma)$.\footnote{Сравните это с замечанием Наура о том,
  что мы можем записать любую программу в виде одного выражения
  $Output = Program(Input)$~\cite{raphael-spl}.}  
В функциональном программировании эта
точка зрения имеет особое значение: программа~-- это выражение, которое
соответствует математической функции $f$.  Функциональные языки
поддерживают создание таких выражений за счет того, что позволяют
использовать мощные функциональные конструкции.

Функциональное программирование может противопоставляться
императивному как c хорошей, так и в плохой стороны.  К недостаткам
ФП можно отнести то, что функциональные программы не используют
переменные~-- то есть {\em не имеют} состояния.  Соответственно, они не
могут использовать присваивание, поскольку нечему присваивать.
Кроме того, идея последовательного выполнения операторов также
бессмысленна, поскольку первый оператор не имеет никакого влияния на
второй, так как нет никакого состояния, передаваемого между ними. 
К достоинствам функционального подхода можно отнести то, 
что функциональные программы
могут использовать функции более изящным способом.  Функции могут
рассматриваться точно так же, как и более простые объекты, такие как
целые числа: они могут передаваться в другие функции как аргументы и
возвращаться в качестве результатов, а также применяться в
вычислениях.  Вместо последовательного выполнения операторов и использования
циклов, функциональные языки программирования предлагают рекурсивные функции,
т.е. функции, определённые в терминах самих себя.  Большинство
традиционных языков программирования обеспечивают весьма скудные
возможности в этих областях. Язык C имеет некоторые ограниченные
возможности работы с функциями при помощи указателей, но не
позволяет создавать новые функции динамически, а язык FORTRAN вообще
не поддерживает рекурсию.

Продемонстрируем разницу между императивным и функциональным
программированием на примере функции вычисления факториала.
Она может быть записана императивно на языке C как:

\begin{lstlisting}[language=C]
  int fact(int n)
  { int x = 1;
    while (n > 0)
     { x = x * n;
       n = n - 1;
     }
    return x;
  }
\end{lstlisting}

\noindent в то время как на языке ML (функциональном языке 
программирования, который мы обсудим позже) она может быть реализована
в виде рекурсивной функции:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

Можно отметить, что такое определение достаточно просто реализовать и на
языке~C. Однако, при необходимости более сложной работы с функциями
функциональные языки не имеют себе равных.

\section{Достоинства функционального программирования}

На первый взгляд, язык без переменных или возможности
последовательного выполнения инструкций кажется совершенно непрактичным.  Это
впечатление не может быть разрушено с помощью нескольких слов,
написанных тут.  Но мы надеемся, что изучая материал, приведённый
далее, читатель получит представление о том, какое разнообразие задач можно 
решить, программируя в функциональном стиле.

Имеративный стиль программирования не является нерушимой догмой.
Многие свойства
императивных языков программирования развились в процессе
абстрагирования от типового компьютерного оборудования, от машинного
кода к ассемблерам, затем к макроассемблерам, языку~FORTRAN и так
далее. Нет оснований утверждать, что такие языки представляют собой
наиболее удобный способ взаимодействия человека и машины. В самом деле,
последнее слово в развитии компьютерных архитектур еще не сказано, и
компьютеры должны служить нашим нуждам, а не наоборот. Вероятно, было бы
правильнее не начинать с оборудования и продвигаться вверх, а 
наоборот, взяв за основу язык программирования, как
средство описания алгоритмов, следовать {\em вниз} к 
оборудованию~\cite{dijkstra-discipline}.  
В действительности, данная тенденция
может быть обнаружена и в традиционных языках программирования.  Даже
FORTRAN  позволяет записывать арифметические выражения обычным
способом.  Программист не обеспокоен задачей линеаризации вычисления
подвыражений и выделения памяти для хранения промежуточных результатов.

Из этих соображений можно сделать вывод, 
что идея разработки языков программирования, сильно
отличающихся от традиционных, императивных языков, является вполне
законной.  Однако, для того, чтобы показать, что мы не просто
предлагаем изменения ради изменений, мы должны сказать несколько слов
о том, почему мы могли бы предпочесть функциональные языки
программирования императивным.

Возможно, главной причиной является то, что программы на функциональных
языках более точно соответствуют математическим объектам, и их свойства легче
доказывать. Для того, чтобы показать, что программа означает, мы можем
связать абстрактный математический смысл с программой или оператором~---
это цель {\em денотационной семантики} (семантика = значение, смысл).
В императивных языках это должно делаться скорее побочным способом,
из-за неявной зависимости от состояния.  Для простых
императивных языков можно связать оператор с функцией $\Sigma \to
\Sigma$, где $\Sigma$~-- множество допустимых состояний.
Таким образом, оператор получает некоторое состояние и порождает другое.
Однако, не каждый оператор всегда завершает свою работу
(например, {\tt while true do x := x}), 
так что эта функция, вообще говоря, является частичной.
Иногда более предпочтительными являются альтернативные средства
формализации семантики, например, {\em преобразователи предикатов}
Дейкстры~\cite{dijkstra-discipline}.  Но если мы добавим возможности, которые
могут сложным образом изменить последовательность выполнения операторов,
например, {\tt goto}, или конструкции {\tt break} и {\tt continue}
языка C, то даже такие решения перестанут работать, поскольку один
оператор может привести к пропуску выполнения других операторов, 
следующих за ним в тексте программы.
Вместо этого обычно используют более сложные семантики, основанные 
на {\em продолжениях (continuations)}.

В противоположность сказанному выше, функциональные программы, по
словам Хенсона, <<носят свою семантику с собой>>~\cite{henson-book}.%
\footnote{Дополнительно: денотационную семантику можно
  рассматривать как попытку превратить императивные языки в
  функциональные, путём явного объявления состояний.}  Мы можем
показать это на примере ML.  Основные типы напрямую могут
рассматриваться как математические объекты.  Используя стандартную
запись $\sem{X}$ для <<семантики $X$>>, мы можем сказать, например,
что $\sem{\mbox{int}} = \num$.  Например, функция ML {\tt fact},
определённая выражением:

\begin{lstlisting}
  let rec fact n =
    if n = 0 then 1
    else n * fact(n - 1);;
\end{lstlisting}

\noindent имеет один аргумент типа {\tt int}, и возвращает значение
типа {\tt int}, так что она просто является связанной с абстрактной
частичной функцией $\num \to \num$:

$$ \sem{\mbox{fact}}(n) = \left\{ \begin{array}{ll}
    n! & \mbox{if $n \geq 0$} \\
    \bot & \mbox{otherwise}
  \end{array} \right. $$

(Здесь $\bot$ обозначает неопределённость, поскольку для отрицательных
аргументов программа не сможет завершиться).  Однако этот способ
простой интерпретации не работает для не-функциональных программ,
поскольку, так называемые <<функции>> могут не быть функциями в
математическом смысле.  Например, в стандартной библиотеке языка C
есть функция {\tt rand()}, которая возвращает различные
псевдослучайные значения при последовательных вызовах.  Это может
быть сделано с помощью локальных статических переменных, используемых
для хранения предыдущих результатов, например, так:

\begin{lstlisting}[language=C]
  int
  rand(void) {
          static int n = 0;
          return n = 2147001325 * n + 715136305;
  }
\end{lstlisting}

Таким образом, мы можем рассматривать отказ от переменных и
присваивания, как следующий шаг после отказа от
\texttt{goto}, поскольку каждый следующий шаг делает семантику проще.  Более
простая семантика делает доказательство свойств программ более ясным.  Это
даёт нам больше возможностей для доказательства корректности программ и
преобразований, используемых для их оптимизации.

% Thus, one can see the abandonment of variables and assignments as the logical
% next step after the abandonment of {\tt goto}, since each step makes the
% semantics simpler. A simpler semantics makes reasoning about programs more
% straightforward. This opens up more possibilities for correctness proofs, and
% for provably correct transformations into more efficient programs.

У функциональных языков есть и другое потенциальное преимущество.
Поскольку вычисление выражений не имеет побочных эффектов для любых
состояний, то отдельные подвыражения могут вычисляться в произвольном
порядке, не влияя друг на друга.  Это означает, что функциональные
программы хорошо поддаются распараллеливанию, т.е.,
компьютер может автоматически вычислять различные подвыражения на
разных процессорах.  В то же время, императивные программы часто
задают жёсткий порядок вычислений, так что даже ограниченное перемешивание
инструкций в современных процессорах с конвейерной обработкой ведёт к
сложностям и возникновению технических проблем.

На самом деле, ML не является чисто функциональным языком
программирования; в нём есть переменные и присваивания, если
потребуется.  Большую часть времени мы будем делать нашу работу,
оставаясь в рамках чисто функционального подмножества языка.  Но даже если мы
и воспользуемся присваиваниями, потеряв некоторые из ранее
перечисленных достоинств, останется в силе большая гибкость в
работе с функциями, свойственная языкам, подобным ML.
Программы часто могут быть выражены очень кратко и
элегантно при помощи функций высшего порядка (функций,
которые оперируют другими функциями).\footnote{Элегантность
  субъективна, а краткость~--- не самоцель.  Функциональные
  языки, а также другие языки, такие как APL, часто создают соблазн
  создания очень короткого, хитроумного кода, который элегантен для
  знатоков, но непонятен для остальных.}  Код может быть более общим,
поскольку он может быть параметризован другими функциями.  Например,
программа, которая складывает список чисел, и программа, которая
умножает список чисел, могут рассматриваться как экземпляры одной и той
же программы, которая параметризуется арифметической операцией над
парой чисел и единичным элементом.  В первом случае это будут $+$ и
$0$, а во втором~-- $*$ и $1$.\footnote{Это напоминает
  абстракции, введенные в чистой математике; например, аддитивные и
  мультипликативные структуры над числами являются частными случаями
  абстрактного понятия <<моноид>>.  Такое подобие помогает избегать
  дублирования и увеличивает элегантность.}  В заключение, функции
могут использоваться для представления {\em бесконечных} наборов
данных удобным способом, например, мы позже покажем как использовать
функции для выполнения вычислений с вещественными числами, в отличие
от использования приближений в виде чисел с плавающей запятой.

В то же время, функциональные программы не лишены собственных проблем.
Поскольку функциональные программы менее ориентированы на выполнение
на конечном оборудовании, может быть тяжело вычислить точное
использование ресурсов, таких как время и память.  Ввод-вывод также
непросто ввести в функциональную модель, хотя существуют остроумные
способы, основанные на бесконечных последовательностях.

Читатели данной книги должны сами сделать заключение о достоинствах
функционального стиля.  Мы не хотим навязывать никакую идеологию,
а лишь хотим показать, что {\em существуют} разные подходы к
программированию, и что в соответствующих ситуациях функциональное
программирование может иметь значительные достоинства.  Большинство
наших примеров выбрано из областей, которые могут быть определены как
<<символьные вычисления>>.  Мы верим, что функциональные программы
успешно работают в таких приложениях.  Однако, как всегда, человек
должен использовать наиболее подходящие для работы инструменты.
Возможно, что императивное, объектно-ориентированное или логическое
программирование лучше подходят для определённых задач.

\section{План}

Для тех, кто использовал императивное программирование, переход к
функциональному будет неизбежно тяжёл, независимо от используемого
подхода.  Хотя есть люди, которые сразу хотят перейти непосредственно
к программированию, мы выбрали другой подход~-- мы начнём с
$\lambda$-исчисления, и покажем как оно может быть использовано в роли
теоретической основы функциональных языков.  Такой подход обладает
тем достоинством, что он хорошо соответствует реальной истории разработки
функциональных языков.

Следовательно, сначала мы введём $\lambda$-исчисление, и покажем как оно,
первоначально предназначенное на роль формальной логической основы
математики, превратилось в полноценный язык программирования.  Затем мы
обсудим, зачем мы хотим добавить типы в $\lambda$-исчисление, и
покажем, как добиться требуемого.  Это приведёт нас к языку~ML, который по
существу является оптимизированной реализацией типизированного
$\lambda$-исчисления с определённой стратегией вычисления выражений.
Мы рассмотрим практические основы функционального программирования на
ML, обсудим полиморфизм и понятие наиболее общего типа данных.  Затем мы перейдём к
более сложным темам, таким как исключения и императивные возможности
ML.  В заключение, мы приведём несколько реальных примеров, которые,
как мы надеемся, подтвердят мощь ML.

\section*{Дополнительная литература}
Множество книг о <<функциональном программировании>> включают в себя
общее введение в предмет и описание отличий данного подхода от императивного~--- 
просмотрите несколько и выберите ту, которая вам нравится.  Например, Хенсон
предлагает хорошее вводное обсуждение~\cite{henson-book}, которое содержит 
такую же смесь теории и практики, как и данный текст.  Детальная и 
спорная пропаганда функционального стиля программирования изложена 
в работе создателя~FORTRAN Джона Бэкуса~\cite{backus-liberated}.
Э.~Гордон обсуждает возникающие в функциональных языках проблемы ввода-вывода, 
а также приводит некоторые их решения~\cite{gordon-io}.  Читатели,
заинтересовавшиеся денотационной семантикой для императивных и
функциональных языков, могут обратиться к~\cite{winskel-sem}.

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
