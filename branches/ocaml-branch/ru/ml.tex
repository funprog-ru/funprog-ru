\chapter{Знакомство с ML}

В предыдущих главах мы начали с чистого $\lambda$-исчисления, которое затем
систематически расширяли новыми возможностями.  Например, мы
добавили примитивную конструкцию~let, чтобы сделать полиморфную
типизацию более полезной, а также оператор рекурсии для
восстановления вычислительной полноты, потерянной после
введения типов.  Двигаясь дальше по этому пути, мы в конечном счёте
приходим к~ML, при этом сохранив простоту мировоззрения, сформированного
в ходе изучения типизированного $\lambda$-исчисления.

Очередным этапом на этом пути будет отказ от представления данных (например,
натуральных чисел и логических значений) в виде термов лямбда-исчисления 
и замена их примитивами, такими как типы~{\tt bool} (для логических значений) 
и~{\tt int} (для целых чисел). В дополнение, введём новые конструкторы типов,
такие как~$\times$,~--- желательность подобного шага уже упоминалась в 
предыдущей главе. С этими изменениями
также связаны новые константы и новые правила преобразования.
Например, выражение $2 + 2$ будет вычисляться с использованием машинной
арифметики вместо представления его в нумералах Чёрча и выполнения
$\beta$-преобразований.  Эти дополнительные преобразования,
рассматриваемые как расширение обычных $\lambda$-операций, часто
называются `$\delta$-преобразованиями'.  В течение курса мы неоднократно 
увидим, чем язык ML отличается от чистого $\lambda$-исчисления.  Первым
делом обратимся к фундаментальному вопросу стратегии
вычисления выражений в~ML.

\section{Энергичное вычисление}

Как уже было сказано ранее, с теоретической точки зрения нормальный порядок
(сверху вниз, слева направо) редукции выражений более предпочтителен,
потому что если хоть какая-то стратегия завершается, то и эта тоже.%
\footnote{Данная стратегия подобна некоторым, используемым в традиционных
  языках, таких как Algol~60, где её называют {\em вызов по имени}.}
Однако, такой подход имеет некоторые практические недостатки.  Например,
рассмотрим следующее выражение:

$$ (\lamb{x} x + x + x)\; (10 + 5) $$

При использовании нормального порядка редукции мы получаем $(10 + 5) +
(10 + 5) + (10 + 5)$, так что на следующих шагах мы должны
вычислить одно и то же выражение трижды.  На практике это совершенно
недопустимо.  Существуют два основных решения данной проблемы, и эти
решения делят мир функционального программирования на два лагеря.

Первое решение~--- придерживаться нормального порядка редукции, но при
этом пытаться оптимизировать реализацию так, чтобы разнообразные
подвыражения, возникающие при таком подходе, использовались совместно
и никогда не вычислялись более одного раза.  В самой реализации
выражения представляются в виде ориентированных ациклических графов, а не в
виде деревьев.  Этот подход известен как {\em ленивое (lazy)} или {\em
  вызов по необходимости (call-by-need)} вычисление, поскольку
выражения вычисляются только тогда, когда необходимо.

Вторым решением является попытка перевернуть с ног на голову
теоретические размышления о стратегии редукции и вычислять аргументы
функции до начала её собственного вычисления.  Этот подход известен как {\em
  аппликативный порядок} или {\em энергичное} вычисление.  Последнее
имя возникло из-за того, что аргументы функции вычисляются даже тогда,
когда они не нужны, например, $t$ в $(\lamb{x} y)\; t$.  Конечно, применение
аппликативного порядка означает, что процесс вычисления некоторых выражений
может зацикливаться, тогда как он завершается при работе в
ленивом режиме.  Но это считается допустимым, поскольку подобных ситуаций
достаточно легко избежать на практике.  В любом случае, стратегия
энергичного вычисления является стандартной для многих языков
программирования, таких как C, где её называют {\em вызов по значению
  (call by value)}.

ML использует энергичное вычисление по двум основным причинам.
Управление редукцией и совместным использованием подвыражений, которое требуется
при ленивом вычислении, является достаточно сложным, и реализация
может быть относительно неэффективной и трудной.  Если программист
не проявит должной осторожности, то память может заполниться невычисленными
выражениями, так что в общем случае оценить потребление памяти программой
будет затруднительно.
В действительности, многие реализации ленивого вычисления стараются
оптимизировать его путём использования энергичного вычисления в тех
местах, где семантика не отличается.\footnote{Они стараются выполнить
  {\em анализ строгости}~--- один из видов статического анализа,
  который часто помогает определить, что аргументы должны быть
  вычислены~\cite{mycroft-thesis}.}  В противоположность этому, в ML
мы всегда сначала вычисляем аргументы функций, и только затем
выполняем $\beta$-редукцию~--- это просто, эффективно и легко
реализуется с использованием стандартных технологий построения
компиляторов.

Второй причиной для выбора аппликативного порядка вычислений служит
то, что ML не является {\em чистым} функциональным языком, а имеет
императивные возможности (переменные, присваивание и т.п.).
Следовательно, порядок вычисления подвыражений может изменить {\em
  семантику}, а не просто влияет на эффективность.  Если используется
ленивое вычисление, то для программиста становится практически
невозможным отчётливо представить (в нетривиальной программе) когда
и какое подвыражение вычисляется.  С другой стороны, в энергичной системе, 
подобной ML, достаточно лишь помнить соответствующие простые правила.

Однако, важно осознавать, что стратегия вычислений ML {\em не} просто редукция
снизу вверх, в противоположность нормальному порядку. В
действительности ML {\em никогда не вычисляет содержимое
  $\lambda$-абстракций}.  (В частности, он никогда не
редуцирует $\eta$-редексы, а только $\beta$-редексы.)  При
вычислении  $(\lamb{x} s[x])\; t$, сначала вычисляется $t$.  Однако
$s[x]$ не затрагивается, поскольку оно является содержимым
$\lambda$-абстракции.  Кроме того, любое подвыражение  $t$, которое
является содержимым $\lambda$-абстракции, также остаётся нетронутым.
Вот точные правила вычисления:

\begin{itemize}

\item Константы вычисляются сами в себя.

\item Вычисления заканчиваются на $\lambda$-абстракциях, и не
  затрагивают их содержимого.  В частности, не выполняется
  $\eta$-преобразование.

\item При вычислении комбинации $s\; t$ {\em сначала} вычисляются оба
  терма, $s$ и $t$.  Потом, при условии что результатом вычисления~$s$ является
  $\lambda$-абстракция, производится самое внешнее
  $\beta$-преобразование, и процесс повторяется.

\end{itemize}

Порядок вычисления $s$ и $t$ отличается в зависимости от версии ML.  В
той версии, которую мы будем использовать, сначала всегда
вычисляется~$t$.  Строго говоря, мы также должны задать правило для
{\tt let}-выражений, поскольку, как упоминалось, они теперь
считаются примитивами.  Однако, с точки зрения стратегии вычислений, они
как и прежде могут рассматриваться как применение $\lambda$-абстракции к
аргументу, который будет вычислен первым.
% COMMENT# то есть let x = s in t можно рассматривать как
% (lambda x t) s   --lg
Для того, чтобы сделать это явным, правило для 

$$ \mbox{let}\; x = s\; \mbox{in}\; t $$

\noindent гласит, что сначала вычисляются все $s$, а результат
подставляется вместо $x$ в $t$, после чего вычисляется новое
значение $t$.  Рассмотрим некоторые примеры вычисления
выражений:

\begin{eqnarray*}
(\lamb{x} (\lamb{y} y + y)\; x) (2 + 2)
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x) 4   \\
& \goesto & (\lamb{y} y + y) 4                  \\
& \goesto & 4 + 4                               \\
& \goesto & 8
\end{eqnarray*}

Заметим, что подтерм $(\lamb{y} y + y)\; x$ {\em не редуцируется},
поскольку он находится в пределах $\lambda$-абстракции.  Однако,
редуцируемые термы, \emph{не} находящиеся внутри $\lambda$-абстракций
обоих функций, а также аргумент, редуцируются до того, как вычисляется
применение функции, например, второй шаг будет следующим:

\begin{eqnarray*}
((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; (2 + 2)
& \goesto & ((\lamb{f\; x} f\; x)\; (\lamb{y} y + y))\; 4           \\
& \goesto & (\lamb{x} (\lamb{y} y + y)\; x)\; 4                   \\
& \goesto & (\lamb{y} y + y)\; 4                                  \\
& \goesto & 4 + 4
\end{eqnarray*}

Тот факт, что ML не вычисляет содержимое $\lambda$-абстракций,
является ключевым для опытных программистов на ML.
Он даёт возможность точного контроля над вычислением выражений и
может использоваться для имитации многих полезных возможностей ленивой 
стратегии. Простейшие примеры этого будут рассмотрены в следующем разделе.

\section{Результаты энергичного вычисления}

Использование энергичного вычисления заставляет нас объявить примитивами
некоторые дополнительные языковые конструкции, определив для них 
специальные методы редукции, вместо того, чтобы реализовать их
напрямую в терминах $\lambda$-исчисления.  В частности, мы не можем
больше рассматривать условную конструкцию

$$ \mbox{if}\; b\; \mbox{then}\; e_1\; \mbox{else}\; e_2 $$

\noindent как применение обычного трехкомпонентного (тернарного) оператора

$$ \mbox{COND}\; b\; e_1\; e_2 $$

Причина заключается в том, что по правилам энергичного вычисления 
мы всегда должны вычислить все выражения, $b$, $e_1$ и $e_2$,
\emph{до} вычисления $\mbox{COND}$. Как правило, последствия этого фатальны.
Например, заново рассмотрим наше определение функции вычисления
факториала:

$$ \mbox{let rec fact}(n) = \mbox{if ISZERO}\; n\; \mbox{then}\; 1\;
                            \mbox{else}\; n * \mbox{fact}(\mbox{PRE}\; n) $$

Если условное выражение будет вычислять все свои аргументы, то при вычислении 
$\mbox{fact}(0)$, ветвь `else' также должна быть вычислена, что
в свою очередь вызывает вычисление $\mbox{fact}(\mbox{PRE}\; 0)$. 
Но это также потребует вычисления $\mbox{fact}(\mbox{PRE}\;
(\mbox{PRE}\; 0))$, и т.д.  Соответственно, вычисление превратится в
бесконечный цикл.

Таким образом, мы делаем условное выражение примитивной конструкцией
и меняем обычную стратегию редукции так, что {\em сначала}
вычисляется логическое выражение, а затем~--- {\em только
  одна} соответствующая ветвь условия.

А что происходит с самим процессом рекурсии?  Мы предложили
интерпретацию рекурсивных определений в терминах рекурсивного оператора
$Rec$ с его собственным правилом редукции:

$$ Rec\; f \goesto f(Rec\; f) $$

\noindent который также будет зацикливаться при использовании стратегии
энергичного вычисления:

$$  Rec\; f \goesto f(Rec\; f) \goesto f(f(Rec\; f)) \goesto f(f(f(Rec\; f)))
\goesto \cdots $$

Однако, достаточно лишь очень простого изменения правил
редукции, чтобы решить эту проблему:

$$ Rec\; f \goesto f(\lamb{x} Rec\; f\; x) $$

Теперь $\lambda$-абстракция в правой части правила означает, 
что $\lamb{x} Rec\; f\; x$ вычисляется само в себя 
(то есть, не вычисляется вовсе), и только
после того, как выражение было редуцировано в ходе подстановки этой
$\lambda$-абстракции в терм~$f$, вычисление продолжается.

\section{Семейство языков ML}

Мы говорили о `ML' так, как будто это один язык.  На самом деле
существует много вариантов ML, в том числе и~`Lazy ML'~--- реализация
университета Chalmers в Швеции, которая базируется на ленивых
вычислениях.  Наиболее популярная версия ML в образовании~--- это
`Standard ML', но мы будем использовать другую, которая называется
CAML (`camel') Light.\footnote{Это имя означает `Categorical Abstract
  Machine', метод реализации, лежащий в её основе.}  Мы выбрали CAML
Light по следующим причинам:

\begin{itemize}

\item реализация имеет небольшой объём и хорошо переносима между
  платформами, так что она эффективно работает на Unix, PC, Mac, и
  других.

\item Система очень проста синтаксически и семантически, что делает
  её достаточно простой для изучения.

\item Система хорошо подходит для практического использования.
  Например, она имеет интерфейс к библиотекам на языке C и
  поддерживает стандартную раздельную компиляцию, совместимую с {\tt
    make}.

\end{itemize}

Однако, мы будем изучать достаточно общие техники, так что любой написанный
код может быть запущен (с небольшими синтаксическими изменениями) на
любой версии ML, и часто, на других функциональных языках.

\section{Запуск ML}

ML уже установлен на рабочий сервер (Thor).  Для того, чтобы
использовать его, вам необходимо добавить каталог с исполняемыми
файлами CAML в переменную среды {\tt PATH}.  Это может быть сделано
следующим образом (предполагая, что вы используете командный процессор
bash или другой из его семейства):

\begin{boxed}
\begin{verbatim}
  PATH="$PATH:/home/jrh13/caml/bin"
  export PATH
\end{verbatim}
\end{boxed}%$

Чтобы не вводить эти команды при каждом входе на сервер, вы можете
вставить их в конец вашего файла {\tt .bash\_profile} или
его эквивалента для вашего командного процессора.  Теперь, для
использования CAML в интерактивном режиме, вам просто надо набрать
{\tt camllight}, и программа должна запуститься и выдать приглашение
(`{\tt \#}'):

\begin{boxed}
\begin{verbatim}
  $ camllight
  >       Caml Light version 0.73

  #
\end{verbatim}
\end{boxed}%$

Для того, чтобы выйти из системы, просто наберите {\tt ctrl/d} или
{\tt quit();;} в строке ввода.  Если вы заинтересованы в
установке CAML Light на ваш собственный компьютер, то вы должны
прочитать следующую Web-страницу для получения подробной информации:

\begin{boxed}
\begin{verbatim}
  http://pauillac.inria.fr/caml/
\end{verbatim}
\end{boxed}

\section{Взаимодействие с ML}

Когда ML выдаст вам строку приглашения, вы можете вводить выражения,
завершённые двумя последовательными знаками ``точка с запятой''.
Принято говорить, что ML находится в режиме диалога (который также имеет
жаргонное название REPL, read-eval-print loop): выражения считываются,
вычисляются и выводятся результаты.  Например, ML может быть
использован как простой калькулятор:

\begin{boxed}
\begin{verbatim}
  #10 + 5;;
  - : int = 15
\end{verbatim}
\end{boxed}

Система не только возвращает ответ, но также выдаёт  {\em тип}
выражения, который определяется автоматически.  Система может сделать
это, поскольку знает тип встроенного оператора сложения {\tt +}.  С
другой стороны, если для выражения не может быть определён тип, то
система отвергнет его и постарается выдать сообщение о том, почему
произошла ошибка.  В сложных случаях сообщения об ошибках  достаточно
тяжело понять.

\begin{boxed}
\begin{verbatim}
  #1 + true;;
  Toplevel input:
  >let it = 1 + true;;
  >             ^^^^
  This expression has type bool,
  but is used with type int.
\end{verbatim}
\end{boxed}

Поскольку ML является функциональным языком, то выражения могут иметь
функциональный тип.  Для $\lambda$-абстракций $\lamb{x} t[x]$ ML предоставляет
следующий синтаксис~--- {\tt fun x -> t[x]}.  Например, мы можем
определить функцию вычисления целого числа, следующего за данным:

\begin{boxed}
\begin{verbatim}
  #fun x -> x + 1;;
  - : int -> int = <fun>
\end{verbatim}
\end{boxed}

Как и в предыдущем примере, тип выражения (сейчас это {\tt int ->
  int}), выводится и выдаётся на экран.  Однако сама функция не
печатается; система лишь выдаёт {\tt <fun>}.  Это сделано потому, что
внутреннее представление функций не слишком читабельно.\footnote{CAML не
  хранит их как синтаксические деревья, а компилирует в байт-код.}
Функции применяются к следующим за ними аргументам, так же как и в
$\lambda$-исчислении.  Например:

\begin{boxed}
\begin{verbatim}
  #(fun x -> x + 1) 4;;
  - : int = 5
\end{verbatim}
\end{boxed}

Подобно $\lambda$-исчислению, применение функции левоассоциативно,
так что вы можете определять каррированные функции, используя  то же
самое соглашение по сокращению повторяющихся $\lambda$-абстракций (т.е.,
{\tt fun}-й).  Например, все следующие выражения эквивалентны:

\begin{boxed}
\begin{verbatim}
  #((fun x -> (fun y -> x + y)) 1) 2;;
  - : int = 3
  #(fun x -> fun y -> x + y) 1 2;;
  - : int = 3
  #(fun x y -> x + y) 1 2;;
  - : int = 3
\end{verbatim}
\end{boxed}

\section{Связывания и объявления}
Вводить большое выражение целиком утомительно, гораздо удобнее будет
воспользоватся {\tt let} для связывания осмысленных
подвыражений с именами. Это может быть сделано следующим образом:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1 in
   successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent Для связывания функций существует более элегантная
конструкция:

\begin{boxed}
\begin{verbatim}
  #let successor x = x + 1 in
  successor(successor(successor 0));;
  - : int = 3
\end{verbatim}
\end{boxed}

\noindent в том числе для рекурсивных определений, дополненных ключевым 
словом~{\tt rec}:

\begin{boxed}
\begin{verbatim}
  #let rec fact n = if n = 0 then 1
                    else n * fact(n - 1) in
   fact 6;;
  - : int = 720
\end{verbatim}
\end{boxed}

Используя {\tt and}, мы можем сделать несколько связываний
одновременно и определить взаимно рекурсивные функции. Вот пример
двух простых, хотя и сильно неэффективных, функций, которые определяют,
является ли натуральное число чётным или нечётным:

\begin{boxed}
\begin{verbatim}
  #let rec even n = if n = 0 then true else odd (n - 1)
       and odd n  = if n = 0 then false else even (n - 1);;
  even : int -> bool = <fun>
  odd : int -> bool = <fun>
  #even 12;;
  - : bool = true
  #odd 14;;
  - : bool = false
\end{verbatim}
\end{boxed}

В действительности, любое связывание может быть сделано отдельно от
его применения.  ML помнит набор связанных переменных, и пользователь
может пополнять данный набор интерактивно.  Просто уберите {\tt in} и
завершите выражение двойной точкой с запятой:

\begin{boxed}
\begin{verbatim}
  #let successor = fun x -> x + 1;;
  successor : int -> int = <fun>
\end{verbatim}
\end{boxed}

\noindent После этого объявления, любое последующее выражение может
использовать функцию {\tt successor}, например:

\begin{boxed}
\begin{verbatim}
  #successor 11;;
  - : int = 12
\end{verbatim}
\end{boxed}

Заметьте, что мы не делаем {\em присваивания} значений {\em переменным}.  Каждое
связывание выполняется только раз, когда система анализирует введённые
данные; оно не может быть повторено или изменено.  Оно может быть
перезаписано новым определением с тем же именем, но это не присваивание,
в своём обычном значении, поскольку последовательность событий связана
только с процессом {\em компиляции}, а не с динамикой {\em выполнения}
программы.  Конечно, отходя от интерактивного получения ответа от
системы, мы можем полностью заменить все двойные точки с запятой,
записанные после объявлений, на {\tt in} и вычислить всё сразу.  С
этой точки зрения видно, что переписывание объявления в
действительности соответствует определению новой локальной переменной,
которая скрывает предыдущую, в соответствии с обычными правилами
$\lambda$-исчисления.  Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let y = 2;;
  y : int = 2
  #let x = 3;;
  x : int = 3
  #x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

\noindent является тем же самым, что и:

\begin{boxed}
\begin{verbatim}
  #let x = 1 in
   let y = 2 in
   let x = 3 in
   x + y;;
  - : int = 5
\end{verbatim}
\end{boxed}

Обязательно заметьте, что следуя $\lambda$-исчислению, связывание
переменных является {\em статическим}, например, первое связывание
{\tt x} используется до того, как будет сделано новое связывание, и
любое его использование до нового определения не будет затронуто
этим определением. Например:

\begin{boxed}
\begin{verbatim}
  #let x = 1;;
  x : int = 1
  #let f w = w + x;;
  f : int -> int = <fun>
  #let x = 2;;
  x : int = 2
  #f 0;;
  - : int = 1
\end{verbatim}
\end{boxed}

Первые версии LISP, однако, использовали {\em динамическое}
связывание, когда переопределение переменной также распространялось на
предыдущие использования этой переменной, так что аналогичная
последовательность команд должна будет вернуть число 2.  В
действительности это считалось ошибкой, но скоро программисты начали
использовать эту возможность.  Как следствие, когда некоторая
низкоуровневая функция изменялась, то изменения распространялись на
все её применения в других функциях без необходимости
перекомпиляции.  Такая возможность продолжала существовать долгое время
во многих диалектах LISP, но в конечном счёте победила идея, что
статическое связывание лучше.  В Common LISP по умолчанию используется
статическое связывание, но динамическое также можно разрешить,
если необходимо, используя ключевое слово {\tt special}.

\section{Полиморфные функции}

Мы можем определять полиморфные функции, например, 
тождественное отображение:

\begin{boxed}
\begin{verbatim}
  #let I = fun x -> x;;
  I : 'a -> 'a = <fun>
\end{verbatim}
\end{boxed}

Внешнее представление в ASCII-кодировке типовых переменных~$\alpha$,
$\beta$, \dots{} в~ML имеет вид {\tt 'a}, {\tt 'b}, \dots{}
Пример использования полиморфной функции с разными типами:

\begin{boxed}
\begin{verbatim}
  #I true;;
  - : bool = true
  #I 1;;
  - : int = 1
  #I I I I 12;;
  - : int = 12
\end{verbatim}
\end{boxed}

В данном примере все вхождения {\tt I} имеют различные типы и
интуитивно соответствуют разным функциям. Очередным этапом будет определение 
всех базовых комбинаторов:

\begin{boxed}
\begin{verbatim}
  #let I x = x;;
  I : 'a -> 'a = <fun>
  #let K x y = x;;
  K : 'a -> 'b -> 'a = <fun>
  #let S f g x = (f x) (g x);;
  S : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c = <fun>
\end{verbatim}
\end{boxed}

Заметьте, что система сама следит за типами, несмотря на то, что в
последнем случае они были довольно сложными.  Теперь, вспомним, что $I =
S\; K\; K$; давайте попробуем сделать это на ML:\footnote{Отметим,
  что без учёта типов, $S\; K\; A = I$ верно для любого $A$.
  Однако, читатель может сам попробовать, например, $S\; K\; S$ и
  убедиться, что его тип является менее общим, чем ожидалось.}
% COMMENT# По поводу этого footnote:
% http://users.livejournal.com/_darkus_/336760.html
% I = Y(SK);;  !!  --lg

\begin{boxed}
\begin{verbatim}
  #let I' = S K K;;
  I' : '_a -> '_a = <fun>
\end{verbatim}
\end{boxed}

\noindent Выражение имеет правильный тип\footnote{Игнорируйте
  подчёркивания.  Это связано с типизацией императивных
  конструкций, которые мы обсудим позже.} и может быть легко проверено
на конкретных случаях, например:

\begin{boxed}
\begin{verbatim}
  #I' 3 = 3;;
  - : bool = true
\end{verbatim}
\end{boxed}

В приведённых примерах полиморфных функций система очень быстро
выводит наиболее общий тип для каждого выражения, и этот тип достаточно прост.
Так обычно и происходит на практике, но
существуют патологические случаи, например, следующий пример,
приведённый в~\cite{mairson-ml}.  Тип этого выражения выводится
около 10 секунд и занимает более 4000 строк на 80-символьном
терминале.

\begin{boxed}
\begin{lstlisting}
  let pair x y = fun z -> z x y in
  let x1 = fun y -> pair y y in
  let x2 = fun y -> x1(x1 y) in
  let x3 = fun y -> x2(x2 y) in
  let x4 = fun y -> x3(x3 y) in
  let x5 = fun y -> x4(x4 y) in
  x5(fun z -> z);;
\end{lstlisting}
\end{boxed}

Мы уже упоминали, что программисты на ML никогда не задают типы.  Это правда в
том смысле, что транслятор ML сам назначит выражению наиболее общий тип.
Однако, иногда бывает полезно {\em ограничить} вывод типа.  Подобная мера не
заставит работать код, который до этого не работал, но может
использоваться как документация для понимания его предназначения;
также возможно использовать более короткие синонимы для
сложных типов.  Ограничение типа может быть задано в ML путём
добавления {\em аннотации типа} после некоторого выражения.
Аннотации типов состоят из двоеточия, за которым указан тип.  Обычно
расположение аннотаций не имеет значения; если они есть, то
они заставляют использовать соответствующие ограничения.  Например,
вот несколько альтернативных вариантов явного назначения тождественной функции
типа {\tt int -> int}:

\begin{boxed}
\begin{verbatim}
  #let I (x:int) = x;;
  I : int -> int = <fun>
  #let I x = (x:int);;
  I : int -> int = <fun>
  #let (I:int->int) = fun x -> x;;
  I : int -> int = <fun>
  #let I = fun (x:int) -> x;;
  I : int -> int = <fun>
  #let I = ((fun x -> x):int->int);;
  I : int -> int = <fun>
\end{verbatim}
\end{boxed}

\section{Равенство функций}

Вместо проверки эквивалентности функций, таких как~$I$ и~$I'$,
сравнением результатов их применения к конкретным аргументам, например
$3$, может показаться, что мы можем разрешить данный вопрос путём
сравнения самих функций.  Однако, это не работает:

\begin{boxed}
\begin{verbatim}
  #I' = I;;
  Uncaught exception: Invalid_argument "equal: functional value"
\end{verbatim}
\end{boxed}

В общем случае {\em запрещено} сравнивать функции, хотя в нескольких
специальных случаях, когда равенство функций очевидно, выдаётся {\tt
  true}.

\begin{boxed}
\begin{verbatim}
  #let f x = x + 1;;
  f : int -> int = <fun>
  #let g x = x + 1;;
  g : int -> int = <fun>
  #f = f;;
  - : bool = true
  #f = g;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #let h = g;;
  h : int -> int = <fun>
  #h = f;;
  Uncaught exception: Invalid_argument "equal: functional value"
  #h = g;;
  - : bool = true
\end{verbatim}
\end{boxed}

Почему существуют эти ограничения?  Разве в ML функции не равноправны
с другими разновидностями данных?  Да, но к сожалению, (экстенсиональное)
равенство функций в общем случае невычислимо.  Это следует из различных классических
результатов теории алгоритмов, таких как {\em неразрешимость проблемы
  останова} и {\em теорема Райса}.\footnote{Вы увидите
  доказательства в курсе теории алгоритмов.  Теорема Райса~---
  чрезвычайно сильный вывод о неразрешимости, которая утверждает, что
  {\em любое} нетривиальное свойство функции, соответствующее
% COMMENT# нетривиальное свойство это такое свойство, для которого
% есть функции как обладающие им так и не обладающие --lg
  программе, невычислимо из её текста.  Отличной книгой по теории
  алгоритмов является~\cite{davis-weyuker}.} 
Приведём конкретный пример, демонстрирующий эту неразрешимость. На данный момент
для функции, определённой ниже, так и не установлено, завершается ли её
вычисление для произвольного аргумента. Предположение, что данная функция
вычислима всюду, известно как {\em гипотеза
  Коллатца (Collatz conjecture)}:\footnote{Хороший обзор этой
  проблемы и попыток её решения приведены в~\cite{lagarias-collatz}.
  Строго говоря, мы должны использовать целые числа неограниченной
  разрядности, а не машинную арифметику.  Позже мы увидим как это
  сделать.}

\begin{boxed}
\begin{verbatim}
  #let rec collatz n =
     if n <= 1 then 0
     else if even(n) then collatz(n / 2)
     else collatz(3 * n + 1);;
  collatz : int -> int = <fun>
\end{verbatim}
\end{boxed}

С другой стороны, очевидно, что в случае завершения вычислений их результатом
всегда будет~$0$. Теперь рассмотрим следующую тривиальную функцию:

\begin{boxed}
\begin{verbatim}
  #let f (x:int) = 0;;
  f : int -> int = <fun>
\end{verbatim}
\end{boxed}

Решив уравнение {\tt collatz = f}, компьютер подтвердил бы
гипотезу Коллатца. Похожие примеры также легко построить
на основе других математических задач, решение которых пока не найдено.

Процедура контроля типов может быть расширена таким образом, что позволит
выявлять без выполнения программы попытки сравнения как элементарных 
объектов-функций, так и объектов-агрегатов, в состав которых входят 
объекты-функции. Типы данных, в которые не входят подвыражения типа функция,
известны как {\em сравнимые типы}, поскольку всегда возможно проверить 
объекты таких типов на равенство. В то же время, это делает систему типов 
более сложной.  Однако, сторонники такого подхода придерживаются мнения,
что статическая проверка типов должна быть настолько полной, насколько 
это возможно.

\section*{Дополнительная литература}

Многие книги о функциональном программировании содержат информацию по общим
для всех функциональных языков аспектам, которые мы тоже обсуждали, например,
по стратегии вычислений.
Хорошее элементарное введение в CAML Light и функциональное
программирование можно найти в~\cite{mauny-tutorial}.
Учебник~\cite{paulson-ml} также хорош, но в его основе лежит другой диалект~--- 
Standard~ML.

\section*{Примеры}

\begin{enumerate}

\item Предположим, что `функция-условие', определённая {\tt ite(b,x,y)
    = if b then x else y} является единственной функцией, которая
  может работать с аргументами типа {\tt bool}.  Существует ли способ
  написать функцию факториала?

\item Докажите при помощи правил типизации, приведённых в предыдущей главе,
 что комбинатор~$S$ имеет в точности тот тип, который выводит для него~ML.

\item Напишите простую рекурсивную функцию возведения
  в степень целых чисел, т.е. вычисляющую $x^n$ для $n \geq 0$.
  Напишите на ML пару функций, из эквивалентности которых следовала бы
  справедливость Великой теоремы Ферма: не существует целых чисел $x$,
  $y$, $z$ и натурального числа $n > 2$ таких, что $x^n + y^n = z^n$, за
  исключением тривиального случая, когда $x = 0$ или $y = 0$.

\end{enumerate}

%%% Local Variables:
%%% TeX-master: "all"
%%% End:
