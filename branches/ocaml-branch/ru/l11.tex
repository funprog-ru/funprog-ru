\documentclass{fp-slides}

\begin{document}

\defverbatim[colored]\MyLitCam{
  \begin{lstlisting}[frame=single]
  $ camllight my_little_caml
\end{lstlisting}}

\defverbatim[colored]\MyLitCamNum{
  \begin{lstlisting}[frame=single]
  #open "num";;
\end{lstlisting}}

\defverbatim[colored]\RealOfInt{
  \begin{lstlisting}[frame=single]
  #let real_of_int k n =
     (Int 2 **/ Int n) */ Int k;;
  real_of_int : int -> int -> num = <fun>
  #real_of_int 23;;
  - : int -> num = <fun>
\end{lstlisting}}

\defverbatim[colored]\SignChange{
  \begin{lstlisting}[frame=single]
  let real_neg f n = minus_num(f n);;
\end{lstlisting}}

\defverbatim[colored]\DivWithDiv{
  \begin{lstlisting}[frame=single]
  #let ndiv x y = round_num(x // y);;
  ndiv : num -> num -> num = <fun>
  ##infix "ndiv";;
  #(Int 23) ndiv (Int 5);;
  - : num = Int 5
  #(Int 22) ndiv (Int 5);;
  - : num = Int 4
\end{lstlisting}}

\defverbatim[colored]\AddProg{
  \begin{lstlisting}[frame=single]
  let real_add f g n =
    (f(n + 2) +/ g(n + 2)) ndiv (Int 4);;
\end{lstlisting}}

\defverbatim[colored]\MulProg{
  \begin{lstlisting}[frame=single]
let log2 =
  let rec log2 x y =
    if x </ Int 1 then y
    else log2 (quo_num x (Int 2)) (y + 1) in
  fun x -> log2 (x -/ Int 1) 0;;
\end{lstlisting}}

\defverbatim[colored]\MulSimpleProg{
  \begin{lstlisting}[frame=single]
let real_intmul m x n =
  let p = log2 (abs_num m) in
  let p1 = p + 1 in
  (m */ x(n + p1)) ndiv (Int 2 **/ Int p1);;
\end{lstlisting}}

\defverbatim[colored]\MulEx{
  \begin{lstlisting}[frame=single]
  let real_mul x y n =
    let n2 = n + 2 in
    let r = n2 / 2 in
    let s = n2 - r in
    let xr = x(r) and ys = y(s) in
    let p = log2 xr and q = log2 ys in
    if p = 0 & q = 0 then Int 0 else
    let k = q + r + 1
    and l = p + s + 1
    and m = p + q + 4 in
    (x(k) */ y(l)) ndiv (Int 2 **/ Int m);;
\end{lstlisting}}

\defverbatim[colored]\MsdProg{
  \begin{lstlisting}[frame=single]
  let msd =
    let rec msd n x =
      if abs_num(x(n)) >/ Int 1 then n
      else msd (n + 1) x in
    msd 0;;
\end{lstlisting}}

\defverbatim[colored]\RealMulInvProg{
  \begin{lstlisting}[frame=single]
  let real_inv x n =
    let x0 = x(0) in
    let k =
      if x0 >/ Int 1 then
        let r = log2 x0 - 1 in
        let k0 = n + 1 - 2 * r in
        if k0 < 0 then 0 else k0
      else
        let p = msd x in
        n + 2 * p + 1 in
    (Int 2 **/ Int (n + k)) ndiv (x(k));;
\end{lstlisting}}

\defverbatim[colored]\RealDivInvProg{
  \begin{lstlisting}[frame=single]
  let real_div x y =
    real_mul x (real_inv y);;
\end{lstlisting}}

\defverbatim[colored]\OrderProg{
  \begin{lstlisting}[frame=single]
  let rec separate n x y =
    let d = x(n) -/ y(n) in
    if abs_num(d) >/ Int 1 then d
    else separate (n + 1) x y;;
  let real_gt x y = separate x y >/ Int 0;;
  let real_ge x y = real_gt x y;;
  let real_lt x y = separate x y </ Int 0;;
  let real_le x y = real_lt x y;;
\end{lstlisting}}

\defverbatim[colored]\View{
  \begin{lstlisting}[frame=single]
  let view x d =
    let n = 4 * d in
    let out = x(n) // (Int 2 **/ Int n) in
    approx_num_fix d out;;
\end{lstlisting}}

\defverbatim[colored]\Testing{
  \begin{lstlisting}[frame=single]
  #let x = real_of_int 3;;
  x : int -> num = <fun>
  #let xi = real_inv x;;
  xi : int -> num = <fun>
  #let wun = real_mul x xi;;
  wun : int -> num = <fun>
  #view x 20;;
  it : string = "3.00000000000000000000"
  #view xi 20;;
  it : string = ".33333333333333333333"
  #view wun 20;;
  it : string = "1.00000000000000000000"
\end{lstlisting}}

\defverbatim[colored]\Reevaluation{
  \begin{lstlisting}[frame=single]
  #let x1 = real_of_int 1 in
   let x2 = real_mul x1 x1 in
   let x3 = real_mul x2 x2 in
   let x4 = real_mul x3 x3 in
   let x5 = real_mul x4 x4 in
   let x6 = real_mul x5 x5 in
   let x7 = real_mul x6 x6 in
   view x7 10;;
   - : string = "+1.0000000000"
\end{lstlisting}}

\defverbatim[colored]\MemoFunc{
  \begin{lstlisting}[frame=single]
let memo f =
  let mem = ref (-1,Int 0) in
  fun n ->
    let (m,res) = !mem in
    if n <= m then
      if m = n then res
      else res ndiv (Int 2 **/ Int(m - n))
    else
      let res = f n in
      mem := (n,res); res;;
\end{lstlisting}}

\defverbatim[colored]\RealAddMemo{
  \begin{lstlisting}[frame=single]
let real_add f g = memo (fun n ->
   (f(n + 2) +/ g(n + 2)) ndiv (Int 4));;
...
\end{lstlisting}}

\frame{\titlepage}

\section*{Лекция 11. Примеры на ML III: Точная арифметика вещественных чисел}

\frame{
  \frametitle{Темы}
  \begin{itemize}
  \item Конечные представления.
    % \item Finite representations
    \maybepause

  \item Представление вещественных чисел аппроксимирующими функциями.
    % \item Real numbers as approximating functions
    \maybepause

  \item Целые числа произвольной разрядности.
    % \item Arbitrary precision integers
    \maybepause

  \item Операции над вещественными числами.
    % \item Operations over reals
    \maybepause

  \item Кэширование.
    % \item Caching

  \end{itemize}
}

\frame{
  \frametitle{Конечные представления}
  % \heading{Finite representations}

  Машинная реализация вещественной арифметики обычно использует приближённое
  представление чисел в формате с плавающей запятой.
  % TERM# 'плавающая запятая' согласно голосованию
  % Real arithmetic on computers is normally done via floating point
  % approximations.

  В общем случае, мы можем оперировать вещественными числами (либо вручную, 
  либо при помощи компьютера) лишь в том случае, когда они имеют то или иное
  конечное представление.
  % In general, we can only manipulate a real number, either ourselves or inside a
  % computer, via some sort of finite representation.

  Возникает вопрос, уместно ли говорить о <<существовании>> чисел, которые
  не представимы в конечной форме.
  % Some question how numbers can be said to <<exist>> if they have no finite
  % representation.

  Например, Кронекер признавал целые и рациональные числа, поскольку их можно
  задать точно, а также {\em алгебраические} числа, представимые многочленами,
  корнями которых они являются.
  % For example, Kronecker accepted integers and rationals because
  % they can be written down explicitly, and even {\em algebraic}
  % numbers because they can be represented using the polynomials of which they
  % are solutions.

  Однако, он отвергал трансцендентные числа, не имеющие конечного представления.
  % However he rejected transcendental numbers because apparently
  % they could not be represented finitely.
}

\frame{
  \frametitle{Представление вещественных чисел программами}
  % \heading{Real numbers as programs}

  Учитывая современные достижения, мы можем сказать, что конечное представление
  возможно для гораздо большего количества чисел, чем те, существование которых
  признавалось Кронекером.
  % However, given our modern perspective, we can say that after all many more
  % numbers than Kronecker would have accepted {\em do} have a finite
  % representation.

  Этим представлением являются программы вычисления требуемых чисел с
  произвольной заданной разрядностью.
  % This is the program used to calculate them to greater and greater precision.

  Например, мы можем написать программу, вычисляющую для заданного \alert{$n$} 
  первые \alert{$n$}~знаков числа~\alert{$\pi$} или же рациональное число~\alert{$r$}
  такое, что~\alert{$|\pi - r| < 2^{-n}$} .
  % For example, we can write a program that will produce for any argument \alert{
  %   $n$} the first \alert{$n$} digits of \alert{$\pi$}.

  % Alternatively it can produce a rational number \alert{$r$} such that
  % \alert{$|\pi - r| < 2^{-n}$}.

  Независимо от того, какой из подходов был выбран для последовательного 
  уточнения вещественного числа, важнейшим его свойством является конечность
  программы-представления.
  % Whatever approach is taken to the successive approximation of a real number,
  % the key point is that its representation, the program itself, is finite.
}

\frame{
  \frametitle{Выбор представления вещественных чисел}
  % \heading{Our representation of reals}

  Каждому вещественному числу~\alert{$x$} поставим в соответствие 
  такую функцию~\alert{$f_x:\nat \to \num$}, что для 
  произвольного~\alert{$n \in \nat$}: \alert{$$ |f_x(n) - 2^n x| < 1.$$}%
  В свою очередь, данное выражение эквивалентно
  \alert{$$ |{f_x(n) \over 2^n} - x| < {1 \over 2^n}.$$}%
  Арифметические операции над числами в таком представлении могут быть определены
  с использованием функций высшего порядка.
  % We  represent a real \alert{$x$} by a function \alert{$f_x:\nat \to \num$} that
  % for each \alert{$n \in \nat$}:
  % \alert{$$ |f_x(n) - 2^n x| < 1 $$}
  % This is of course equivalent to
  % \alert{$$ |{f_x(n) \over 2^n} - x| < {1 \over 2^n} $$}
  % We can actually represent the arithmetic operations on numbers as
  % higher order functions.

  Определив аппроксимирующие функции для~\alert{$x$} и~\alert{$y$}, мы можем 
  построить на их основе аппроксимацию для обширного семейства функций, 
  таких как~\alert{$x + y$}, \alert{$x y$}, \alert{$\sin(x)$} и прочих.
  % Given functions for approximating \alert{$x$} and \alert{$y$},
  % will produce new ones for approximating \alert{$x + y$}, \alert{$x
  %   y$}, \alert{$sin(x)$} and so on, for a wide range of functions.

  Полученные выражения являются точными, поскольку обеспечивают автоматическое 
  вычисление требуемых выражений с любой заданной разрядностью.
  % Such a result is exact, in the sense that we can then give it an arbitrary
  % desired precision and it will perform the appropriate calculation
  % automatically.
}



\frame{
  \frametitle{Целые числа произвольной разрядности}
  % \heading{Arbitrary precision integers}

  Стандартный целочисленный тип ({\tt int}) в CAML имет довольно
  ограниченный диапазон представимых значений, поэтому нам прежде
  всего потребуется возможность оперировать целыми числами
  неограниченной разрядности.
  % CAML's standard integers (type {\black \tt int}) have a severely
  % limited range, so first of all we need to set up a type of
  % unlimited-precision integers.

  Версия CAML Light, установленная на Thor, включает библиотеку быстрых 
  алгоритмов целочисленной (на самом деле, рациональной) арифметики. 
  Запуск программ следует производить так: 
  % The CAML release includes a library that gives a fast implementation of
  % arbitrary precision integer (and in fact rational) arithmetic.
  % 
  % A version of CAML Light with this library pre-loaded is installed on Thor. Just
  % run it with:

  \MyLitCam

  затем, для получения доступа ко всем функциям:
  % then do the following to get access to all the functions:

  \MyLitCamNum

  В библиотеке определяется новый тип данных {\tt num}, представляющий
  рациональные числа произвольной разрядности, среди которых нам понадобится 
  лишь подмножество целых чисел.
  % This library sets up a new type {\black \tt num} of arbitrary precision rational
  % numbers; we will just use the integer subset.
}



\frame{
  \frametitle{Операции над типом {\tt num}}
  % \heading{Operators on {\black \tt num}}

  Язык CAML не предоставляет возможности перегрузки операций, поэтому
  для обозначения арифметических действий над~{\tt num} приходится
  использовать другие символы.
  % CAML does not provide overloading, so it is necessary to use different symbols
  % for the usual arithmetic operations over {\black \tt num}.

  Отметим, что числа-константы типа~{\tt num} должны задаваться
  как~{\tt Int k}, а не просто~{\tt k}.
  % Note that small constants of type {\black \tt num} must be written
  % as {\black \tt Int k} rather than simply {\black \tt k}.

  Унарная операция смены знака величины типа~{\tt num}
  обозначается~{\tt minus\_num}. Ещё одна полезная унарная
  операция~--- {\tt abs\_num}, которая вычисляет абсолютную величину
  аргумента, т.~е.\ по заданному~\alert{$x$} возвращает~\alert{$|x|$}.
  % The unary negation on type {\black \tt num} is written {\black \tt
  %   minus\_num}. Another handy unary operator is {\black \tt
  %   abs\_num}, which finds absolute values, i.e. given \alert{$x$}
  % returns \alert{$|x|$}.

  Помимо унарных, в наше распоряжение предоставлен стандартный набор
  бинарных операций. Операции целочисленного деления и вычисления
  остатка, обозначенные~{\tt quo\_num} и~{ \tt mod\_num}, не являются
  инфиксными. В то же время, большинство прочих бинарных операций
  определены как инфиксные с именами, полученными добавлением
  символа~<<{\tt /}>> к именам аналогичных операций над
  типом~{\tt int}.
  % The usual complement of binary operations are also available. The
  % (truncating) division and modulus function, called {\black \tt
  %   quo\_num} and {\black \tt mod\_num}, do not have infix status.
  % However most of the other binary operators are infixes, and the
  % names are derived from the usual ones by adding a slash <<{black
  %   verb!/!}>>.
}

\frame{
  \frametitle{Бинарные операции}
  % \heading{Binary operators}

  \bigskip
  \begin{tabular}{|l|l|l|}
    \hline
    Оп.         & Тип                              & Значение              \\
    % Op         & Type                             & Meaning               \\
    \hline
    {\tt **/}  & {\tt num -> num -> num}          & Возведение в степень        \\
    {\tt */}   & {\tt num -> num -> num}          & Умножение             \\
    {\tt +/}   & {\tt num -> num -> num}          & Сложение              \\
    {\tt -/}   & {\tt num -> num -> num}          & Вычитание             \\
    {\tt =/}   & {\tt num -> num -> bool}         & Равенство             \\
    {\tt <>/}  & {\tt num -> num -> bool}         & Неравенство           \\
    {\tt </}   & {\tt num -> num -> bool}         & Меньше, чем           \\
    {\tt <=/}  & {\tt num -> num -> bool}         & Меньше либо равно     \\
    {\tt >/}   & {\tt num -> num -> bool}         & Больше, чем           \\
    {\tt >=/}  & {\tt num -> num -> bool}         & Больше либо равно     \\
    % {\tt **/}  & {\tt num -> num -> num}          & Exponentiation        \\
    % {\tt */}   & {\tt num -> num -> num}          & Multiplication        \\
    % {\tt +/}   & {\tt num -> num -> num}          & Addition              \\
    % {\tt -/}   & {\tt num -> num -> num}          & Subtraction           \\
    % {\tt =/}   & {\tt num -> num -> bool}         & Equality              \\
    % {\tt <>/}  & {\tt num -> num -> bool}         & Inequality            \\
    % {\tt </}   & {\tt num -> num -> bool}         & Less than             \\
    % {\tt <=/}  & {\tt num -> num -> bool}         & Less or equal         \\
    % {\tt >/}   & {\tt num -> num -> bool}         & Greater than          \\
    % {\tt >=/}  & {\tt num -> num -> bool}         & Greater or equal      \\
    \hline
  \end{tabular}
  \bigskip
}



\frame{
  \frametitle{Реализация}

  % \heading{Getting started}



  Напомним, что для вещественных чисел нами было выбрано представление
  в виде функций~\alert{$\num \to \num$}.
  % ISSUE: Z -> Z should be probably N -> Z ???
  % Recall that our real numbers are supposed to be (represented by) functions
  % \alert{$\num \to \num$}.

  Реализация на языке~ML в действительности будет использовать {\tt
    int~->~num}, поскольку диапазона значений встроенного
  целочисленного типа вполне достаточно для задания требуемой
  разрядности.
  % In ML we will actually use {\black \tt int -> num}, since the inbuilt
  % type of integers is more than adequate for indexing the level of accuracy.

  Определим некоторые базовые операции над вещественными числами. Наиболее
  фундаментальная операция, с которой мы начнём, ставит в соответствие заданному
  целому вещественное число. Её реализация проста:
  % Now we can define some basic operations on reals. The most basic operation,
  % which gets us started, is to produce the real number corresponding to an
  % integer. This is easy:

  \RealOfInt

  Очевидно, эта операция удовлетворяет критерию аппроксимации~--- её погрешность
  равна нулю.
  % Evidently this satisfies the error criterion: in fact the error is zero.
}



\frame{
  \frametitle{Основные операции}
  % \heading{Basic operations}

  Определим первую нетривиальную операцию~--- смену знака.
  % Now we can define the first nontrivial operation, that of unary
  % negation:

  \SignChange

  Компилятор для этой функции выводит более общий тип, чем требуется, но это
  не создаст трудностей. Достаточно легко убедиться, что критерий аппроксимации
  не нарушается. Если нам известно, что для любого~\alert{$n$} справедливо
  %% ISSUE: check this
  % The compiler generalizes the type more than intended, but this will not trouble
  % us. It is almost as easy to see that the approximation criterion is preserved.
  % If we know that for each \alert{$n$}:
  \alert{$$ |f_x(n) - 2^n x| < 1, $$}%
  то из этого следует:
  % \noindent then we have for any \alert{$n$}:
  \alert{\begin{eqnarray*}
      |f_{-x}(n) - 2^n (-x)| & = & |-f_x(n) - 2^n (-x)|       \\
      & = & |-(f_x(n) - 2^n x)|        \\
      & = & |f_x(n) - 2^n x|           \\
      & < & 1
    \end{eqnarray*}}%
  Аналогично, мы можем определить вычисление абсолютной величины вещественных 
  чисел, используя функцию~{\tt abs\_num}.
  % Similarly, we can define an <<absolute value>> function on real numbers, using
  % the corresponding function {\black \tt abs\_num} on numbers.
}



\frame{
  \frametitle{Сложение: первая попытка}
  % \heading{Addition: first attempt}

  Мы могли бы определить операцию сложения следующим образом:
  % We could define:

  \alert{$$ f_{x + y}(n) = f_x(n) + f_y(n) $$}

  Однако, такое определение не гарантирует соблюдения критерия аппроксимации:
  % However this gives no guarantee that the approximation criterion is maintained;
  % we would have:

  \alert{\begin{eqnarray*}
      &      & |f_{x + y}(n) - 2^n (x + y)| \\
      & =    & |f_x(n) + f_y(n) - 2^n (x + y)|      \\
      & \leq & |f_x(n) - 2^n x| + |f_y(n) - 2^n y|
    \end{eqnarray*}}

  Можно утверждать, что сумма в правой части неравенства не превышает~\alert{$2$}, 
  в то время, как критерий ограничивает нас~\alert{$1$}. Следовательно, в данном 
  случае нам требуется вычислить~\alert{$x$} и~\alert{$y$} с {\em большей} 
  разрядностью, чем требуется от результата операции.
  % We can guarantee that the sum on the right is less than
  % \alert{$2$}, but not that it is less than \alert{$1$} as required.
  % Therefore, we need in this case to evaluate \alert{$x$} and
  % \alert{$y$} to {\em greater} accuracy than required in the answer.
}



\frame{
  \frametitle{Сложение: вторая попытка}
  % \heading{Addition: second attempt}

  Предположим, что сложение определено так:
  % Suppose we define:
  \alert{$$ f_{x + y}(n) = (f_x(n + 1) + f_y(n + 1)) / 2 $$}%
  В этом случае погрешность 
  % \noindent Now we have:
  \alert{\begin{eqnarray*}
      &   & |f_{x + y}(n) - 2^n (x + y)|                              \\
      & = & |(f_x(n + 1) + f_y(n + 1)) / 2 - 2^n (x + y)|             \\
      & \leq & |f_x(n + 1) / 2 - 2^n x| + |f_y(n + 1) / 2 - 2^n y|    \\
      & = & {1 \over 2} |f_x(n + 1) - 2^{n + 1} x| +
      {1 \over 2} |f_y(n + 1) - 2^{n + 1} y|                    \\
      & < & {1 \over 2} 1 + {1 \over 2} 1 = 1.
    \end{eqnarray*}}

  Очевидно, что такое определение достигает желаемой точности. Однако, в нём
  неявно используется операция деления вещественных чисел. Поскольку функция
  должна возвращать целочисленный результат, частное требуется округлить.
  % Apparently this just gives the accuracy required. However we have implicitly
  % used real mathematical division above. Since the function is supposed to yield
  % an integer, we are obliged to round the quotient to an integer.
}



\frame{
  \frametitle{Деление с округлением}
  % \heading{Rounding division}

  Если мы вычислим частное при помощи {\tt quo\_num}, ошибка
  округления составит почти~\alert{$1$} и не позволит достичь
  требуемой точности независимо от точности вычисления аргументов.
  % If we just use {\black \tt quo\_num}, the error from rounding this
  % might be almost \alert{$1$}, after which we could never guarantee
  % the bound we want, however accurately we evaluate the arguments.

  Нам требуется операция деления с округлением, которая всегда возвращает целое,
  ближайшее к~точному результату (или одно из двух ближайших, если расстояние 
  до них оказывается одинаковым), так что ошибка округления никогда не 
  превысит~\alert{$1 \over 2$}.
  % We need a division function that always returns the integer closest to the true
  % result (or one of them in the case of two equally close ones), so that the
  % rounding error never exceeds \alert{$1 \over 2$}.

  \DivWithDiv

  Наше определение корректной операции сложения почти завершено!
  % Now we are ready to define a correct addition function!
}



\frame{
  \frametitle{Сложение: третья попытка (1)}
  % \heading{Addition: third attempt}

  Если мы определим операцию сложения как
  % Now if we define:
  \alert{$$ f_{x + y}(n) = (f_x(n + 2) + f_y(n + 2)) \mbox{ ndiv } 4,$$}%
  всё будет работать, как требуется:
  % \noindent everything works:
  \alert{\begin{eqnarray*}
      &      & |f_{x + y}(n) - 2^n (x + y)|                                   \\
      & =    & |((f_x(n + 2) + f_y(n + 2)) \mbox{ ndiv } 4) - 2^n (x + y)|    \\
      & \leq & {1 \over 2} + |(f_x(n + 2) + f_y(n + 2)) / 4 - 2^n (x + y)|    \\
      & =    & {1 \over 2} + {1 \over 4} |(f_x(n + 2) + f_y(n + 2)) -
      2^{n + 2}(x + y)|                  \\
      & \leq & {1 \over 2} + {1 \over 4} |f_x(n + 2) - 2^{n + 2} x| +         \\
      &      &               {1 \over 4} |f_y(n + 2) - 2^{n + 2} y|           \\
      & <    & {1 \over 2} + {1 \over 4} 1 + {1 \over 4} 1 = 1
    \end{eqnarray*}}
}

\frame{
  \frametitle{Сложение: третья попытка (2)}
  % \heading{Addition: third attempt}

  Программная реализация:
  % \noindent Accordingly we make our definition:
  \AddProg
}

\frame{
  \frametitle{Умножение на целое число (1)}
  % \heading{Multiplication by an integer (1)}

  По соображениям эффективности, данный частный случай заслуживает отдельного
  рассмотрения. Определим
  % It's worth treating this special case efficiently.
  % We define:
  \alert{$$ f_{m x}(n) = (m f_x(n+p+1)) \mbox{ ndiv } 2^{p+1}, $$}%
  где \alert{$p$}~выбирается так, чтобы~\alert{$2^p \geq |m|$}. Корректность такого
  определения легко доказать:
  % \noindent where \alert{$p$} is chosen so that \alert{$2^p \geq
  %   |m|$}. For correctness, we have:

  \alert{\begin{eqnarray*}
      &      & |f_{m x}(n) - 2^n (m x)|                                       \\
      & \leq & {1 \over 2} + |{m f_x(n+p+1) \over 2^{p+1}} - 2^n (m x)|       \\
      & =    & {1 \over 2} + {|m| \over 2^{p+1}} |f_x(n+p+1) - 2^{n+p+1} x|   \\
      & <    & {1 \over 2} + {|m| \over 2^{p+1}}                              \\
      & \leq & {1 \over 2} + {1 \over 2} {|m| \over 2^p}                      \\
      & \leq & {1 \over 2} + {1 \over 2} = 1
    \end{eqnarray*}}
}



\frame{
  \frametitle{Умножение на целое число (2)}
  % \heading{Multiplication by an integer (2)}

  Реализация этой операции требует вычисления подходящего
  значения~\alert{$p$}:
  % In order to implement this, we need a function to find the
  % appropriate \alert{$p$}:

  \MulProg

  Учитывая сказанное выше, операция умножения реализуется так:
  % \noindent The implementation is simply:

  \MulSimpleProg

  Деление на целое число вводится следующим образом:
  % \noindent For division by an integer, we define:
  \alert{$$ f_{x / m}(n) = f_x(n) \mbox{ ndiv } m $$}
}



\frame{
  \frametitle{Умножение: общий случай}
  % \heading{General multiplication}

  Определить умножение в общем случае труднее, поскольку погрешность 
  аппроксимации одного из сомножителей умножается на порядок второго. 
  Следовательно, нам потребуется предварительно оценить порядки сомножителей.
  % This is harder because the error in approximation for one number is multiplied
  % by the magnitude of the second number. We need a first evaluation to determine
  % their approximate magnitude.

  \MulEx

  Оценка погрешности такого определения громоздка, но не слишком сложна.
  % The error analysis is long but not really difficult.
}



\frame{
  \frametitle{Обратные числа (1)}
  % \heading{Multiplicative inverse (1)}

  Чтобы получить любую верхнюю оценку обратного числа, не говоря уж о хорошем
  его приближении, нам потребуется оценить аргумент {\em снизу}.
  % In order to get any sort of upper bound on the inverse, let alone a good
  % approximation, we need to get a {\em lower} bound for the argument.

  Прежде всего, зададим функцию~{\tt msd}:
  % So first define the {\black \tt msd} function:

  \MsdProg

  Эта функция вычисляет наименьшее~\alert{$n$}, для которого 
  справедливо~\alert{$|f_x(n) | > 1$}.
  % This finds the first \alert{$n$} with \alert{$|f_x(n) | > 1$}.

  Отметим, что при~\alert{$x = 0$} произойдёт зацикливание. Эта проблема 
  неизбежна, поскольку равенство вещественных чисел, подобно равенству функций,
  в общем случае алгоритмически неразрешимо.
  % Note that if \alert{$x = 0$} then this will loop indefinitely. This problem is
  % inevitable since equality of reals, like equality of functions, is not
  % computable.

  При этом для~\alert{$x \not= 0$} алгоритм, заданный выше, завершается
  за конечное время.
  % However if \alert{$x \not= 0$} the above must terminate eventually.
}



\frame{
  \frametitle{Обратные числа (2)}
  % \heading{Multiplicative inverse (2)}

  Перейдём к реализации вычисления обратного числа:
  % Now we can code the inverse.

  \RealMulInvProg

  С учётом изложенного ранее, определение операции деления становится тривиальным:
  % Now, of course, it is straightforward to define division:

  \RealDivInvProg
}



\frame{
  \frametitle{Отношения порядка и равенства}
  % \heading{Ordering and equality}

  Для определения взаимного порядка~\alert{$x$} и~\alert{$y$}
  достаточно найти~\alert{$n$} такое, что~\alert{$|f_x(n) - f_y(n)|
    \geq 2$}. Например, если~\alert{$f_x(n) \geq f_y(n) + 2$}, то
  \alert{$$ 2^n x > f_x(n) - 1 \geq f_y(n) + 1 > 2^n y,$$}%
  из чего следует~\alert{$x > y$}.
  % To decide the ordering relation of \alert{$x$} and \alert{$y$} it suffices to
  % find an \alert{$n$} such that \alert{$|f_x(n) - f_y(n)| \geq 2$}. For example, if
  % \alert{$f_x(n) \geq f_y(n) + 2$} we have
  % \alert{$$ 2^n x > f_x(n) - 1 \geq f_y(n) + 1 > 2^n y $$}
  % \noindent and so \alert{$x > y$}.

  \OrderProg

  Отметим, что единственным способом реализации рефлексивных отношений
  порядка будет положить их тождественными соответствующим
  нерефлексивным отношениям.  В целом, для~\alert{$x = y$} любые
  попытки определить их взаимный порядок приведут к зацикливанию.
  % Note that the only way to arrive at the reflexive orderings is to
  % justify the irreflexive version. In general, all these will fail
  % to terminate if \alert{$x = y$}.
}

\frame{
  \frametitle{Тестирование (1)}
  % \heading{Testing}

  Прежде всего, определим функцию отображения вещественных чисел:
  % We first define a function to show us a real:
  \View
}

\frame{
  \frametitle{Тестирование (2)}
  После этого мы можем протестировать нашу реализацию вещественной арифметики 
  на простых примерах:
  % Now we can test out some simple examples:
  \Testing
}

\frame{
  \frametitle{Избыточные вычисления}
  % \heading{The problem of reevaluation}

  Данный пример выполняется крайне медленно:
  % The following is very slow:

  \Reevaluation

  Причиной этого служит повторяющееся вычисление одних и тех же выражений.
  Ситуация ухудшается ещё и тем, что умножение и вычисление обратного числа
  обращаются к своим аргументам более одного раза. Это ведёт к экспоненциальному
  росту сложности вычислений.
  % The problem is the repeated evaluation of the same expression. This is worse
  % because multiplication and inversion often evaluate their arguments more than
  % once. This tends to lead to a blowup exponential in the depth of the
  % expression.
}

\frame{
  \frametitle{Кэширование}
  % \heading{Caching}

  Мы можем решить проблему, наделив наши функции <<памятью>>.
  % We can solve the problem by giving each function a <<memo>>.

  Если функция будет хранить наиболее точное значение, которое уже
  было вычислено, то при попытке вычислить его повторно или при
  вычислении менее точного значения, сохранённое может быть просто
  использовано повторно.
  % It will remember the most accurate result it has already calculated. If asked
  % for the same one, or a less accurate one, it can take it from the store.

  Исходя из~\alert{$|f_x(n + k) - 2^{n + k} x| < 1$}, мы получаем:
  % If we know that \alert{$|f_x(n + k) - 2^{n + k} x| < 1$} then we have:
  \alert{\begin{eqnarray*}
      &      & |f_x(n + k) \mbox{ ndiv } 2^ k - 2^n x|                        \\
      & \leq & {1 \over 2} + |{f_x(n + k) \over 2^k} - 2^n x|                 \\
      & =    & {1 \over 2} + {1 \over 2^k} |f_x(n + k) - 2^{n + k} x|         \\
      & <    & {1 \over 2} + {1 \over 2^k}                                    \\
      & \leq & 1
    \end{eqnarray*}}

  Отсюда следует, что возвращаемое значение~\alert{$f_x(n + k) \mbox{ ndiv } 2^k$}
  не вызовет проблем.
  % Hence we are always safe in returning \alert{$f_x(n + k) \mbox{ ndiv } 2^k$}.
}

\frame{
  \frametitle{Функция {\tt memo}}
  % \heading{Memo function}

  Для упрощения реализации вычислений с <<памятью>> введём следующую функцию:
  % We can use the following generic function to attach a memo to a
  % function:
  \MemoFunc

  Систематическое использование этой функции в определении операций
  существенно повышает их эффективность.
  % Now we systematically insert this in each operator. The resulting system is
  % much more efficient.
  \RealAddMemo
}

\end{document}
